Title: Managing Fragments in Streamlit
URL: https://docs.streamlit.io/develop/concepts/architecture/fragments
Summary: To manage elements within containers in Streamlit, utilize `st.empty` to prevent element accumulation. For executing a full-script rerun from a fragment, use `st.rerun`. The `st.fragment` feature includes a `run_every` parameter to automate reruns at specified intervals.
---

To prevent elements from accumulating in outside containers, use [`st.empty`](https://docs.streamlit.io/develop/api-reference/layout/st.empty) containers. For a related tutorial, see [Create a fragment across multiple containers](https://docs.streamlit.io/develop/tutorials/execution-flow/create-a-multiple-container-fragment).
If you need to trigger a full-script rerun from inside a fragment, call [`st.rerun`](https://docs.streamlit.io/develop/api-reference/execution-flow/st.rerun). For a related tutorial, see [Trigger a full-script rerun from inside a fragment](https://docs.streamlit.io/develop/tutorials/execution-flow/trigger-a-full-script-rerun-from-a-fragment).
## [](https://docs.streamlit.io/develop/concepts/architecture/fragments#automate-fragment-reruns)Automate fragment reruns
`st.fragment` includes a convenient `run_every` parameter that causes the fragment to rerun automatically at the specified time interval. These reruns are in addition to any reruns (fragment or full-script) triggered by your user. The automatic fragment reruns will continue even if your user is not interacting with your app. This is a great way to show a live data stream or status on a running background job, efficiently updating your rendered data and _only_ your rendered data.
`@st.fragment(run_every="10s") def auto_function(): # This will update every 10 seconds! 		df = get_latest_updates() 		st.line_chart(df) auto_function() `
For a related tutorial, see [Start and stop a streaming fragment](https://docs.streamlit.io/develop/tutorials/execution-flow/start-and-stop-fragment-auto-reruns).
## [](https://docs.streamlit.io/develop/concepts/architecture/fragments#compare-fragments-to-other-streamlit-features)Compare fragments to other Streamlit features
### [](https://docs.streamlit.io/develop/concepts/architecture/fragments#fragments-vs-forms)Fragments vs forms
Here is a comparison between fragments and forms:
  * **Forms** allow users to interact with widgets without rerunning your app. Streamlit does not send user actions within a form to your app's Python backend until the form is submitted. Widgets within a form can not dynamically update other widgets (in or out of the form) in real-time.
  * **Fragments** run independently from the rest of your code. As your users interact with fragment widgets, their actions are immediately processed by your app's Python backend and your fragment code is rerun. Widgets within a fragment can dynamically update other widgets within the same fragment in real-time.


A form batches user input without interaction between any widgets. A fragment immediately processes user input but limits the scope of the rerun.
### [](https://docs.streamlit.io/develop/concepts/architecture/fragments#fragments-vs-callbacks)Fragments vs callbacks
Here is a comparison between fragments and callbacks:
  * **Callbacks** allow you to execute a function at the beginning of a script rerun. A callback is a _single prefix_ to your script rerun.
  * **Fragments** allow you to rerun a portion of your script. A fragment is a _repeatable postfix_ to your script, running each time a user interacts with a fragment widget, or automatically in sequence when `run_every` is set.


When callbacks render elements to your page, they are rendered before the rest of your page elements. When fragments render elements to your page, they are updated with each fragment rerun (unless they are written to containers outside of the fragment, in which case they accumulate there).
### [](https://docs.streamlit.io/develop/concepts/architecture/fragments#fragments-vs-custom-components)Fragments vs custom components
Here is a comparison between fragments and custom components:
  * **Components** are custom frontend code that can interact with the Python code, native elements, and widgets in your Streamlit app. Custom components extend whatâ€™s possible with Streamlit. They follow the normal Streamlit execution flow.
  * **Fragments** are parts of your app that can rerun independently of the full app. Fragments can be composed of multiple Streamlit elements, widgets, or any Python code.


A fragment can include one or more custom components. A custom component could not easily include a fragment!
### [](https://docs.streamlit.io/develop/concepts/architecture/fragments#fragments-vs-caching)Fragments vs caching
Here is a comparison between fragments and caching:
  * **Caching:** allows you to skip over a function and return a previously computed value. When you use caching, you execute everything except the cached function (if you've already run it before).
  * **Fragments:** allow you to freeze most of your app and just execute the fragment. When you use fragments, you execute only the fragment (when triggering a fragment rerun).