Title: Using Buttons to Manage Stages in Streamlit
URL: https://docs.streamlit.io/develop/concepts/design/buttons
Summary: This section outlines the mechanics of using buttons to control different stages in a Streamlit application. It explains how to advance and reset stages with buttons, and the importance of callbacks for maintaining visible stages. The provided code example demonstrates setting and tracking stages using session state, and managing user inputs with callbacks.
---

A button at the beginning advances the stage from 0 to 1. A button at the end resets the stage from 3 to 0. The other widgets used in stage 1 and 2 have callbacks to set the stage. If you have a process with dependant steps and want to keep previous stages visible, such a callback forces a user to retrace subsequent stages if they change an earlier widget.
`import streamlit as st if 'stage' not in st.session_state:   st.session_state.stage = 0 def set_state(i):   st.session_state.stage = i if st.session_state.stage == 0:   st.button('Begin', on_click=set_state, args=[1]) if st.session_state.stage >= 1:   name = st.text_input('Name', on_change=set_state, args=[2]) if st.session_state.stage >= 2:   st.write(f'Hello {name}!')   color = st.selectbox( 'Pick a Color', [None, 'red', 'orange', 'green', 'blue', 'violet'],     on_change=set_state, args=[3] ) if color is None:     set_state(2) if st.session_state.stage >= 3:   st.write(f':{color}[Thank you!]')   st.button('Start Over', on_click=set_state, args=[0]) `
### [](https://docs.streamlit.io/develop/concepts/design/buttons#buttons-to-modify-stsession_state)Buttons to modify `st.session_state`
If you modify `st.session_state` inside of a button, you must consider where that button is within the script.
#### [](https://docs.streamlit.io/develop/concepts/design/buttons#a-slight-problem)A slight problem
In this example, we access `st.session_state.name` both before and after the buttons which modify it. When a button ("**Jane** " or "**John** ") is clicked, the script reruns. The info displayed before the buttons lags behind the info written after the button. The data in `st.session_state` before the button is not updated. When the script executes the button function, that is when the conditional code to update `st.session_state` creates the change. Thus, this change is reflected after the button.
`import streamlit as st import pandas as pd if 'name' not in st.session_state:   st.session_state['name'] = 'John Doe' st.header(st.session_state['name']) if st.button('Jane'):   st.session_state['name'] = 'Jane Doe' if st.button('John'):   st.session_state['name'] = 'John Doe' st.header(st.session_state['name']) `
#### [](https://docs.streamlit.io/develop/concepts/design/buttons#logic-used-in-a-callback)Logic used in a callback
Callbacks are a clean way to modify `st.session_state`. Callbacks are executed as a prefix to the script rerunning, so the position of the button relative to accessing data is not important.
`import streamlit as st import pandas as pd if 'name' not in st.session_state:   st.session_state['name'] = 'John Doe' def change_name(name):   st.session_state['name'] = name st.header(st.session_state['name']) st.button('Jane', on_click=change_name, args=['Jane Doe']) st.button('John', on_click=change_name, args=['John Doe']) st.header(st.session_state['name']) `
#### [](https://docs.streamlit.io/develop/concepts/design/buttons#logic-nested-in-a-button-with-a-rerun)Logic nested in a button with a rerun
Although callbacks are often preferred to avoid extra reruns, our first 'John Doe'/'Jane Doe' example can be modified by adding [`st.rerun`](https://docs.streamlit.io/develop/api-reference/execution-flow/st.rerun) instead. If you need to acces data in `st.session_state` before the button that modifies it, you can include `st.rerun` to rerun the script after the change has been committed. This means the script will rerun twice when a button is clicked.
`import streamlit as st import pandas as pd if 'name' not in st.session_state:   st.session_state['name'] = 'John Doe' st.header(st.session_state['name']) if st.button('Jane'):   st.session_state['name'] = 'Jane Doe'   st.rerun() if st.button('John'):   st.session_state['name'] = 'John Doe'   st.rerun() st.header(st.session_state['name']) `
### [](https://docs.streamlit.io/develop/concepts/design/buttons#buttons-to-modify-or-reset-other-widgets)Buttons to modify or reset other widgets
When a button is used to modify or reset another widget, it is the same as the above examples to modify `st.session_state`. However, an extra consideration exists: you cannot modify a key-value pair in `st.session_state` if the widget with that key has already been rendered on the page for the current script run.
_priority_high_
#### Important
Don't do this!
`import streamlit as st st.text_input('Name', key='name') # These buttons will error because their nested code changes # a widget's state after that widget within the script. if st.button('Clear name'):   st.session_state.name = '' if st.button('Streamlit!'):   st.session_state.name = ('Streamlit') `
#### [](https://docs.streamlit.io/develop/concepts/design/buttons#option-1-use-a-key-for-the-button-and-put-the-logic-before-the-widget)Option 1: Use a key for the button and put the logic before the widget
If you assign a key to a button, you can condition code on a button's state by using its value in `st.session_state`. This means that logic depending on your button can be in