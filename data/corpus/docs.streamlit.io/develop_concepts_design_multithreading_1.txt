Title: Multithreading in Streamlit
URL: https://docs.streamlit.io/develop/concepts/design/multithreading
Summary: This section discusses multithreading in Streamlit, emphasizing its role in improving program efficiency through concurrency. It notes that while Streamlit's architecture utilizes threads, the platform does not officially support multithreading in app code. A basic understanding of Streamlit's architecture is recommended as a prerequisite.
---

# [](https://docs.streamlit.io/develop/concepts/design/multithreading#multithreading-in-streamlit)Multithreading in Streamlit
Multithreading is a type of concurrency, which improves the efficiency of computer programs. It's a way for processors to multitask. Streamlit uses threads within its architecture, which can make it difficult for app developers to include their own multithreaded processes. Streamlit does not officially support multithreading in app code, but this guide provides information on how it can be accomplished.
## [](https://docs.streamlit.io/develop/concepts/design/multithreading#prerequisites)Prerequisites
  * You should have a basic understanding of Streamlit's [architecture](https://docs.streamlit.io/develop/concepts/architecture/architecture).


## [](https://docs.streamlit.io/develop/concepts/design/multithreading#when-to-use-multithreading)When to use multithreading
Multithreading is just one type of concurrency. Multiprocessing and coroutines are other forms of concurrency. You need to understand how your code is bottlenecked to choose the correct kind of concurrency.
Multiprocessing is inherently parallel, meaning that resources are split and multiple tasks are performed simultaneously. Therefore, multiprocessing is helpful with compute-bound operations. In contrast, multithreading and coroutines are not inherently parallel and instead allow resource switching. This makes them good choices when your code is stuck _waiting_ for something, like an IO operation. AsyncIO uses coroutines and may be preferable with very slow IO operations. Threading may be preferable with faster IO operations. For a helpful guide to using AsyncIO with Streamlit, see this [Medium article by Sehmi-Conscious Thoughts](https://sehmi-conscious.medium.com/got-that-asyncio-feeling-f1a7c37cab8b).
Don't forget that Streamlit has [fragments](https://docs.streamlit.io/develop/concepts/architecture/fragments) and [caching](https://docs.streamlit.io/develop/concepts/architecture/caching), too! Use caching to avoid unnecessarily repeating computations or IO operations. Use fragments to isolate a bit of code you want to update separately from the rest of the app. You can set fragments to rerun at a specified interval, so they can be used to stream updates to a chart or table.
## [](https://docs.streamlit.io/develop/concepts/design/multithreading#threads-created-by-streamlit)Threads created by Streamlit
Streamlit creates two types of threads in Python:
  * The **server thread** runs the Tornado web (HTTP + WebSocket) server.
  * A **script thread** runs page code â€” one thread for each script run in a session.