Title: Getting Started with Pytest for App Testing
URL: https://docs.streamlit.io/develop/concepts/app-testing/get-started
Summary: This section explains how to successfully execute tests using pytest in your project. It details how pytest scans Python files with the 'test_' prefix for test functions, counts successes, and itemizes failures. Additionally, it covers running pytest from a specific directory and the importance of using relative paths in test scripts.
---

The test should execute successfully. Your terminal should show something like this:
![A successfully completed test using pytest](https://docs.streamlit.io/images/app-testing-pytest-intro.png)
By executing `pytest` at the root of your project directory, all Python files with the test prefix (`test_<name>.py`) will be scanned for test functions. Within each test file, each function with the test prefix will be executed as a test. `pytest` then counts successes and itemizes failures. You can also direct `pytest` to only scan your testing directory. For example, from the root of your project directory, execute:
`pytest tests/ `
### [](https://docs.streamlit.io/develop/concepts/app-testing/get-started#handling-file-paths-and-imports-with-pytest)Handling file paths and imports with `pytest`
Imports and paths within a test script should be relative to the directory where `pytest` is called. That is why the test function uses the path `app.py` instead of `../app.py` even though the app file is one directory up from the test script. You'll usually call `pytest` from the directory containing your main app file. This is typically the root of your project directory.
Additionally, if `.streamlit/` is present in the directory where you call `pytest`, any `config.toml` and `secrets.toml` within it will be accessible to your simulated app. For example, your simulated app will have access to the `config.toml` and `secrets.toml` files in this common setup:
Project structure:
`myproject/ ├── .streamlit/ │  ├── config.toml │  └── secrets.toml ├── app.py └── tests/   └── test_app.py `
Initialization within `test_app.py`:
`# Path to app file is relative to myproject/ at = AppTest.from_file("app.py").run() `
Command to execute tests:
`cd myproject pytest tests/ `
## [](https://docs.streamlit.io/develop/concepts/app-testing/get-started#fundamentals-of-app-testing)Fundamentals of app testing
Now that you understand the basics of `pytest` let's dive into using Streamlit's app testing framework. Every test begins with initializing and running your simulated app. Additional commands are used to retrieve, manipulate, and inspect elements.
On the next page, we'll go [Beyond the basics](https://docs.streamlit.io/develop/concepts/app-testing/beyond-the-basics) and cover more advanced scenarios like working with secrets, Session State, or multipage apps.
### [](https://docs.streamlit.io/develop/concepts/app-testing/get-started#how-to-initialize-and-run-a-simulated-app)How to initialize and run a simulated app
To test a Streamlit app, you must first initialize an instance of [`AppTest`](https://docs.streamlit.io/develop/api-reference/app-testing/st.testing.v1.apptest) with the code for one page of your app. There are three methods for initializing a simulated app. These are provided as class methods to `AppTest`. We will focus on `AppTest.from_file()` which allows you to provide a path to a page of your app. This is the most common scenario for building automated tests during app development. `AppTest.from_string()` and `AppTest.from_function()` may be helpful for some simple or experimental scenarios.
Let's continue with the [example from above](https://docs.streamlit.io/develop/concepts/app-testing/get-started#example-project-with-app-testing).
Recall the testing file:
`"""test_app.py""" from streamlit.testing.v1 import AppTest def test_increment_and_add(): """A user increments the number input, then clicks Add"""   at = AppTest.from_file("app.py").run()   at.number_input[0].increment().run()   at.button[0].click().run() assert at.markdown[0].value == "Beans counted: 1" `
Look at the first line in the test function:
`at = AppTest.from_file("app.py").run() `
This is doing two things and is equivalent to:
`# Initialize the app. at = AppTest.from_file("app.py") # Run the app. at.run() `
`AppTest.from_file()` returns an instance of `AppTest`, initialized with the contents of `app.py`. The `.run()` method is used to run the app for the first time. Looking at the test, notice that the `.run()` method manually executes each script run. A test must explicitly run the app each time. This applies to the app's first run and any rerun resulting from simulated user input.
### [](https://docs.streamlit.io/develop/concepts/app-testing/get-started#how-to-retrieve-elements)How to retrieve elements
The attributes of the `AppTest` class return sequences of elements. The elements are sorted according to display order in the rendered app. Specific elements can be retrieved by index. Additionally, widgets with keys can be retrieved by key.
#### [](https://docs.streamlit.io/develop/concepts/app-testing/get-started#retrieve-elements-by-index)Retrieve elements by index
Each attribute of `AppTest` returns a sequence of the associated element type. Specific elements can be retrieved by index. In the above example, `at.number_input` returns a sequence of all `st.number_input` elements in the app. Thus, `at.number_input[0]` is the first such element in the app. S