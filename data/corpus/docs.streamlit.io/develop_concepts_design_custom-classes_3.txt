Title: Custom Classes in Streamlit
URL: https://docs.streamlit.io/develop/concepts/design/custom-classes
Summary: This section discusses best practices for defining custom classes in Streamlit, particularly focusing on the implementation of `__eq__` methods that do not depend on the type of the class to avoid issues with in-memory IDs. It also introduces a serialization approach using `to_str` and `from_str` methods to store class instance data in `st.session_state` instead of the instances themselves.
---

lar class or `@dataclass` depends on the in-memory ID of the class or class instance. To avoid problems in Streamlit, your custom `__eq__` method should not depend the `type()` of `self` and `other`.
### [](https://docs.streamlit.io/develop/concepts/design/custom-classes#pattern-3-store-your-class-as-serialized-data)Pattern 3: Store your class as serialized data
Another option for classes that store data is to define serialization and deserialization methods like `to_str` and `from_str` for your class. You can use these to store class instance data in `st.session_state` rather than storing the class instance itself. Similar to pattern 2, this is a way to force comparison of the internal data and bypass the changing in-memory IDs.
#### [](https://docs.streamlit.io/develop/concepts/design/custom-classes#example-save-your-class-instance-as-a-string)Example: Save your class instance as a string
Using the same example from pattern 2, this can be done as follows:
`import streamlit as st from dataclasses import dataclass @dataclass class MyDataclass:   var1: int   var2: float def to_str(self): return f"{self.var1},{self.var2}" @classmethod def from_str(cls, serial_str):     values = serial_str.split(",")     var1 = int(values[0])     var2 = float(values[1]) return cls(var1, var2) if "my_dataclass" not in st.session_state:   st.session_state.my_dataclass = MyDataclass(1, 5.5).to_str() # Displays True on every rerun MyDataclass.from_str(st.session_state.my_dataclass) == MyDataclass(1, 5.5) st.button("Rerun") `
### [](https://docs.streamlit.io/develop/concepts/design/custom-classes#pattern-4-use-caching-to-preserve-your-class)Pattern 4: Use caching to preserve your class
For classes that are used as resources (database connections, state managers, APIs), consider using the cached singleton pattern. Use `@st.cache_resource` to decorate a `@staticmethod` of your class to generate a single, cached instance of the class. For example:
`import streamlit as st class MyResource: def __init__(self, api_url: str):     self._url = api_url   @st.cache_resource(ttl=300) @staticmethod def get_resource_manager(api_url: str): return MyResource(api_url) # This is cached until Session State is cleared or 5 minutes has elapsed. resource_manager = MyResource.get_resource_manager("http://example.com/api/") `
When you use one of Streamlit's caching decorators on a function, Streamlit doesn't use the function object to look up cached values. Instead, Streamlit's caching decorators index return values using the function's qualified name and module. So, even though Streamlit redefines `MyResource` with each script run, `st.cache_resource` is unaffected by this. `get_resource_manager()` will return its cached value with each rerun, until the value expires.
## [](https://docs.streamlit.io/develop/concepts/design/custom-classes#understanding-how-python-defines-and-compares-classes)Understanding how Python defines and compares classes
So what's really happening here? We'll consider a simple example to illustrate why this is a pitfall. Feel free to skip this section if you don't want to deal more details. You can jump ahead to learn about [Using `Enum` classes](https://docs.streamlit.io/develop/concepts/design/custom-classes#using-enum-classes-in-streamlit).
### [](https://docs.streamlit.io/develop/concepts/design/custom-classes#example-what-happens-when-you-define-the-same-class-twice)Example: What happens when you define the same class twice?
Set aside Streamlit for a moment and think about this simple Python script:
`from dataclasses import dataclass @dataclass class Student:   student_id: int   name: str Marshall_A = Student(1, "Marshall") Marshall_B = Student(1, "Marshall") # This is True (because a dataclass will compare two of its instances by value) Marshall_A == Marshall_B # Redefine the class @dataclass class Student:   student_id: int   name: str Marshall_C = Student(1, "Marshall") # This is False Marshall_A == Marshall_C `
In this example, the dataclass `Student` is defined twice. All three Marshalls have the same internal values. If you compare `Marshall_A` and `Marshall_B` they will be equal because they were both created from the first definition of `Student`. However, if you compare `Marshall_A` and `Marshall_C` they will not be equal because `Marshall_C` was created from the _second_ definition of `Student`. Even though both `Student` dataclasses are defined exactly the same, they have different in-memory IDs and are therefore different.
### [](https://docs.streamlit.io/develop/concepts/design/custom-classes#whats-happening-in-streamlit)What's happening in Streamlit?
In Streamlit, you probably don't have the same class written twice in your page script. However, the rerun logic of Streamlit creates the same effect. Let's use the above example for an analogy.