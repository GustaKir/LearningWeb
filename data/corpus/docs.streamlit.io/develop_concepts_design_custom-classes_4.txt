Title: Managing Custom Classes and Streamlit Widgets
URL: https://docs.streamlit.io/develop/concepts/design/custom-classes
Summary: This section discusses the implications of defining custom classes in Streamlit and how they interact with Session State. It notes that saving class instances in Session State can lead to type comparison issues during reruns. Additionally, it explains how Streamlit widgets, such as `st.selectbox` and `st.radio`, handle multiple-choice options and save user selections.
---

If you define a class in one script run and save an instance in Session State, then a later rerun will redefine the class and you may end up comparing a `Mashall_C` in your rerun to a `Marshall_A` in Session State. Since widgets rely on Session State under the hood, this is where things can get confusing.
## [](https://docs.streamlit.io/develop/concepts/design/custom-classes#how-streamlit-widgets-store-options)How Streamlit widgets store options
Several Streamlit UI elements, such as `st.selectbox` or `st.radio`, accept multiple-choice options via an `options` argument. The user of your application can typically select one or more of these options. The selected value is returned by the widget function. For example:
`number = st.selectbox("Pick a number, any number", options=[1, 2, 3]) # number == whatever value the user has selected from the UI. `
When you call a function like `st.selectbox` and pass an `Iterable` to `options`, the `Iterable` and current selection are saved into a hidden portion of [Session State](https://docs.streamlit.io/develop/concepts/architecture/session-state) called the Widget Metadata.
When the user of your application interacts with the `st.selectbox` widget, the broswer sends the index of their selection to your Streamlit server. This index is used to determine which values from the original `options` list, _saved in the Widget Metadata from the previous page execution_ , are returned to your application.
The key detail is that the value returned by `st.selectbox` (or similar widget function) is from an `Iterable` saved in Session State during a _previous_ execution of the page, NOT the values passed to `options` on the _current_ execution. There are a number of architectural reasons why Streamlit is designed this way, which we won't go into here. However, **this** is how we end up comparing instances of different classes when we think we are comparing instances of the same class.
### [](https://docs.streamlit.io/develop/concepts/design/custom-classes#a-pathological-example)A pathological example
The above explanation might be a bit confusing, so here's a pathological example to illustrate the idea.
`import streamlit as st from dataclasses import dataclass @dataclass class Student:   student_id: int   name: str Marshall_A = Student(1, "Marshall") if "B" not in st.session_state:   st.session_state.B = Student(1, "Marshall") Marshall_B = st.session_state.B options = [Marshall_A,Marshall_B] selected = st.selectbox("Pick", options) # This comparison does not return expected results: selected == Marshall_A # This comparison evaluates as expected: selected == Marshall_B `
As a final note, we used `@dataclass` in the example for this section to illustrate a point, but in fact it is possible to encounter these same problems with classes, in general. Any class which checks class identity inside of a comparison operator—such as `__eq__` or `__gt__`—can exhibit these issues.
## [](https://docs.streamlit.io/develop/concepts/design/custom-classes#using-enum-classes-in-streamlit)Using `Enum` classes in Streamlit
The [`Enum`](https://docs.python.org/3/library/enum.html#enum.Enum) class from the Python standard library is a powerful way to define custom symbolic names that can be used as options for `st.multiselect` or `st.selectbox` in place of `str` values.
For example, you might add the following to your streamlit page:
`from enum import Enum import streamlit as st # class syntax class Color(Enum):   RED = 1   GREEN = 2   BLUE = 3 selected_colors = set(st.multiselect("Pick colors", options=Color)) if selected_colors == {Color.RED, Color.GREEN}:   st.write("Hooray, you found the color YELLOW!") `
If you're using the latest version of Streamlit, this Streamlit page will work as it appears it should. When a user picks both `Color.RED` and `Color.GREEN`, they are shown the special message.
However, if you've read the rest of this page you might notice something tricky going on. Specifically, the `Enum` class `Color` gets redefined every time this script is run. In Python, if you define two `Enum` classes with the same class name, members, and values, the classes and their members are still considered unique from each other. This _should_ cause the above `if` condition to always evaluate to `False`. In any script rerun, the `Color` values returned by `st.multiselect` would be of a different class than the `Color` defined in that script run.
If you run the snippet above with Streamlit version 1.28.0 or less, you will not be able see the special message. Thankfully, as of version 1.29.0, Streamlit introduced a configuration option to greatly simplify the problem.