Title: Custom Classes in Streamlit
URL: https://docs.streamlit.io/develop/concepts/design/custom-classes
Summary: This document discusses the challenges of using custom classes in Streamlit due to the script rerun after each user interaction. It provides general patterns for defining custom classes, explains the issues that can arise, and specifically addresses the use of `Enum` classes along with a configuration option to enhance their usability.
---

Because Streamlit reruns your script after every user interaction, custom classes may be redefined multiple times within the same Streamlit session. This may result in unwanted effects, especially with class and instance comparisons. Read on to understand this common pitfall and how to avoid it.
We begin by covering some general-purpose patterns you can use for different types of custom classes, and follow with a few more technical details explaining why this matters. Finally, we go into more detail about [Using `Enum` classes](https://docs.streamlit.io/develop/concepts/design/custom-classes#using-enum-classes-in-streamlit) specifically, and describe a configuration option which can make them more convenient.
## [](https://docs.streamlit.io/develop/concepts/design/custom-classes#patterns-to-define-your-custom-classes)Patterns to define your custom classes
### [](https://docs.streamlit.io/develop/concepts/design/custom-classes#pattern-1-define-your-class-in-a-separate-module)Pattern 1: Define your class in a separate module
This is the recommended, general solution. If possible, move class definitions into their own module file and import them into your app script. As long as you are not editing the files that define your app, Streamlit will not re-import those classes with each rerun. Therefore, if a class is defined in an external file and imported into your script, the class will not be redefined during the session, unless you are actively editing your app.
#### [](https://docs.streamlit.io/develop/concepts/design/custom-classes#example-move-your-class-definition)Example: Move your class definition
Try running the following Streamlit app where `MyClass` is defined within the page's script. `isinstance()` will return `True` on the first script run then return `False` on each rerun thereafter.
`# app.py import streamlit as st # MyClass gets redefined every time app.py reruns class MyClass: def __init__(self, var1, var2):     self.var1 = var1     self.var2 = var2 if "my_instance" not in st.session_state:  st.session_state.my_instance = MyClass("foo", "bar") # Displays True on the first run then False on every rerun st.write(isinstance(st.session_state.my_instance, MyClass)) st.button("Rerun") `
If you move the class definition out of `app.py` into another file, you can make `isinstance()` consistently return `True`. Consider the following file structure:
`myproject/ ├── my_class.py └── app.py `
`# my_class.py class MyClass: def __init__(self, var1, var2):     self.var1 = var1     self.var2 = var2 `
`# app.py import streamlit as st from my_class import MyClass # MyClass doesn't get redefined with each rerun if "my_instance" not in st.session_state:  st.session_state.my_instance = MyClass("foo", "bar") # Displays True on every rerun st.write(isinstance(st.session_state.my_instance, MyClass)) st.button("Rerun") `
Streamlit only reloads code in imported modules when it detects the code has changed. Thus, if you are actively editing your app code, you may need to start a new session or restart your Streamlit server to avoid an undesirable class redefinition.
### [](https://docs.streamlit.io/develop/concepts/design/custom-classes#pattern-2-force-your-class-to-compare-internal-values)Pattern 2: Force your class to compare internal values
For classes that store data (like [dataclasses](https://docs.python.org/3/library/dataclasses.html)), you may be more interested in comparing the internally stored values rather than the class itself. If you define a custom `__eq__` method, you can force comparisons to be made on the internally stored values.
#### [](https://docs.streamlit.io/develop/concepts/design/custom-classes#example-define-__eq__)Example: Define `__eq__`
Try running the following Streamlit app and observe how the comparison is `True` on the first run then `False` on every rerun thereafter.
`import streamlit as st from dataclasses import dataclass @dataclass class MyDataclass:   var1: int   var2: float if "my_dataclass" not in st.session_state:   st.session_state.my_dataclass = MyDataclass(1, 5.5) # Displays True on the first run the False on every rerun st.session_state.my_dataclass == MyDataclass(1, 5.5) st.button("Rerun") `
Since `MyDataclass` gets redefined with each rerun, the instance stored in Session State will not be equal to any instance defined in a later script run. You can fix this by forcing a comparison of internal values as follows:
`import streamlit as st from dataclasses import dataclass @dataclass class MyDataclass:   var1: int   var2: float def __eq__(self, other): # An instance of MyDataclass is equal to another object if the object # contains the same fields with the same values return (self.var1, self.var2) == (other.var1, other.var2) if "my_dataclass" not in st.session_state:   st.session_state.my_dataclass = MyDataclass(1, 5.5) # Displays True on every rerun st.session_state.my_dataclass == MyDataclass(1, 5.5) st.button("Rerun") `
The default Python `__eq__` implementation for a regu