Title: Streamlit Widget Behavior and ID Assignment
URL: https://docs.streamlit.io/develop/concepts/architecture/widget-behavior
Summary: Streamlit optimizes widget updates by assigning unique IDs based on widget parameters to avoid rebuilding on each rerun. Widgets with identical parameters on the same page trigger a `DuplicateWidgetID` error, necessitating unique keys for differentiation.
---

Whenever possible, Streamlit updates widgets incrementally on the frontend instead of rebuilding them with each rerun. This means Streamlit assigns an ID to each widget from the arguments passed to the widget function. A widget's ID is based on parameters such as label, min or max value, default value, placeholder text, help text, and key. The page where the widget appears also factors into a widget's ID. If you have two widgets of the same type with the same arguments on the same page, you will get a `DuplicateWidgetID` error. In this case, assign unique keys to the two widgets.
#### [](https://docs.streamlit.io/develop/concepts/architecture/widget-behavior#streamlit-cant-understand-two-identical-widgets-on-the-same-page)Streamlit can't understand two identical widgets on the same page
`# This will cause a DuplicateWidgetID error. st.button("OK") st.button("OK") `
#### [](https://docs.streamlit.io/develop/concepts/architecture/widget-behavior#use-keys-to-distinguish-otherwise-identical-widgets)Use keys to distinguish otherwise identical widgets
`st.button("OK", key="privacy") st.button("OK", key="terms") `
## [](https://docs.streamlit.io/develop/concepts/architecture/widget-behavior#order-of-operations)Order of operations
When a user interacts with a widget, the order of logic is:
  1. Its value in `st.session_state` is updated.
  2. The callback function (if any) is executed.
  3. The page reruns with the widget function returning its new value.


If the callback function writes anything to the screen, that content will appear above the rest of the page. A callback function runs as a _prefix_ to the script rerunning. Consequently, that means anything written via a callback function will disappear as soon as the user performs their next action. Other widgets should generally not be created within a callback function.
_push_pin_
#### Note
If a callback function is passed any args or kwargs, those arguments will be established when the widget is rendered. In particular, if you want to use a widget's new value in its own callback function, you cannot pass that value to the callback function via the `args` parameter; you will have to assign a key to the widget and look up its new value using a call to `st.session_state` _within the callback function_.
### [](https://docs.streamlit.io/develop/concepts/architecture/widget-behavior#using-callback-functions-with-forms)Using callback functions with forms
Using a callback function with a form requires consideration of this order of operations.
`import streamlit as st if "attendance" not in st.session_state:   st.session_state.attendance = set() def take_attendance(): if st.session_state.name in st.session_state.attendance:     st.info(f"{st.session_state.name} has already been counted.") else:     st.session_state.attendance.add(st.session_state.name) with st.form(key="my_form"):   st.text_input("Name", key="name")   st.form_submit_button("I'm here!", on_click=take_attendance) `
[Built with Streamlit ðŸŽˆ](https://streamlit.io)
[Fullscreen _open_in_new_](https://doc-guide-widgets-form-callbacks.streamlit.app/?utm_medium=oembed)
## [](https://docs.streamlit.io/develop/concepts/architecture/widget-behavior#statefulness-of-widgets)Statefulness of widgets
As long as the defining parameters of a widget remain the same and that widget is continuously rendered on the frontend, then it will be stateful and remember user input.
### [](https://docs.streamlit.io/develop/concepts/architecture/widget-behavior#changing-parameters-of-a-widget-will-reset-it)Changing parameters of a widget will reset it
If any of the defining parameters of a widget change, Streamlit will see it as a new widget and it will reset. The use of manually assigned keys and default values is particularly important in this case. _Note that callback functions, callback args and kwargs, label visibility, and disabling a widget do not affect a widget's identity._
In this example, we have a slider whose min and max values are changed. Try interacting with each slider to change its value then change the min or max setting to see what happens.
`import streamlit as st cols = st.columns([2, 1, 2]) minimum = cols[0].number_input("Minimum", 1, 5) maximum = cols[2].number_input("Maximum", 6, 10, 10) st.slider("No default, no key", minimum, maximum) st.slider("No default, with key", minimum, maximum, key="a") st.slider("With default, no key", minimum, maximum, value=5) st.slider("With default, with key", minimum, maximum, value=5, key="b") `
[Built with Streamlit ðŸŽˆ](https://streamlit.io)
[Fullscreen _open_in_new_](https://doc-guide-widgets-change-parameters.streamlit.app/?utm_medium=oembed)
#### [](https://docs.streamlit.io/develop/concepts/architecture/widget-behavior#updating-a-slider-with-no-default-value)Updating a slider with no default value
For the first two sliders above, as soon as the min or max value is changed, the sliders reset to the min value. The changing of the min or max value makes them "new" widgets f