Title: Streamlit Buttons and Session State Management
URL: https://docs.streamlit.io/develop/concepts/design/buttons
Summary: This chunk discusses the use of buttons in Streamlit applications and managing session state. It explains using the `.get()` method on `st.session_state` to handle button states when the script runs for the first time. Additionally, it presents an alternative approach using a callback function to set values in session state based on button clicks.
---

your script before that button. In the following example, we use the `.get()` method on `st.session_state` because the keys for the buttons will not exist when the script runs for the first time. The `.get()` method will return `False` if it can't find the key. Otherwise, it will return the value of the key.
`import streamlit as st # Use the get method since the keys won't be in session_state # on the first script run if st.session_state.get('clear'):   st.session_state['name'] = '' if st.session_state.get('streamlit'):   st.session_state['name'] = 'Streamlit' st.text_input('Name', key='name') st.button('Clear name', key='clear') st.button('Streamlit!', key='streamlit') `
#### [](https://docs.streamlit.io/develop/concepts/design/buttons#option-2-use-a-callback)Option 2: Use a callback
`import streamlit as st st.text_input('Name', key='name') def set_name(name):   st.session_state.name = name st.button('Clear name', on_click=set_name, args=['']) st.button('Streamlit!', on_click=set_name, args=['Streamlit']) `
#### [](https://docs.streamlit.io/develop/concepts/design/buttons#option-3-use-containers)Option 3: Use containers
By using [`st.container`](https://docs.streamlit.io/develop/api-reference/layout/st.container) you can have widgets appear in different orders in your script and frontend view (webpage).
`import streamlit as st begin = st.container() if st.button('Clear name'):   st.session_state.name = '' if st.button('Streamlit!'):   st.session_state.name = ('Streamlit') # The widget is second in logic, but first in display begin.text_input('Name', key='name') `
### [](https://docs.streamlit.io/develop/concepts/design/buttons#buttons-to-add-other-widgets-dynamically)Buttons to add other widgets dynamically
When dynamically adding widgets to the page, make sure to use an index to keep the keys unique and avoid a `DuplicateWidgetID` error. In this example, we define a function `display_input_row` which renders a row of widgets. That function accepts an `index` as a parameter. The widgets rendered by `display_input_row` use `index` within their keys so that `display_input_row` can be executed multiple times on a single script rerun without repeating any widget keys.
`import streamlit as st def display_input_row(index):   left, middle, right = st.columns(3)   left.text_input('First', key=f'first_{index}')   middle.text_input('Middle', key=f'middle_{index}')   right.text_input('Last', key=f'last_{index}') if 'rows' not in st.session_state:   st.session_state['rows'] = 0 def increase_rows():   st.session_state['rows'] += 1 st.button('Add person', on_click=increase_rows) for i in range(st.session_state['rows']):   display_input_row(i) # Show the results st.subheader('People') for i in range(st.session_state['rows']):   st.write( f'Person {i+1}:',     st.session_state[f'first_{i}'],     st.session_state[f'middle_{i}'],     st.session_state[f'last_{i}'] ) `
### [](https://docs.streamlit.io/develop/concepts/design/buttons#buttons-to-handle-expensive-or-file-writing-processes)Buttons to handle expensive or file-writing processes
When you have expensive processes, set them to run upon clicking a button and save the results into `st.session_state`. This allows you to keep accessing the results of the process without re-executing it unnecessarily. This is especially helpful for processes that save to disk or write to a database. In this example, we have an `expensive_process` that depends on two parameters: `option` and `add`. Functionally, `add` changes the output, but `option` does notâ€”`option` is there to provide a parameter
`import streamlit as st import pandas as pd import time def expensive_process(option, add): with st.spinner('Processing...'):     time.sleep(5)   df = pd.DataFrame({'A': [1, 2, 3], 'B': [4, 5, 6], 'C':[7, 8, 9]}) + add   return (df, add) cols = st.columns(2) option = cols[0].selectbox('Select a number', options=['1', '2', '3']) add = cols[1].number_input('Add a number', min_value=0, max_value=10) if 'processed' not in st.session_state:   st.session_state.processed = {} # Process and save results if st.button('Process'):   result = expensive_process(option, add)   st.session_state.processed[option] = result   st.write(f'Option {option} processed with add {add}')   result[0] `
Astute observers may think, "This feels a little like caching." We are only saving results relative to one parameter, but the pattern could easily be expanded to save results relative to both parameters. In that sense, yes, it has some similarities to caching, but also some important differences. When you save results in `st.session_state`, the results are only available to the current user in their current session. If you use [`st.cache_data`](https://docs.streamlit.io/develop/api-reference/caching-and-state/st.cache_data) instead, the results are available to all users across all sessions.