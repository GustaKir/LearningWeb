Title: Setting Up Docker and gcloud CLI for Kubernetes Deployment
URL: https://docs.streamlit.io/deploy/tutorials/kubernetes
Summary: This section covers verifying the installation of Docker Engine using the 'hello-world' image and provides a tip for running Docker as a non-root user. It introduces the requirement for the gcloud CLI to orchestrate Docker containers with Kubernetes and host images on Google Container Registry, including links to install and initialize the gcloud CLI.
---

Verify that Docker Engine is installed correctly by running the `hello-world` Docker image:
`sudo docker run hello-world `
_star_
#### Tip
Follow Docker's official [post-installation steps for Linux](https://docs.docker.com/engine/install/linux-postinstall/) to run Docker as a non-root user, so that you don't have to preface the `docker` command with `sudo`.
### [](https://docs.streamlit.io/deploy/tutorials/kubernetes#install-the-gcloud-cli)Install the gcloud CLI
In this guide, we will orchestrate Docker containers with Kubernetes and host docker images on the Google Container Registry (GCR). As GCR is a Google-supported Docker registry, we need to register [`gcloud`](https://cloud.google.com/sdk/gcloud/reference) as the Docker credential helper.
Follow the official documentation to [Install the gcloud CLI](https://cloud.google.com/sdk/docs/install) and initialize it.
## [](https://docs.streamlit.io/deploy/tutorials/kubernetes#create-a-docker-container)Create a Docker container
We need to create a docker container which contains all the dependencies and the application code. Below you can see the entrypoint, i.e. the command run when the container starts, and the Dockerfile definition.
### [](https://docs.streamlit.io/deploy/tutorials/kubernetes#create-an-entrypoint-script)Create an entrypoint script
Create a `run.sh` script containing the following:
`#!/bin/bash APP_PID= stopRunningProcess() { # Based on https://linuxconfig.org/how-to-propagate-a-signal-to-child-processes-from-a-bash-script if test ! "${APP_PID}" = '' && ps -p ${APP_PID} > /dev/null ; then > /proc/1/fd/1 echo "Stopping ${COMMAND_PATH} which is running with process ID ${APP_PID}" kill -TERM ${APP_PID} > /proc/1/fd/1 echo "Waiting for ${COMMAND_PATH} to process SIGTERM signal" wait ${APP_PID} > /proc/1/fd/1 echo "All processes have stopped running" else > /proc/1/fd/1 echo "${COMMAND_PATH} was not started when the signal was sent or it has already been stopped" fi } trap stopRunningProcess EXIT TERM source ${VIRTUAL_ENV}/bin/activate streamlit run ${HOME}/app/streamlit_app.py & APP_ID=${!} wait ${APP_ID} `
### [](https://docs.streamlit.io/deploy/tutorials/kubernetes#create-a-dockerfile)Create a Dockerfile
Docker builds images by reading the instructions from a `Dockerfile`. A `Dockerfile` is a text document that contains all the commands a user could call on the command line to assemble an image. Learn more in the [Dockerfile reference](https://docs.docker.com/engine/reference/builder/). The [docker build](https://docs.docker.com/engine/reference/commandline/build/) command builds an image from a `Dockerfile`. The [docker run](https://docs.docker.com/engine/reference/commandline/run/) command first creates a container over the specified image, and then starts it using the specified command.
Here's an example `Dockerfile` that you can add to the root of your directory.
`FROM python:3.9-slim RUN groupadd --gid 1000 appuser \   && useradd --uid 1000 --gid 1000 -ms /bin/bash appuser RUN pip3 install --no-cache-dir --upgrade \   pip \   virtualenv RUN apt-get update && apt-get install -y \   build-essential \   software-properties-common \   git USER appuser WORKDIR /home/appuser RUN git clone https://github.com/streamlit/streamlit-example.git app ENV VIRTUAL_ENV=/home/appuser/venv RUN virtualenv ${VIRTUAL_ENV} RUN . ${VIRTUAL_ENV}/bin/activate && pip install -r app/requirements.txt EXPOSE 8501 COPY run.sh /home/appuser ENTRYPOINT ["./run.sh"] `
_priority_high_
#### Important
As mentioned in [Development flow](https://docs.streamlit.io/get-started/fundamentals/main-concepts#development-flow), for Streamlit version 1.10.0 and higher, Streamlit apps cannot be run from the root directory of Linux distributions. Your main script should live in a directory other than the root directory. If you try to run a Streamlit app from the root directory, Streamlit will throw a `FileNotFoundError: [Errno 2] No such file or directory` error. For more information, see GitHub issue [#5239](https://github.com/streamlit/streamlit/issues/5239).
If you are using Streamlit version 1.10.0 or higher, you must set the `WORKDIR` to a directory other than the root directory. For example, you can set the `WORKDIR` to `/home/appuser` as shown in the example `Dockerfile` above.
### [](https://docs.streamlit.io/deploy/tutorials/kubernetes#build-a-docker-image)Build a Docker image
Put the above files (`run.sh` and `Dockerfile`) in the same folder and build the docker image:
`docker build --platform linux/amd64 -t gcr.io/$GCP_PROJECT_ID/k8s-streamlit:test . `
_priority_high_
#### Important
Replace `$GCP_PROJECT_ID` in the above command with the name of your Google Cloud project.
### [](https://docs.streamlit.io/deploy/tutorials/kubernetes#upload-the-docker-image-to-a-container-registry)Upload the Docker image to a container registry
The next step is to upload the Docker image to a container registry. In this example, we will use the [Google Container Registry (GCR)](https://clou