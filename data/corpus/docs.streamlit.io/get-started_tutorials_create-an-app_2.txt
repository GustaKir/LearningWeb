Title: Effortless Caching in Streamlit Apps
URL: https://docs.streamlit.io/get-started/tutorials/create-an-app
Summary: This section discusses the importance of caching data in Streamlit applications to improve performance. It describes how to implement caching using the `@st.cache_data` decorator to speed up data loading and demonstrate its effectiveness. Adjustments to the loading state message are suggested to reflect the use of caching.
---

Ok, that's underwhelming...
It turns out that it takes a long time to download data, and load 10,000 lines into a dataframe. Converting the date column into datetime isn’t a quick job either. You don’t want to reload the data each time the app is updated – luckily Streamlit allows you to cache the data.
## [](https://docs.streamlit.io/get-started/tutorials/create-an-app#effortless-caching)Effortless caching
  1. Try adding `@st.cache_data` before the `load_data` declaration:
`@st.cache_data def load_data(nrows): `
  2. Then save the script, and Streamlit will automatically rerun your app. Since this is the first time you’re running the script with `@st.cache_data`, you won't see anything change. Let’s tweak your file a little bit more so that you can see the power of caching.
  3. Replace the line `data_load_state.text('Loading data...done!')` with this:
`data_load_state.text("Done! (using st.cache_data)") `
  4. Now save. See how the line you added appeared immediately? If you take a step back for a second, this is actually quite amazing. Something magical is happening behind the scenes, and it only takes one line of code to activate it.


### [](https://docs.streamlit.io/get-started/tutorials/create-an-app#hows-it-work)How's it work?
Let's take a few minutes to discuss how `@st.cache_data` actually works.
When you mark a function with Streamlit’s cache annotation, it tells Streamlit that whenever the function is called that it should check two things:
  1. The input parameters you used for the function call.
  2. The code inside the function.


If this is the first time Streamlit has seen both these items, with these exact values, and in this exact combination, it runs the function and stores the result in a local cache. The next time the function is called, if the two values haven't changed, then Streamlit knows it can skip executing the function altogether. Instead, it reads the output from the local cache and passes it on to the caller -- like magic.
"But, wait a second," you’re saying to yourself, "this sounds too good to be true. What are the limitations of all this awesomesauce?"
Well, there are a few:
  1. Streamlit will only check for changes within the current working directory. If you upgrade a Python library, Streamlit's cache will only notice this if that library is installed inside your working directory.
  2. If your function is not deterministic (that is, its output depends on random numbers), or if it pulls data from an external time-varying source (for example, a live stock market ticker service) the cached value will be none-the-wiser.
  3. Lastly, you should avoid mutating the output of a function cached with `st.cache_data` since cached values are stored by reference.