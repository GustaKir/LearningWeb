Title: Introduction to Python Abstract Syntax Trees (AST) in Version 2.5
URL: https://docs.python.org/3/whatsnew/2.5.html
Summary: This document chunk introduces the Abstract Syntax Tree (AST) functionality in Python 2.5, mentioning that while official documentation is lacking, PEP 339 discusses its design. It describes how AST nodes are defined in `Parser/Python.asdl` and how Python scripts generate C structure definitions. It also outlines the process of converting Python source into an AST and subsequently into a code object. The development of this feature is credited to several contributors under Jeremy Hylton's management.
---

```
from_astimport PyCF_ONLY_AST
ast = compile("""a=0
for i in range(10):
  a += i
""", "<string>", 'exec', PyCF_ONLY_AST)
assignment = ast.body[0]
for_loop = ast.body[1]

```

No official documentation has been written for the AST code yet, but [**PEP 339**](https://peps.python.org/pep-0339/) discusses the design. To start learning about the code, read the definition of the various AST nodes in `Parser/Python.asdl`. A Python script reads this file and generates a set of C structure definitions in `Include/Python-ast.h`. The `PyParser_ASTFromString()` and `PyParser_ASTFromFile()`, defined in `Include/pythonrun.h`, take Python source as input and return the root of an AST representing the contents. This AST can then be turned into a code object by `PyAST_Compile()`. For more information, read the source code, and then ask questions on python-dev.
The AST code was developed under Jeremy Hylton’s management, and implemented by (in alphabetical order) Brett Cannon, Nick Coghlan, Grant Edwards, John Ehresman, Kurt Kaiser, Neal Norwitz, Tim Peters, Armin Rigo, and Neil Schemenauer, plus the participants in a number of AST sprints at conferences such as PyCon.
  * Evan Jones’s patch to obmalloc, first described in a talk at PyCon DC 2005, was applied. Python 2.4 allocated small objects in 256K-sized arenas, but never freed arenas. With this patch, Python will free arenas when they’re empty. The net effect is that on some platforms, when you allocate many objects, Python’s memory usage may actually drop when you delete them and the memory may be returned to the operating system. (Implemented by Evan Jones, and reworked by Tim Peters.)
Note that this change means extension modules must be more careful when allocating memory. Python’s API has many different functions for allocating memory that are grouped into families. For example, [`PyMem_Malloc()`](https://docs.python.org/3/c-api/memory.html#c.PyMem_Malloc "PyMem_Malloc"), [`PyMem_Realloc()`](https://docs.python.org/3/c-api/memory.html#c.PyMem_Realloc "PyMem_Realloc"), and [`PyMem_Free()`](https://docs.python.org/3/c-api/memory.html#c.PyMem_Free "PyMem_Free") are one family that allocates raw memory, while [`PyObject_Malloc()`](https://docs.python.org/3/c-api/memory.html#c.PyObject_Malloc "PyObject_Malloc"), [`PyObject_Realloc()`](https://docs.python.org/3/c-api/memory.html#c.PyObject_Realloc "PyObject_Realloc"), and [`PyObject_Free()`](https://docs.python.org/3/c-api/memory.html#c.PyObject_Free "PyObject_Free") are another family that’s supposed to be used for creating Python objects.
Previously these different families all reduced to the platform’s `malloc()` and `free()` functions. This meant it didn’t matter if you got things wrong and allocated memory with the `PyMem` function but freed it with the `PyObject` function. With 2.5’s changes to obmalloc, these families now do different things and mismatches will probably result in a segfault. You should carefully test your C extension modules with Python 2.5.
  * The built-in set types now have an official C API. Call [`PySet_New()`](https://docs.python.org/3/c-api/set.html#c.PySet_New "PySet_New") and [`PyFrozenSet_New()`](https://docs.python.org/3/c-api/set.html#c.PyFrozenSet_New "PyFrozenSet_New") to create a new set, [`PySet_Add()`](https://docs.python.org/3/c-api/set.html#c.PySet_Add "PySet_Add") and [`PySet_Discard()`](https://docs.python.org/3/c-api/set.html#c.PySet_Discard "PySet_Discard") to add and remove elements, and [`PySet_Contains()`](https://docs.python.org/3/c-api/set.html#c.PySet_Contains "PySet_Contains") and [`PySet_Size()`](https://docs.python.org/3/c-api/set.html#c.PySet_Size "PySet_Size") to examine the set’s state. (Contributed by Raymond Hettinger.)
  * C code can now obtain information about the exact revision of the Python interpreter by calling the [`Py_GetBuildInfo()`](https://docs.python.org/3/c-api/init.html#c.Py_GetBuildInfo "Py_GetBuildInfo") function that returns a string of build information like this: `"trunk:45355:45356M, Apr 13 2006, 07:42:19"`. (Contributed by Barry Warsaw.)
  * Two new macros can be used to indicate C functions that are local to the current file so that a faster calling convention can be used. `Py_LOCAL(type)` declares the function as returning a value of the specified _type_ and uses a fast-calling qualifier. `Py_LOCAL_INLINE(type)` does the same thing and also requests the function be inlined. If macro `PY_LOCAL_AGGRESSIVE` is defined before `python.h` is included, a set of more aggressive optimizations are enabled for the module; you should benchmark the results to find out if these optimizations actually make the code faster. (Contributed by Fredrik Lundh at the NeedForSpeed sprint.)
  * `PyErr_NewException(name, base, dict)` can now accept a tuple of base classes as its _base_ argument. (Contributed by Georg Brandl.)
  * The `PyErr_Warn()` function for issuing warnings is now deprecated in favour of `PyErr_WarnEx(category, message, stacklevel)` which l