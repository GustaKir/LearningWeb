Title: Special Values in Decimal Module
URL: https://docs.python.org/3/library/decimal.html
Summary: The `decimal` module includes special values such as `NaN`, `sNaN`, `-Infinity`, `Infinity`, and two types of zeros (`+0` and `-0`). Infinities can be created directly or can result from untrapped division by zero or overflow conditions. These infinities can be used in arithmetic operations and are signed.
---

```

### Special values[¶](https://docs.python.org/3/library/decimal.html#special-values "Link to this heading")
The number system for the [`decimal`](https://docs.python.org/3/library/decimal.html#module-decimal "decimal: Implementation of the General Decimal Arithmetic Specification.") module provides special values including `NaN`, `sNaN`, `-Infinity`, `Infinity`, and two zeros, `+0` and `-0`.
Infinities can be constructed directly with: `Decimal('Infinity')`. Also, they can arise from dividing by zero when the [`DivisionByZero`](https://docs.python.org/3/library/decimal.html#decimal.DivisionByZero "decimal.DivisionByZero") signal is not trapped. Likewise, when the [`Overflow`](https://docs.python.org/3/library/decimal.html#decimal.Overflow "decimal.Overflow") signal is not trapped, infinity can result from rounding beyond the limits of the largest representable number.
The infinities are signed (affine) and can be used in arithmetic operations where they get treated as very large, indeterminate numbers. For instance, adding a constant to infinity gives another infinite result.
Some operations are indeterminate and return `NaN`, or if the [`InvalidOperation`](https://docs.python.org/3/library/decimal.html#decimal.InvalidOperation "decimal.InvalidOperation") signal is trapped, raise an exception. For example, `0/0` returns `NaN` which means “not a number”. This variety of `NaN` is quiet and, once created, will flow through other computations always resulting in another `NaN`. This behavior can be useful for a series of computations that occasionally have missing inputs — it allows the calculation to proceed while flagging specific results as invalid.
A variant is `sNaN` which signals rather than remaining quiet after every operation. This is a useful return value when an invalid result needs to interrupt a calculation for special handling.
The behavior of Python’s comparison operators can be a little surprising where a `NaN` is involved. A test for equality where one of the operands is a quiet or signaling `NaN` always returns [`False`](https://docs.python.org/3/library/constants.html#False "False") (even when doing `Decimal('NaN')==Decimal('NaN')`), while a test for inequality always returns [`True`](https://docs.python.org/3/library/constants.html#True "True"). An attempt to compare two Decimals using any of the `<`, `<=`, `>` or `>=` operators will raise the [`InvalidOperation`](https://docs.python.org/3/library/decimal.html#decimal.InvalidOperation "decimal.InvalidOperation") signal if either operand is a `NaN`, and return [`False`](https://docs.python.org/3/library/constants.html#False "False") if this signal is not trapped. Note that the General Decimal Arithmetic specification does not specify the behavior of direct comparisons; these rules for comparisons involving a `NaN` were taken from the IEEE 854 standard (see Table 3 in section 5.7). To ensure strict standards-compliance, use the [`compare()`](https://docs.python.org/3/library/decimal.html#decimal.Decimal.compare "decimal.Decimal.compare") and [`compare_signal()`](https://docs.python.org/3/library/decimal.html#decimal.Decimal.compare_signal "decimal.Decimal.compare_signal") methods instead.
The signed zeros can result from calculations that underflow. They keep the sign that would have resulted if the calculation had been carried out to greater precision. Since their magnitude is zero, both positive and negative zeros are treated as equal and their sign is informational.
In addition to the two signed zeros which are distinct yet equal, there are various representations of zero with differing precisions yet equivalent in value. This takes a bit of getting used to. For an eye accustomed to normalized floating-point representations, it is not immediately obvious that the following calculation returns a value equal to zero:
>>>```
>>> 1 / Decimal('Infinity')
Decimal('0E-1000026')