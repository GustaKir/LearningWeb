Title: Named Tuples and Namespaces in Python
URL: https://docs.python.org/3/glossary.html
Summary: Named tuples can be built-in or created from a regular class that inherits from tuple, or using the typing.NamedTuple and collections.namedtuple techniques, which offer additional methods. Namespaces, implemented as dictionaries, store variables and include local, global, built-in, and nested types.
---

```

Some named tuples are built-in types (such as the above examples). Alternatively, a named tuple can be created from a regular class definition that inherits from [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "tuple") and that defines named fields. Such a class can be written by hand, or it can be created by inheriting [`typing.NamedTuple`](https://docs.python.org/3/library/typing.html#typing.NamedTuple "typing.NamedTuple"), or with the factory function [`collections.namedtuple()`](https://docs.python.org/3/library/collections.html#collections.namedtuple "collections.namedtuple"). The latter techniques also add some extra methods that may not be found in hand-written or built-in named tuples. 

namespace[¶](https://docs.python.org/3/glossary.html#term-namespace "Link to this term")
    
The place where a variable is stored. Namespaces are implemented as dictionaries. There are the local, global and built-in namespaces as well as nested namespaces in objects (in methods). Namespaces support modularity by preventing naming conflicts. For instance, the functions [`builtins.open`](https://docs.python.org/3/library/functions.html#open "open") and [`os.open()`](https://docs.python.org/3/library/os.html#os.open "os.open") are distinguished by their namespaces. Namespaces also aid readability and maintainability by making it clear which module implements a function. For instance, writing [`random.seed()`](https://docs.python.org/3/library/random.html#random.seed "random.seed") or [`itertools.islice()`](https://docs.python.org/3/library/itertools.html#itertools.islice "itertools.islice") makes it clear that those functions are implemented by the [`random`](https://docs.python.org/3/library/random.html#module-random "random: Generate pseudo-random numbers with various common distributions.") and [`itertools`](https://docs.python.org/3/library/itertools.html#module-itertools "itertools: Functions creating iterators for efficient looping.") modules, respectively. 

namespace package[¶](https://docs.python.org/3/glossary.html#term-namespace-package "Link to this term")
    
A [package](https://docs.python.org/3/glossary.html#term-package) which serves only as a container for subpackages. Namespace packages may have no physical representation, and specifically are not like a [regular package](https://docs.python.org/3/glossary.html#term-regular-package) because they have no `__init__.py` file.
Namespace packages allow several individually installable packages to have a common parent package. Otherwise, it is recommended to use a [regular package](https://docs.python.org/3/glossary.html#term-regular-package).
For more information, see [**PEP 420**](https://peps.python.org/pep-0420/) and [Namespace packages](https://docs.python.org/3/reference/import.html#reference-namespace-package).
See also [module](https://docs.python.org/3/glossary.html#term-module). 

nested scope[¶](https://docs.python.org/3/glossary.html#term-nested-scope "Link to this term")
    
The ability to refer to a variable in an enclosing definition. For instance, a function defined inside another function can refer to variables in the outer function. Note that nested scopes by default work only for reference and not for assignment. Local variables both read and write in the innermost scope. Likewise, global variables read and write to the global namespace. The [`nonlocal`](https://docs.python.org/3/reference/simple_stmts.html#nonlocal) allows writing to outer scopes. 

new-style class[¶](https://docs.python.org/3/glossary.html#term-new-style-class "Link to this term")
    
Old name for the flavor of classes now used for all class objects. In earlier Python versions, only new-style classes could use Python’s newer, versatile features like [`__slots__`](https://docs.python.org/3/reference/datamodel.html#object.__slots__ "object.__slots__"), descriptors, properties, [`__getattribute__()`](https://docs.python.org/3/reference/datamodel.html#object.__getattribute__ "object.__getattribute__"), class methods, and static methods. 

object[¶](https://docs.python.org/3/glossary.html#term-object "Link to this term")
    
Any data with state (attributes or value) and defined behavior (methods). Also the ultimate base class of any [new-style class](https://docs.python.org/3/glossary.html#term-new-style-class). 

optimized scope[¶](https://docs.python.org/3/glossary.html#term-optimized-scope "Link to this term")
    
A scope where target local variable names are reliably known to the compiler when the code is compiled, allowing optimization of read and write access to these names. The local namespaces for functions, generators, coroutines, comprehensions, and generator expressions are optimized in this fashion. Note: most interpreter optimizations are applied to all scopes, only those relying on a known set of local and nonlocal variable names are restricted to optimized scopes.