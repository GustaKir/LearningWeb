Title: Python 3.12 Highlights
URL: https://docs.python.org/3/whatsnew/3.12.html
Summary: Python 3.12 introduces several changes, including the modification of `Py_XSETREF` macros to evaluate arguments only once, normalization of the interpreter's error indicator for exception functions, and the deprecation of `_Py_RefTotal` in favor of `_Py_GetGlobalRefTotal()` for ABI compatibility.
---

g.html#c.Py_XSETREF "Py_XSETREF") macros now only evaluate their arguments once. If an argument has side effects, these side effects are no longer duplicated. (Contributed by Victor Stinner in [gh-98724](https://github.com/python/cpython/issues/98724).)
  * The interpreter’s error indicator is now always normalized. This means that [`PyErr_SetObject()`](https://docs.python.org/3/c-api/exceptions.html#c.PyErr_SetObject "PyErr_SetObject"), [`PyErr_SetString()`](https://docs.python.org/3/c-api/exceptions.html#c.PyErr_SetString "PyErr_SetString") and the other functions that set the error indicator now normalize the exception before storing it. (Contributed by Mark Shannon in [gh-101578](https://github.com/python/cpython/issues/101578).)
  * `_Py_RefTotal` is no longer authoritative and only kept around for ABI compatibility. Note that it is an internal global and only available on debug builds. If you happen to be using it then you’ll need to start using `_Py_GetGlobalRefTotal()`.
  * The following functions now select an appropriate metaclass for the newly created type:
    * [`PyType_FromSpec()`](https://docs.python.org/3/c-api/type.html#c.PyType_FromSpec "PyType_FromSpec")
    * [`PyType_FromSpecWithBases()`](https://docs.python.org/3/c-api/type.html#c.PyType_FromSpecWithBases "PyType_FromSpecWithBases")
    * [`PyType_FromModuleAndSpec()`](https://docs.python.org/3/c-api/type.html#c.PyType_FromModuleAndSpec "PyType_FromModuleAndSpec")
Creating classes whose metaclass overrides [`tp_new`](https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_new "PyTypeObject.tp_new") is deprecated, and in Python 3.14+ it will be disallowed. Note that these functions ignore `tp_new` of the metaclass, possibly allowing incomplete initialization.
Note that [`PyType_FromMetaclass()`](https://docs.python.org/3/c-api/type.html#c.PyType_FromMetaclass "PyType_FromMetaclass") (added in Python 3.12) already disallows creating classes whose metaclass overrides `tp_new` ([`__new__()`](https://docs.python.org/3/reference/datamodel.html#object.__new__ "object.__new__") in Python).
Since `tp_new` overrides almost everything `PyType_From*` functions do, the two are incompatible with each other. The existing behavior – ignoring the metaclass for several steps of type creation – is unsafe in general, since (meta)classes assume that `tp_new` was called. There is no simple general workaround. One of the following may work for you:
    * If you control the metaclass, avoid using `tp_new` in it:
      * If initialization can be skipped, it can be done in [`tp_init`](https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_init "PyTypeObject.tp_init") instead.
      * If the metaclass doesn’t need to be instantiated from Python, set its `tp_new` to `NULL` using the [`Py_TPFLAGS_DISALLOW_INSTANTIATION`](https://docs.python.org/3/c-api/typeobj.html#c.Py_TPFLAGS_DISALLOW_INSTANTIATION "Py_TPFLAGS_DISALLOW_INSTANTIATION") flag. This makes it acceptable for `PyType_From*` functions.
    * Avoid `PyType_From*` functions: if you don’t need C-specific features (slots or setting the instance size), create types by [calling](https://docs.python.org/3/c-api/call.html#call) the metaclass.
    * If you _know_ the `tp_new` can be skipped safely, filter the deprecation warning out using [`warnings.catch_warnings()`](https://docs.python.org/3/library/warnings.html#warnings.catch_warnings "warnings.catch_warnings") from Python.
  * [`PyOS_InputHook`](https://docs.python.org/3/c-api/veryhigh.html#c.PyOS_InputHook "PyOS_InputHook") and [`PyOS_ReadlineFunctionPointer`](https://docs.python.org/3/c-api/veryhigh.html#c.PyOS_ReadlineFunctionPointer "PyOS_ReadlineFunctionPointer") are no longer called in [subinterpreters](https://docs.python.org/3/c-api/init.html#sub-interpreter-support). This is because clients generally rely on process-wide global state (since these callbacks have no way of recovering extension module state).
This also avoids situations where extensions may find themselves running in a subinterpreter that they don’t support (or haven’t yet been loaded in). See [gh-104668](https://github.com/python/cpython/issues/104668) for more info.
  * [`PyLongObject`](https://docs.python.org/3/c-api/long.html#c.PyLongObject "PyLongObject") has had its internals changed for better performance. Although the internals of [`PyLongObject`](https://docs.python.org/3/c-api/long.html#c.PyLongObject "PyLongObject") are private, they are used by some extension modules. The internal fields should no longer be accessed directly, instead the API functions beginning `PyLong_...` should be used instead.