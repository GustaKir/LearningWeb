Title: Mutable Default Values in Data Classes
URL: https://docs.python.org/3/library/dataclasses.html
Summary: This section explains how fields in Python data classes can use a default factory when excluded from `__init__()` using `init=False`. It highlights the issue of mutable default values, illustrating with an example that demonstrates how default values defined at the class level can lead to shared mutable state among instances.
---

```

If a field is excluded from [`__init__()`](https://docs.python.org/3/reference/datamodel.html#object.__init__ "object.__init__") (using `init=False`) and the field also specifies _default_factory_ , then the default factory function will always be called from the generated `__init__()` function. This happens because there is no other way to give the field an initial value.
## Mutable default values[¶](https://docs.python.org/3/library/dataclasses.html#mutable-default-values "Link to this heading")
Python stores default member variable values in class attributes. Consider this example, not using dataclasses:
```
classC:
  x = []
  defadd(self, element):
    self.x.append(element)
o1 = C()
o2 = C()
o1.add(1)
o2.add(2)
assert o1.x == [1, 2]
assert o1.x is o2.x

```

Note that the two instances of class `C` share the same class variable `x`, as expected.
Using dataclasses, _if_ this code was valid:
```
@dataclass
classD:
  x: list = []   # This code raises ValueError
  defadd(self, element):
    self.x.append(element)

```

it would generate code similar to:
```
classD:
  x = []
  def__init__(self, x=x):
    self.x = x
  defadd(self, element):
    self.x.append(element)
assert D().x is D().x

```

This has the same issue as the original example using class `C`. That is, two instances of class `D` that do not specify a value for `x` when creating a class instance will share the same copy of `x`. Because dataclasses just use normal Python class creation they also share this behavior. There is no general way for Data Classes to detect this condition. Instead, the [`@dataclass`](https://docs.python.org/3/library/dataclasses.html#dataclasses.dataclass "dataclasses.dataclass") decorator will raise a [`ValueError`](https://docs.python.org/3/library/exceptions.html#ValueError "ValueError") if it detects an unhashable default parameter. The assumption is that if a value is unhashable, it is mutable. This is a partial solution, but it does protect against many common errors.
Using default factory functions is a way to create new instances of mutable types as default values for fields:
```
@dataclass
classD:
  x: list = field(default_factory=list)
assert D().x is not D().x

```

Changed in version 3.11: Instead of looking for and disallowing objects of type [`list`](https://docs.python.org/3/library/stdtypes.html#list "list"), [`dict`](https://docs.python.org/3/library/stdtypes.html#dict "dict"), or [`set`](https://docs.python.org/3/library/stdtypes.html#set "set"), unhashable objects are now not allowed as default values. Unhashability is used to approximate mutability.
## Descriptor-typed fields[¶](https://docs.python.org/3/library/dataclasses.html#descriptor-typed-fields "Link to this heading")
Fields that are assigned [descriptor objects](https://docs.python.org/3/reference/datamodel.html#descriptors) as their default value have the following special behaviors:
  * The value for the field passed to the dataclass’s [`__init__()`](https://docs.python.org/3/reference/datamodel.html#object.__init__ "object.__init__") method is passed to the descriptor’s [`__set__()`](https://docs.python.org/3/reference/datamodel.html#object.__set__ "object.__set__") method rather than overwriting the descriptor object.
  * Similarly, when getting or setting the field, the descriptor’s [`__get__()`](https://docs.python.org/3/reference/datamodel.html#object.__get__ "object.__get__") or `__set__()` method is called rather than returning or overwriting the descriptor object.
  * To determine whether a field contains a default value, [`@dataclass`](https://docs.python.org/3/library/dataclasses.html#dataclasses.dataclass "dataclasses.dataclass") will call the descriptor’s `__get__()` method using its class access form: `descriptor.__get__(obj=None, type=cls)`. If the descriptor returns a value in this case, it will be used as the field’s default. On the other hand, if the descriptor raises [`AttributeError`](https://docs.python.org/3/library/exceptions.html#AttributeError "AttributeError") in this situation, no default value will be provided for the field.


```
classIntConversionDescriptor:
  def__init__(self, *, default):
    self._default = default
  def__set_name__(self, owner, name):
    self._name = "_" + name
  def__get__(self, obj, type):
    if obj is None:
      return self._default
    return getattr(obj, self._name, self._default)
  def__set__(self, obj, value):
    setattr(obj, self._name, int(value))
@dataclass
classInventoryItem:
  quantity_on_hand: IntConversionDescriptor = IntConversionDescriptor(default=100)
i = InventoryItem()
print(i.quantity_on_hand)  # 100
i.quantity_on_hand = 2.5  # calls __set__ with 2.5
print(i.quantity_on_hand)  # 2