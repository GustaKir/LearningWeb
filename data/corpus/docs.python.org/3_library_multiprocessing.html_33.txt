Title: apply_async Method in Multiprocessing
URL: https://docs.python.org/3/library/multiprocessing.html
Summary: The apply_async method is a variant of apply that returns an AsyncResult object. It supports optional callbacks for successful and erroneous results, allowing for custom handling of the function's output upon completion.
---

apply_async(_func_[, _args_[, _kwds_[, _callback_[, _error_callback_]]]])[¶](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.apply_async "Link to this definition")
    
A variant of the [`apply()`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.apply "multiprocessing.pool.Pool.apply") method which returns a [`AsyncResult`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.AsyncResult "multiprocessing.pool.AsyncResult") object.
If _callback_ is specified then it should be a callable which accepts a single argument. When the result becomes ready _callback_ is applied to it, that is unless the call failed, in which case the _error_callback_ is applied instead.
If _error_callback_ is specified then it should be a callable which accepts a single argument. If the target function fails, then the _error_callback_ is called with the exception instance.
Callbacks should complete immediately since otherwise the thread which handles the results will get blocked. 

map(_func_ , _iterable_[, _chunksize_])[¶](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.map "Link to this definition")
    
A parallel equivalent of the [`map()`](https://docs.python.org/3/library/functions.html#map "map") built-in function (it supports only one _iterable_ argument though, for multiple iterables see [`starmap()`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.starmap "multiprocessing.pool.Pool.starmap")). It blocks until the result is ready.
This method chops the iterable into a number of chunks which it submits to the process pool as separate tasks. The (approximate) size of these chunks can be specified by setting _chunksize_ to a positive integer.
Note that it may cause high memory usage for very long iterables. Consider using [`imap()`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.imap "multiprocessing.pool.Pool.imap") or [`imap_unordered()`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.imap_unordered "multiprocessing.pool.Pool.imap_unordered") with explicit _chunksize_ option for better efficiency. 

map_async(_func_ , _iterable_[, _chunksize_[, _callback_[, _error_callback_]]])[¶](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.map_async "Link to this definition")
    
A variant of the [`map()`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.map "multiprocessing.pool.Pool.map") method which returns a [`AsyncResult`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.AsyncResult "multiprocessing.pool.AsyncResult") object.
If _callback_ is specified then it should be a callable which accepts a single argument. When the result becomes ready _callback_ is applied to it, that is unless the call failed, in which case the _error_callback_ is applied instead.
If _error_callback_ is specified then it should be a callable which accepts a single argument. If the target function fails, then the _error_callback_ is called with the exception instance.
Callbacks should complete immediately since otherwise the thread which handles the results will get blocked. 

imap(_func_ , _iterable_[, _chunksize_])[¶](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.imap "Link to this definition")
    
A lazier version of [`map()`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.map "multiprocessing.pool.Pool.map").
The _chunksize_ argument is the same as the one used by the [`map()`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.map "multiprocessing.pool.Pool.map") method. For very long iterables using a large value for _chunksize_ can make the job complete **much** faster than using the default value of `1`.
Also if _chunksize_ is `1` then the `next()` method of the iterator returned by the [`imap()`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.imap "multiprocessing.pool.Pool.imap") method has an optional _timeout_ parameter: `next(timeout)` will raise [`multiprocessing.TimeoutError`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.TimeoutError "multiprocessing.TimeoutError") if the result cannot be returned within _timeout_ seconds. 

imap_unordered(_func_ , _iterable_[, _chunksize_])[¶](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.imap_unordered "Link to this definition")
    
The same as [`imap()`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.imap "multiprocessing.pool.Pool.imap") except that the ordering of the results from the returned iterator should be considered arbitrary. (Only when there is only one worker process is the order guaranteed to be “correct”.)