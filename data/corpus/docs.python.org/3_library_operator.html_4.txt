Title: Operator Module: Method Caller Function
URL: https://docs.python.org/3/library/operator.html
Summary: The `methodcaller` function returns a callable that invokes a specified method on its operand. It can accept additional positional and keyword arguments for the method. The documentation includes examples demonstrating its use.
---

```


operator.methodcaller(_name_ , _/_ , _* args_, _** kwargs_)[¶](https://docs.python.org/3/library/operator.html#operator.methodcaller "Link to this definition")
    
Return a callable object that calls the method _name_ on its operand. If additional arguments and/or keyword arguments are given, they will be given to the method as well. For example:
  * After `f = methodcaller('name')`, the call `f(b)` returns `b.name()`.
  * After `f = methodcaller('name', 'foo', bar=1)`, the call `f(b)` returns `b.name('foo', bar=1)`.


Equivalent to:
```
defmethodcaller(name, /, *args, **kwargs):
  defcaller(obj):
    return getattr(obj, name)(*args, **kwargs)
  return caller

```

## Mapping Operators to Functions[¶](https://docs.python.org/3/library/operator.html#mapping-operators-to-functions "Link to this heading")
This table shows how abstract operations correspond to operator symbols in the Python syntax and the functions in the [`operator`](https://docs.python.org/3/library/operator.html#module-operator "operator: Functions corresponding to the standard operators.") module.
Operation | Syntax | Function  
---|---|---  
Addition | `a + b` | `add(a, b)`  
Concatenation | `seq1 + seq2` | `concat(seq1, seq2)`  
Containment Test | `obj in seq` | `contains(seq, obj)`  
Division | `a / b` | `truediv(a, b)`  
Division | `a // b` | `floordiv(a, b)`  
Bitwise And | `a & b` | `and_(a, b)`  
Bitwise Exclusive Or | `a ^ b` | `xor(a, b)`  
Bitwise Inversion | `~ a` | `invert(a)`  
Bitwise Or | `a | b` | `or_(a, b)`  
Exponentiation | `a ** b` | `pow(a, b)`  
Identity | `a is b` | `is_(a, b)`  
Identity | `a is not b` | `is_not(a, b)`  
Indexed Assignment | `obj[k] = v` | `setitem(obj, k, v)`  
Indexed Deletion | `del obj[k]` | `delitem(obj, k)`  
Indexing | `obj[k]` | `getitem(obj, k)`  
Left Shift | `a << b` | `lshift(a, b)`  
Modulo | `a % b` | `mod(a, b)`  
Multiplication | `a * b` | `mul(a, b)`  
Matrix Multiplication | `a @ b` | `matmul(a, b)`  
Negation (Arithmetic) | `- a` | `neg(a)`  
Negation (Logical) | `not a` | `not_(a)`  
Positive | `+ a` | `pos(a)`  
Right Shift | `a >> b` | `rshift(a, b)`  
Slice Assignment | `seq[i:j] = values` | `setitem(seq, slice(i, j), values)`  
Slice Deletion | `del seq[i:j]` | `delitem(seq, slice(i, j))`  
Slicing | `seq[i:j]` | `getitem(seq, slice(i, j))`  
String Formatting | `s % obj` | `mod(s, obj)`  
Subtraction | `a - b` | `sub(a, b)`  
Truth Test | `obj` | `truth(obj)`  
Ordering | `a < b` | `lt(a, b)`  
Ordering | `a <= b` | `le(a, b)`  
Equality | `a == b` | `eq(a, b)`  
Difference | `a != b` | `ne(a, b)`  
Ordering | `a >= b` | `ge(a, b)`  
Ordering | `a > b` | `gt(a, b)`  
## In-place Operators[¶](https://docs.python.org/3/library/operator.html#in-place-operators "Link to this heading")
Many operations have an “in-place” version. Listed below are functions providing a more primitive access to in-place operators than the usual syntax does; for example, the [statement](https://docs.python.org/3/glossary.html#term-statement) `x += y` is equivalent to `x = operator.iadd(x, y)`. Another way to put it is to say that `z = operator.iadd(x, y)` is equivalent to the compound statement `z = x; z += y`.
In those examples, note that when an in-place method is called, the computation and assignment are performed in two separate steps. The in-place functions listed below only do the first step, calling the in-place method. The second step, assignment, is not handled.
For immutable targets such as strings, numbers, and tuples, the updated value is computed, but not assigned back to the input variable:
>>>```
>>> a = 'hello'
>>> iadd(a, ' world')
'hello world'
>>> a
'hello'

```

For mutable targets such as lists and dictionaries, the in-place method will perform the update, so no subsequent assignment is necessary:
>>>```
>>> s = ['h', 'e', 'l', 'l', 'o']
>>> iadd(s, [' ', 'w', 'o', 'r', 'l', 'd'])
['h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd']
>>> s
['h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd']