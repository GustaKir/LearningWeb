Title: Real Number Operations in Python
URL: https://docs.python.org/3/library/stdtypes.html
Summary: This section outlines the operations available for `numbers.Real` types in Python, specifically for `int` and `float`. It includes details on truncating, rounding, flooring, and ceiling operations, along with their expected results.
---

All [`numbers.Real`](https://docs.python.org/3/library/numbers.html#numbers.Real "numbers.Real") types ([`int`](https://docs.python.org/3/library/functions.html#int "int") and [`float`](https://docs.python.org/3/library/functions.html#float "float")) also include the following operations:
Operation | Result  
---|---  
[`math.trunc(x)`](https://docs.python.org/3/library/math.html#math.trunc "math.trunc") | _x_ truncated to [`Integral`](https://docs.python.org/3/library/numbers.html#numbers.Integral "numbers.Integral")  
[`round(x[, n])`](https://docs.python.org/3/library/functions.html#round "round") | _x_ rounded to _n_ digits, rounding half to even. If _n_ is omitted, it defaults to 0.  
[`math.floor(x)`](https://docs.python.org/3/library/math.html#math.floor "math.floor") | the greatest [`Integral`](https://docs.python.org/3/library/numbers.html#numbers.Integral "numbers.Integral") <= _x_  
[`math.ceil(x)`](https://docs.python.org/3/library/math.html#math.ceil "math.ceil") | the least [`Integral`](https://docs.python.org/3/library/numbers.html#numbers.Integral "numbers.Integral") >= _x_  
For additional numeric operations see the [`math`](https://docs.python.org/3/library/math.html#module-math "math: Mathematical functions \(sin\(\) etc.\).") and [`cmath`](https://docs.python.org/3/library/cmath.html#module-cmath "cmath: Mathematical functions for complex numbers.") modules.
### Bitwise Operations on Integer Types[¶](https://docs.python.org/3/library/stdtypes.html#bitwise-operations-on-integer-types "Link to this heading")
Bitwise operations only make sense for integers. The result of bitwise operations is calculated as though carried out in two’s complement with an infinite number of sign bits.
The priorities of the binary bitwise operations are all lower than the numeric operations and higher than the comparisons; the unary operation `~` has the same priority as the other unary numeric operations (`+` and `-`).
This table lists the bitwise operations sorted in ascending priority:
Operation | Result | Notes  
---|---|---  
`x | y` | bitwise _or_ of _x_ and _y_ | (4)  
`x ^ y` | bitwise _exclusive or_ of _x_ and _y_ | (4)  
`x & y` | bitwise _and_ of _x_ and _y_ | (4)  
`x << n` | _x_ shifted left by _n_ bits | (1)(2)  
`x >> n` | _x_ shifted right by _n_ bits | (1)(3)  
`~x` | the bits of _x_ inverted |   
Notes:
  1. Negative shift counts are illegal and cause a [`ValueError`](https://docs.python.org/3/library/exceptions.html#ValueError "ValueError") to be raised.
  2. A left shift by _n_ bits is equivalent to multiplication by `pow(2, n)`.
  3. A right shift by _n_ bits is equivalent to floor division by `pow(2, n)`.
  4. Performing these calculations with at least one extra sign extension bit in a finite two’s complement representation (a working bit-width of `1 + max(x.bit_length(), y.bit_length())` or more) is sufficient to get the same result as if there were an infinite number of sign bits.


### Additional Methods on Integer Types[¶](https://docs.python.org/3/library/stdtypes.html#additional-methods-on-integer-types "Link to this heading")
The int type implements the [`numbers.Integral`](https://docs.python.org/3/library/numbers.html#numbers.Integral "numbers.Integral") [abstract base class](https://docs.python.org/3/glossary.html#term-abstract-base-class). In addition, it provides a few more methods: 

int.bit_length()[¶](https://docs.python.org/3/library/stdtypes.html#int.bit_length "Link to this definition")
    
Return the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros:
>>>```
>>> n = -37
>>> bin(n)
'-0b100101'
>>> n.bit_length()
6

```

More precisely, if `x` is nonzero, then `x.bit_length()` is the unique positive integer `k` such that `2**(k-1) <= abs(x) < 2**k`. Equivalently, when `abs(x)` is small enough to have a correctly rounded logarithm, then `k = 1 + int(log(abs(x), 2))`. If `x` is zero, then `x.bit_length()` returns `0`.
Equivalent to:
```
defbit_length(self):
  s = bin(self)    # binary representation: bin(-37) --> '-0b100101'
  s = s.lstrip('-0b') # remove leading zeros and minus sign
  return len(s)    # len('100101') --> 6

```

Added in version 3.1. 

int.bit_count()[¶](https://docs.python.org/3/library/stdtypes.html#int.bit_count "Link to this definition")
    
Return the number of ones in the binary representation of the absolute value of the integer. This is also known as the population count. Example:
>>>```
>>> n = 19
>>> bin(n)
'0b10011'
>>> n.bit_count()
3
>>> (-n).bit_count()
3

```

Equivalent to:
```
defbit_count(self):
  return bin(self).count("1")

```

Added in version 3.10. 

int.to_bytes(_length =1_, _byteorder ='big'_, _*_ , _signed =False_)[¶](https://docs.python.org/3/library/stdtypes.html#int.to_bytes "Link to this definition")
    
Return an array of bytes representing an integer.
>>>