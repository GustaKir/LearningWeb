Title: Unittest Discover Command Options
URL: https://docs.python.org/3/library/unittest.html
Summary: The 'unittest' module provides a shortcut `python -m unittest` which is equivalent to `python -m unittest discover`. To customize test discovery, the 'discover' sub-command offers options such as verbosity, starting directory, file pattern, and top-level directory.
---

```

Note
As a shortcut, `python -m unittest` is the equivalent of `python -m unittest discover`. If you want to pass arguments to test discovery the `discover` sub-command must be used explicitly.
The `discover` sub-command has the following options: 

-v, --verbose[¶](https://docs.python.org/3/library/unittest.html#cmdoption-unittest-discover-v "Link to this definition")
    
Verbose output 

-s, --start-directory directory[¶](https://docs.python.org/3/library/unittest.html#cmdoption-unittest-discover-s "Link to this definition")
    
Directory to start discovery (`.` default) 

-p, --pattern pattern[¶](https://docs.python.org/3/library/unittest.html#cmdoption-unittest-discover-p "Link to this definition")
    
Pattern to match test files (`test*.py` default) 

-t, --top-level-directory directory[¶](https://docs.python.org/3/library/unittest.html#cmdoption-unittest-discover-t "Link to this definition")
    
Top level directory of project (defaults to start directory)
The [`-s`](https://docs.python.org/3/library/unittest.html#cmdoption-unittest-discover-s), [`-p`](https://docs.python.org/3/library/unittest.html#cmdoption-unittest-discover-p), and [`-t`](https://docs.python.org/3/library/unittest.html#cmdoption-unittest-discover-t) options can be passed in as positional arguments in that order. The following two command lines are equivalent:
```
python -m unittest discover -s project_directory -p "*_test.py"
python -m unittest discover project_directory "*_test.py"

```

As well as being a path it is possible to pass a package name, for example `myproject.subpackage.test`, as the start directory. The package name you supply will then be imported and its location on the filesystem will be used as the start directory.
Caution
Test discovery loads tests by importing them. Once test discovery has found all the test files from the start directory you specify it turns the paths into package names to import. For example `foo/bar/baz.py` will be imported as `foo.bar.baz`.
If you have a package installed globally and attempt test discovery on a different copy of the package then the import _could_ happen from the wrong place. If this happens test discovery will warn you and exit.
If you supply the start directory as a package name rather than a path to a directory then discover assumes that whichever location it imports from is the location you intended, so you will not get the warning.
Test modules and packages can customize test loading and discovery by through the [load_tests protocol](https://docs.python.org/3/library/unittest.html#id1).
Changed in version 3.4: Test discovery supports [namespace packages](https://docs.python.org/3/glossary.html#term-namespace-package) for the start directory. Note that you need to specify the top level directory too (e.g. `python -m unittest discover -s root/namespace -t root`).
Changed in version 3.11: [`unittest`](https://docs.python.org/3/library/unittest.html#module-unittest "unittest: Unit testing framework for Python.") dropped the [namespace packages](https://docs.python.org/3/glossary.html#term-namespace-package) support in Python 3.11. It has been broken since Python 3.7. Start directory and subdirectories containing tests must be regular package that have `__init__.py` file.
Directories containing start directory still can be a namespace package. In this case, you need to specify start directory as dotted package name, and target directory explicitly. For example:
```
# proj/ <-- current directory
#  namespace/
#   mypkg/
#    __init__.py
#    test_mypkg.py
python -m unittest discover -s namespace.mypkg -t .

```

## Organizing test code[¶](https://docs.python.org/3/library/unittest.html#organizing-test-code "Link to this heading")
The basic building blocks of unit testing are _test cases_ — single scenarios that must be set up and checked for correctness. In [`unittest`](https://docs.python.org/3/library/unittest.html#module-unittest "unittest: Unit testing framework for Python."), test cases are represented by [`unittest.TestCase`](https://docs.python.org/3/library/unittest.html#unittest.TestCase "unittest.TestCase") instances. To make your own test cases you must write subclasses of [`TestCase`](https://docs.python.org/3/library/unittest.html#unittest.TestCase "unittest.TestCase") or use [`FunctionTestCase`](https://docs.python.org/3/library/unittest.html#unittest.FunctionTestCase "unittest.FunctionTestCase").
The testing code of a [`TestCase`](https://docs.python.org/3/library/unittest.html#unittest.TestCase "unittest.TestCase") instance should be entirely self contained, such that it can be run either in isolation or in arbitrary combination with any number of other test cases.
The simplest [`TestCase`](https://docs.python.org/3/library/unittest.html#unittest.TestCase "unittest.TestCase") subclass will simply implement a test method (i.e. a method whose name starts with `test`) in order to perform specific testing code: