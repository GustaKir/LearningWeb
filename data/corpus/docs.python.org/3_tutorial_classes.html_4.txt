Title: Class Definitions in Python
URL: https://docs.python.org/3/tutorial/classes.html
Summary: Class definitions must be executed before use, creating a new namespace for local variables, including methods. While typically containing function definitions, class bodies can include other statements as well. The peculiar argument list for methods is governed by specific calling conventions.
---

```

Class definitions, like function definitions ([`def`](https://docs.python.org/3/reference/compound_stmts.html#def) statements) must be executed before they have any effect. (You could conceivably place a class definition in a branch of an [`if`](https://docs.python.org/3/reference/compound_stmts.html#if) statement, or inside a function.)
In practice, the statements inside a class definition will usually be function definitions, but other statements are allowed, and sometimes useful — we’ll come back to this later. The function definitions inside a class normally have a peculiar form of argument list, dictated by the calling conventions for methods — again, this is explained later.
When a class definition is entered, a new namespace is created, and used as the local scope — thus, all assignments to local variables go into this new namespace. In particular, function definitions bind the name of the new function here.
When a class definition is left normally (via the end), a _class object_ is created. This is basically a wrapper around the contents of the namespace created by the class definition; we’ll learn more about class objects in the next section. The original local scope (the one in effect just before the class definition was entered) is reinstated, and the class object is bound here to the class name given in the class definition header (`ClassName` in the example).
### 9.3.2. Class Objects[¶](https://docs.python.org/3/tutorial/classes.html#class-objects "Link to this heading")
Class objects support two kinds of operations: attribute references and instantiation.
_Attribute references_ use the standard syntax used for all attribute references in Python: `obj.name`. Valid attribute names are all the names that were in the class’s namespace when the class object was created. So, if the class definition looked like this:
```
classMyClass:
"""A simple example class"""
  i = 12345
  deff(self):
    return 'hello world'

```

then `MyClass.i` and `MyClass.f` are valid attribute references, returning an integer and a function object, respectively. Class attributes can also be assigned to, so you can change the value of `MyClass.i` by assignment. [`__doc__`](https://docs.python.org/3/reference/datamodel.html#type.__doc__ "type.__doc__") is also a valid attribute, returning the docstring belonging to the class: `"A simple example class"`.
Class _instantiation_ uses function notation. Just pretend that the class object is a parameterless function that returns a new instance of the class. For example (assuming the above class):
```
x = MyClass()

```

creates a new _instance_ of the class and assigns this object to the local variable `x`.
The instantiation operation (“calling” a class object) creates an empty object. Many classes like to create objects with instances customized to a specific initial state. Therefore a class may define a special method named [`__init__()`](https://docs.python.org/3/reference/datamodel.html#object.__init__ "object.__init__"), like this:
```
def__init__(self):
  self.data = []

```

When a class defines an [`__init__()`](https://docs.python.org/3/reference/datamodel.html#object.__init__ "object.__init__") method, class instantiation automatically invokes `__init__()` for the newly created class instance. So in this example, a new, initialized instance can be obtained by:
```
x = MyClass()

```

Of course, the [`__init__()`](https://docs.python.org/3/reference/datamodel.html#object.__init__ "object.__init__") method may have arguments for greater flexibility. In that case, arguments given to the class instantiation operator are passed on to `__init__()`. For example,
>>>```
>>> classComplex:
...   def__init__(self, realpart, imagpart):
...     self.r = realpart
...     self.i = imagpart
...
>>> x = Complex(3.0, -4.5)
>>> x.r, x.i
(3.0, -4.5)

```

### 9.3.3. Instance Objects[¶](https://docs.python.org/3/tutorial/classes.html#instance-objects "Link to this heading")
Now what can we do with instance objects? The only operations understood by instance objects are attribute references. There are two kinds of valid attribute names: data attributes and methods.
_data attributes_ correspond to “instance variables” in Smalltalk, and to “data members” in C++. Data attributes need not be declared; like local variables, they spring into existence when they are first assigned to. For example, if `x` is the instance of `MyClass` created above, the following piece of code will print the value `16`, without leaving a trace:
```
x.counter = 1
while x.counter < 10:
  x.counter = x.counter * 2
print(x.counter)
del x.counter