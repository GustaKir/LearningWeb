Title: New Features in Python 2.5
URL: https://docs.python.org/3/whatsnew/2.5.html
Summary: Python 2.5 introduces methods for packing and unpacking data to and from buffer objects directly, allowing storage in arrays or memory-mapped files. It also marks the transition from CVS to Subversion for version control, with build information accessible via the `sys.subversion` variable and the `Py_GetBuildInfo()` function for C extensions.
---

```

You can also pack and unpack data to and from buffer objects directly using the `pack_into(buffer, offset, v1, v2, ...)` and `unpack_from(buffer, offset)` methods. This lets you store data directly into an array or a memory-mapped file.
(`Struct` objects were implemented by Bob Ippolito at the NeedForSpeed sprint. Support for buffer objects was added by Martin Blais, also at the NeedForSpeed sprint.)
  * The Python developers switched from CVS to Subversion during the 2.5 development process. Information about the exact build version is available as the `sys.subversion` variable, a 3-tuple of `(interpreter-name, branch-name, revision-range)`. For example, at the time of writing my copy of 2.5 was reporting `('CPython', 'trunk', '45313:45315')`.
This information is also available to C extensions via the [`Py_GetBuildInfo()`](https://docs.python.org/3/c-api/init.html#c.Py_GetBuildInfo "Py_GetBuildInfo") function that returns a string of build information like this: `"trunk:45355:45356M, Apr 13 2006, 07:42:19"`. (Contributed by Barry Warsaw.)
  * Another new function, [`sys._current_frames()`](https://docs.python.org/3/library/sys.html#sys._current_frames "sys._current_frames"), returns the current stack frames for all running threads as a dictionary mapping thread identifiers to the topmost stack frame currently active in that thread at the time the function is called. (Contributed by Tim Peters.)
  * The `TarFile` class in the [`tarfile`](https://docs.python.org/3/library/tarfile.html#module-tarfile "tarfile: Read and write tar-format archive files.") module now has an `extractall()` method that extracts all members from the archive into the current working directory. It’s also possible to set a different directory as the extraction target, and to unpack only a subset of the archive’s members.
The compression used for a tarfile opened in stream mode can now be autodetected using the mode `'r|*'`. (Contributed by Lars Gustäbel.)
  * The [`threading`](https://docs.python.org/3/library/threading.html#module-threading "threading: Thread-based parallelism.") module now lets you set the stack size used when new threads are created. The `stack_size([*size*])` function returns the currently configured stack size, and supplying the optional _size_ parameter sets a new value. Not all platforms support changing the stack size, but Windows, POSIX threading, and OS/2 all do. (Contributed by Andrew MacIntyre.)
  * The [`unicodedata`](https://docs.python.org/3/library/unicodedata.html#module-unicodedata "unicodedata: Access the Unicode Database.") module has been updated to use version 4.1.0 of the Unicode character database. Version 3.2.0 is required by some specifications, so it’s still available as [`unicodedata.ucd_3_2_0`](https://docs.python.org/3/library/unicodedata.html#unicodedata.ucd_3_2_0 "unicodedata.ucd_3_2_0").
  * New module: the [`uuid`](https://docs.python.org/3/library/uuid.html#module-uuid "uuid: UUID objects \(universally unique identifiers\) according to RFC 4122") module generates universally unique identifiers (UUIDs) according to [**RFC 4122**](https://datatracker.ietf.org/doc/html/rfc4122.html). The RFC defines several different UUID versions that are generated from a starting string, from system properties, or purely randomly. This module contains a `UUID` class and functions named `uuid1()`, `uuid3()`, `uuid4()`, and `uuid5()` to generate different versions of UUID. (Version 2 UUIDs are not specified in [**RFC 4122**](https://datatracker.ietf.org/doc/html/rfc4122.html) and are not supported by this module.)
>>>```
>>> importuuid
>>> # make a UUID based on the host ID and current time
>>> uuid.uuid1()
UUID('a8098c1a-f86e-11da-bd1a-00112444be1e')
>>> # make a UUID using an MD5 hash of a namespace UUID and a name
>>> uuid.uuid3(uuid.NAMESPACE_DNS, 'python.org')
UUID('6fa459ea-ee8a-3ca4-894e-db77e160355e')
>>> # make a random UUID
>>> uuid.uuid4()
UUID('16fd2706-8baf-433b-82eb-8c7fada847da')
>>> # make a UUID using a SHA-1 hash of a namespace UUID and a name
>>> uuid.uuid5(uuid.NAMESPACE_DNS, 'python.org')
UUID('886313e1-3b8a-5372-9b90-0c9aee199e5d')