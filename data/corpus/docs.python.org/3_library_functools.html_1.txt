Title: Understanding cached_property in functools
URL: https://docs.python.org/3/library/functools.html
Summary: The `cached_property` decorator in Python allows a class attribute to cache its value upon first lookup, unlike a regular property which blocks writes unless a setter is defined. It only runs if an attribute of the same name does not already exist. Subsequent accesses act as normal attributes, and the cached value can be cleared by deleting the attribute.
---

```
classDataSet:
  def__init__(self, sequence_of_numbers):
    self._data = tuple(sequence_of_numbers)
  @cached_property
  defstdev(self):
    return statistics.stdev(self._data)

```

The mechanics of [`cached_property()`](https://docs.python.org/3/library/functools.html#functools.cached_property "functools.cached_property") are somewhat different from [`property()`](https://docs.python.org/3/library/functions.html#property "property"). A regular property blocks attribute writes unless a setter is defined. In contrast, a _cached_property_ allows writes.
The _cached_property_ decorator only runs on lookups and only when an attribute of the same name doesn’t exist. When it does run, the _cached_property_ writes to the attribute with the same name. Subsequent attribute reads and writes take precedence over the _cached_property_ method and it works like a normal attribute.
The cached value can be cleared by deleting the attribute. This allows the _cached_property_ method to run again.
The _cached_property_ does not prevent a possible race condition in multi-threaded usage. The getter function could run more than once on the same instance, with the latest run setting the cached value. If the cached property is idempotent or otherwise not harmful to run more than once on an instance, this is fine. If synchronization is needed, implement the necessary locking inside the decorated getter function or around the cached property access.
Note, this decorator interferes with the operation of [**PEP 412**](https://peps.python.org/pep-0412/) key-sharing dictionaries. This means that instance dictionaries can take more space than usual.
Also, this decorator requires that the `__dict__` attribute on each instance be a mutable mapping. This means it will not work with some types, such as metaclasses (since the `__dict__` attributes on type instances are read-only proxies for the class namespace), and those that specify `__slots__` without including `__dict__` as one of the defined slots (as such classes don’t provide a `__dict__` attribute at all).
If a mutable mapping is not available or if space-efficient key sharing is desired, an effect similar to [`cached_property()`](https://docs.python.org/3/library/functools.html#functools.cached_property "functools.cached_property") can also be achieved by stacking [`property()`](https://docs.python.org/3/library/functions.html#property "property") on top of [`lru_cache()`](https://docs.python.org/3/library/functools.html#functools.lru_cache "functools.lru_cache"). See [How do I cache method calls?](https://docs.python.org/3/faq/programming.html#faq-cache-method-calls) for more details on how this differs from [`cached_property()`](https://docs.python.org/3/library/functools.html#functools.cached_property "functools.cached_property").
Added in version 3.8.
Changed in version 3.12: Prior to Python 3.12, `cached_property` included an undocumented lock to ensure that in multi-threaded usage the getter function was guaranteed to run only once per instance. However, the lock was per-property, not per-instance, which could result in unacceptably high lock contention. In Python 3.12+ this locking is removed. 

functools.cmp_to_key(_func_)[¶](https://docs.python.org/3/library/functools.html#functools.cmp_to_key "Link to this definition")
    
Transform an old-style comparison function to a [key function](https://docs.python.org/3/glossary.html#term-key-function). Used with tools that accept key functions (such as [`sorted()`](https://docs.python.org/3/library/functions.html#sorted "sorted"), [`min()`](https://docs.python.org/3/library/functions.html#min "min"), [`max()`](https://docs.python.org/3/library/functions.html#max "max"), [`heapq.nlargest()`](https://docs.python.org/3/library/heapq.html#heapq.nlargest "heapq.nlargest"), [`heapq.nsmallest()`](https://docs.python.org/3/library/heapq.html#heapq.nsmallest "heapq.nsmallest"), [`itertools.groupby()`](https://docs.python.org/3/library/itertools.html#itertools.groupby "itertools.groupby")). This function is primarily used as a transition tool for programs being converted from Python 2 which supported the use of comparison functions.
A comparison function is any callable that accepts two arguments, compares them, and returns a negative number for less-than, zero for equality, or a positive number for greater-than. A key function is a callable that accepts one argument and returns another value to be used as the sort key.
Example:
```
sorted(iterable, key=cmp_to_key(locale.strcoll)) # locale-aware sort order