Title: Logging Best Practices for Libraries
URL: https://docs.python.org/3/howto/logging.html
Summary: This section advises against logging to the root logger in libraries, recommending the use of uniquely identified loggers, such as the library's top-level package name. It also cautions against adding any handlers other than NullHandler, emphasizing that handler configuration should be left to the application developer.
---

```

should have the desired effect. If an organisation produces a number of libraries, then the logger name specified can be ‘orgname.foo’ rather than just ‘foo’.
Note
It is strongly advised that you _do not log to the root logger_ in your library. Instead, use a logger with a unique and easily identifiable name, such as the `__name__` for your library’s top-level package or module. Logging to the root logger will make it difficult or impossible for the application developer to configure the logging verbosity or handlers of your library as they wish.
Note
It is strongly advised that you _do not add any handlers other than_ [`NullHandler`](https://docs.python.org/3/library/logging.handlers.html#logging.NullHandler "logging.NullHandler") _to your library’s loggers_. This is because the configuration of handlers is the prerogative of the application developer who uses your library. The application developer knows their target audience and what handlers are most appropriate for their application: if you add handlers ‘under the hood’, you might well interfere with their ability to carry out unit tests and deliver logs which suit their requirements.
## Logging Levels[¶](https://docs.python.org/3/howto/logging.html#logging-levels "Link to this heading")
The numeric values of logging levels are given in the following table. These are primarily of interest if you want to define your own levels, and need them to have specific values relative to the predefined levels. If you define a level with the same numeric value, it overwrites the predefined value; the predefined name is lost.
Level | Numeric value  
---|---  
`CRITICAL` | 50  
`ERROR` | 40  
`WARNING` | 30  
`INFO` | 20  
`DEBUG` | 10  
`NOTSET` | 0  
Levels can also be associated with loggers, being set either by the developer or through loading a saved logging configuration. When a logging method is called on a logger, the logger compares its own level with the level associated with the method call. If the logger’s level is higher than the method call’s, no logging message is actually generated. This is the basic mechanism controlling the verbosity of logging output.
Logging messages are encoded as instances of the [`LogRecord`](https://docs.python.org/3/library/logging.html#logging.LogRecord "logging.LogRecord") class. When a logger decides to actually log an event, a [`LogRecord`](https://docs.python.org/3/library/logging.html#logging.LogRecord "logging.LogRecord") instance is created from the logging message.
Logging messages are subjected to a dispatch mechanism through the use of _handlers_ , which are instances of subclasses of the [`Handler`](https://docs.python.org/3/library/logging.html#logging.Handler "logging.Handler") class. Handlers are responsible for ensuring that a logged message (in the form of a [`LogRecord`](https://docs.python.org/3/library/logging.html#logging.LogRecord "logging.LogRecord")) ends up in a particular location (or set of locations) which is useful for the target audience for that message (such as end users, support desk staff, system administrators, developers). Handlers are passed [`LogRecord`](https://docs.python.org/3/library/logging.html#logging.LogRecord "logging.LogRecord") instances intended for particular destinations. Each logger can have zero, one or more handlers associated with it (via the [`addHandler()`](https://docs.python.org/3/library/logging.html#logging.Logger.addHandler "logging.Logger.addHandler") method of [`Logger`](https://docs.python.org/3/library/logging.html#logging.Logger "logging.Logger")). In addition to any handlers directly associated with a logger, _all handlers associated with all ancestors of the logger_ are called to dispatch the message (unless the _propagate_ flag for a logger is set to a false value, at which point the passing to ancestor handlers stops).
Just as for loggers, handlers can have levels associated with them. A handler’s level acts as a filter in the same way as a logger’s level does. If a handler decides to actually dispatch an event, the [`emit()`](https://docs.python.org/3/library/logging.html#logging.Handler.emit "logging.Handler.emit") method is used to send the message to its destination. Most user-defined subclasses of [`Handler`](https://docs.python.org/3/library/logging.html#logging.Handler "logging.Handler") will need to override this [`emit()`](https://docs.python.org/3/library/logging.html#logging.Handler.emit "logging.Handler.emit").
### Custom Levels[¶](https://docs.python.org/3/howto/logging.html#custom-levels "Link to this heading")
Defining your own levels is possible, but should not be necessary, as the existing levels have been chosen on the basis of practical experience. However, if you are convinced that you need custom levels, great care should be exercised when doing this, and it is possibly _a very bad idea to define custom levels if you are developing a library_. That’s because if multiple library authors all define their own custom levels, there is