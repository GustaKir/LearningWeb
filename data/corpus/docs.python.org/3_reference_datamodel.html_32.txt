Title: Super Binding in Python
URL: https://docs.python.org/3/reference/datamodel.html
Summary: Super binding involves using `super()` for attribute lookup, where `super(A, a).x` searches the method resolution order for the next base class `B` after `A` and retrieves the attribute `x` from `B`. The behavior of attribute retrieval depends on whether `x` is a descriptor and the methods defined in the descriptor class, including `__get__()`, `__set__()`, and `__delete__()`, which categorize it as data or non-data descriptor.
---

Super Binding
    
A dotted lookup such as `super(A, a).x` searches `a.__class__.__mro__` for a base class `B` following `A` and then returns `B.__dict__['x'].__get__(a, A)`. If not a descriptor, `x` is returned unchanged.
For instance bindings, the precedence of descriptor invocation depends on which descriptor methods are defined. A descriptor can define any combination of [`__get__()`](https://docs.python.org/3/reference/datamodel.html#object.__get__ "object.__get__"), [`__set__()`](https://docs.python.org/3/reference/datamodel.html#object.__set__ "object.__set__") and [`__delete__()`](https://docs.python.org/3/reference/datamodel.html#object.__delete__ "object.__delete__"). If it does not define `__get__()`, then accessing the attribute will return the descriptor object itself unless there is a value in the object’s instance dictionary. If the descriptor defines `__set__()` and/or `__delete__()`, it is a data descriptor; if it defines neither, it is a non-data descriptor. Normally, data descriptors define both `__get__()` and `__set__()`, while non-data descriptors have just the `__get__()` method. Data descriptors with `__get__()` and `__set__()` (and/or `__delete__()`) defined always override a redefinition in an instance dictionary. In contrast, non-data descriptors can be overridden by instances.
Python methods (including those decorated with [`@staticmethod`](https://docs.python.org/3/library/functions.html#staticmethod "staticmethod") and [`@classmethod`](https://docs.python.org/3/library/functions.html#classmethod "classmethod")) are implemented as non-data descriptors. Accordingly, instances can redefine and override methods. This allows individual instances to acquire behaviors that differ from other instances of the same class.
The [`property()`](https://docs.python.org/3/library/functions.html#property "property") function is implemented as a data descriptor. Accordingly, instances cannot override the behavior of a property.
#### 3.3.2.4. __slots__[¶](https://docs.python.org/3/reference/datamodel.html#slots "Link to this heading")
___slots___ allow us to explicitly declare data members (like properties) and deny the creation of [`__dict__`](https://docs.python.org/3/reference/datamodel.html#object.__dict__ "object.__dict__") and ___weakref___ (unless explicitly declared in ___slots___ or available in a parent.)
The space saved over using [`__dict__`](https://docs.python.org/3/reference/datamodel.html#object.__dict__ "object.__dict__") can be significant. Attribute lookup speed can be significantly improved as well.