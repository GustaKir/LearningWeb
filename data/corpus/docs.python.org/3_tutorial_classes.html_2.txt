Title: Attributes and Namespaces in Python
URL: https://docs.python.org/3/tutorial/classes.html
Summary: This section explains that attributes in Python can be either read-only or writable, allowing for assignment and deletion. It describes how writable attributes can be modified or removed using the `del` statement. Additionally, it outlines the lifecycle of different namespaces in Python, highlighting the creation of the built-in namespace and the global namespace for modules.
---

https://docs.python.org/3/tutorial/classes.html#id2)
Attributes may be read-only or writable. In the latter case, assignment to attributes is possible. Module attributes are writable: you can write `modname.the_answer = 42`. Writable attributes may also be deleted with the [`del`](https://docs.python.org/3/reference/simple_stmts.html#del) statement. For example, `del modname.the_answer` will remove the attribute `the_answer` from the object named by `modname`.
Namespaces are created at different moments and have different lifetimes. The namespace containing the built-in names is created when the Python interpreter starts up, and is never deleted. The global namespace for a module is created when the module definition is read in; normally, module namespaces also last until the interpreter quits. The statements executed by the top-level invocation of the interpreter, either read from a script file or interactively, are considered part of a module called [`__main__`](https://docs.python.org/3/library/__main__.html#module-__main__ "__main__: The environment where top-level code is run. Covers command-line interfaces, import-time behavior, and ``__name__ == '__main__'``."), so they have their own global namespace. (The built-in names actually also live in a module; this is called [`builtins`](https://docs.python.org/3/library/builtins.html#module-builtins "builtins: The module that provides the built-in namespace.").)
The local namespace for a function is created when the function is called, and deleted when the function returns or raises an exception that is not handled within the function. (Actually, forgetting would be a better way to describe what actually happens.) Of course, recursive invocations each have their own local namespace.
A _scope_ is a textual region of a Python program where a namespace is directly accessible. “Directly accessible” here means that an unqualified reference to a name attempts to find the name in the namespace.
Although scopes are determined statically, they are used dynamically. At any time during execution, there are 3 or 4 nested scopes whose namespaces are directly accessible:
  * the innermost scope, which is searched first, contains the local names
  * the scopes of any enclosing functions, which are searched starting with the nearest enclosing scope, contain non-local, but also non-global names
  * the next-to-last scope contains the current module’s global names
  * the outermost scope (searched last) is the namespace containing built-in names