Title: Garbage Collection and Resource Management in Python
URL: https://docs.python.org/3/reference/datamodel.html
Summary: This section discusses how external resources are managed in Python, emphasizing the importance of explicitly closing objects that manage such resources, typically through a `close()` method. It highlights the use of `try`...`finally` and `with` statements for resource management and introduces the concept of containers (like tuples, lists, and dictionaries) that hold references to other objects.
---

at these resources are freed when the object is garbage-collected, but since garbage collection is not guaranteed to happen, such objects also provide an explicit way to release the external resource, usually a `close()` method. Programs are strongly recommended to explicitly close such objects. The [`try`](https://docs.python.org/3/reference/compound_stmts.html#try)…[`finally`](https://docs.python.org/3/reference/compound_stmts.html#finally) statement and the [`with`](https://docs.python.org/3/reference/compound_stmts.html#with) statement provide convenient ways to do this.
Some objects contain references to other objects; these are called _containers_. Examples of containers are tuples, lists and dictionaries. The references are part of a container’s value. In most cases, when we talk about the value of a container, we imply the values, not the identities of the contained objects; however, when we talk about the mutability of a container, only the identities of the immediately contained objects are implied. So, if an immutable container (like a tuple) contains a reference to a mutable object, its value changes if that mutable object is changed.
Types affect almost all aspects of object behavior. Even the importance of object identity is affected in some sense: for immutable types, operations that compute new values may actually return a reference to any existing object with the same type and value, while for mutable objects this is not allowed. For example, after `a = 1; b = 1`, _a_ and _b_ may or may not refer to the same object with the value one, depending on the implementation. This is because [`int`](https://docs.python.org/3/library/functions.html#int "int") is an immutable type, so the reference to `1` can be reused. This behaviour depends on the implementation used, so should not be relied upon, but is something to be aware of when making use of object identity tests. However, after `c = []; d = []`, _c_ and _d_ are guaranteed to refer to two different, unique, newly created empty lists. (Note that `e = f = []` assigns the _same_ object to both _e_ and _f_.)
## 3.2. The standard type hierarchy[¶](https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy "Link to this heading")
Below is a list of the types that are built into Python. Extension modules (written in C, Java, or other languages, depending on the implementation) can define additional types. Future versions of Python may add types to the type hierarchy (e.g., rational numbers, efficiently stored arrays of integers, etc.), although such additions will often be provided via the standard library instead.
Some of the type descriptions below contain a paragraph listing ‘special attributes.’ These are attributes that provide access to the implementation and are not intended for general use. Their definition may change in the future.
### 3.2.1. None[¶](https://docs.python.org/3/reference/datamodel.html#none "Link to this heading")
This type has a single value. There is a single object with this value. This object is accessed through the built-in name `None`. It is used to signify the absence of a value in many situations, e.g., it is returned from functions that don’t explicitly return anything. Its truth value is false.
### 3.2.2. NotImplemented[¶](https://docs.python.org/3/reference/datamodel.html#notimplemented "Link to this heading")
This type has a single value. There is a single object with this value. This object is accessed through the built-in name [`NotImplemented`](https://docs.python.org/3/library/constants.html#NotImplemented "NotImplemented"). Numeric methods and rich comparison methods should return this value if they do not implement the operation for the operands provided. (The interpreter will then try the reflected operation, or some other fallback, depending on the operator.) It should not be evaluated in a boolean context.
See [Implementing the arithmetic operations](https://docs.python.org/3/library/numbers.html#implementing-the-arithmetic-operations) for more details.
Changed in version 3.9: Evaluating [`NotImplemented`](https://docs.python.org/3/library/constants.html#NotImplemented "NotImplemented") in a boolean context is deprecated. While it currently evaluates as true, it will emit a [`DeprecationWarning`](https://docs.python.org/3/library/exceptions.html#DeprecationWarning "DeprecationWarning"). It will raise a [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError "TypeError") in a future version of Python.
### 3.2.3. Ellipsis[¶](https://docs.python.org/3/reference/datamodel.html#ellipsis "Link to this heading")
This type has a single value. There is a single object with this value. This object is accessed through the literal `...` or the built-in name `Ellipsis`. Its truth value is true.
### 3.2.4.