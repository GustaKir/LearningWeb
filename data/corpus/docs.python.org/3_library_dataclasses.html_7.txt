Title: Python Dataclasses Constants Overview
URL: https://docs.python.org/3/library/dataclasses.html
Summary: This section explains two constants in the Python `dataclasses` module: `MISSING`, which indicates a missing default or `default_factory`, and `KW_ONLY`, used to define keyword-only fields in dataclass definitions. An example illustrates how `KW_ONLY` can be applied in a dataclass.
---

```


dataclasses.MISSING[¶](https://docs.python.org/3/library/dataclasses.html#dataclasses.MISSING "Link to this definition")
    
A sentinel value signifying a missing default or default_factory. 

dataclasses.KW_ONLY[¶](https://docs.python.org/3/library/dataclasses.html#dataclasses.KW_ONLY "Link to this definition")
    
A sentinel value used as a type annotation. Any fields after a pseudo-field with the type of `KW_ONLY` are marked as keyword-only fields. Note that a pseudo-field of type `KW_ONLY` is otherwise completely ignored. This includes the name of such a field. By convention, a name of `_` is used for a `KW_ONLY` field. Keyword-only fields signify [`__init__()`](https://docs.python.org/3/reference/datamodel.html#object.__init__ "object.__init__") parameters that must be specified as keywords when the class is instantiated.
In this example, the fields `y` and `z` will be marked as keyword-only fields:
```
@dataclass
classPoint:
  x: float
  _: KW_ONLY
  y: float
  z: float
p = Point(0, y=1.5, z=2.0)

```

In a single dataclass, it is an error to specify more than one field whose type is `KW_ONLY`.
Added in version 3.10. 

_exception_ dataclasses.FrozenInstanceError[¶](https://docs.python.org/3/library/dataclasses.html#dataclasses.FrozenInstanceError "Link to this definition")
    
Raised when an implicitly defined [`__setattr__()`](https://docs.python.org/3/reference/datamodel.html#object.__setattr__ "object.__setattr__") or [`__delattr__()`](https://docs.python.org/3/reference/datamodel.html#object.__delattr__ "object.__delattr__") is called on a dataclass which was defined with `frozen=True`. It is a subclass of [`AttributeError`](https://docs.python.org/3/library/exceptions.html#AttributeError "AttributeError").
## Post-init processing[¶](https://docs.python.org/3/library/dataclasses.html#post-init-processing "Link to this heading") 

dataclasses.__post_init__()[¶](https://docs.python.org/3/library/dataclasses.html#dataclasses.__post_init__ "Link to this definition")
    
When defined on the class, it will be called by the generated [`__init__()`](https://docs.python.org/3/reference/datamodel.html#object.__init__ "object.__init__"), normally as `self.__post_init__()`. However, if any `InitVar` fields are defined, they will also be passed to `__post_init__()` in the order they were defined in the class. If no `__init__()` method is generated, then `__post_init__()` will not automatically be called.
Among other uses, this allows for initializing field values that depend on one or more other fields. For example:
```
@dataclass
classC:
  a: float
  b: float
  c: float = field(init=False)
  def__post_init__(self):
    self.c = self.a + self.b

```

The [`__init__()`](https://docs.python.org/3/reference/datamodel.html#object.__init__ "object.__init__") method generated by [`@dataclass`](https://docs.python.org/3/library/dataclasses.html#dataclasses.dataclass "dataclasses.dataclass") does not call base class `__init__()` methods. If the base class has an `__init__()` method that has to be called, it is common to call this method in a [`__post_init__()`](https://docs.python.org/3/library/dataclasses.html#dataclasses.__post_init__ "dataclasses.__post_init__") method:
```
classRectangle:
  def__init__(self, height, width):
    self.height = height
    self.width = width
@dataclass
classSquare(Rectangle):
  side: float
  def__post_init__(self):
    super().__init__(self.side, self.side)