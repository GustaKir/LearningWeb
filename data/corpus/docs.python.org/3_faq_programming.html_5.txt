Title: Local and Global Variables in Python
URL: https://docs.python.org/3/faq/programming.html
Summary: This section discusses the rules governing local and global variables in Python, explaining how variables are treated inside functions. It highlights the use of the `nonlocal` keyword for nested functions and clarifies that variables referenced inside a function are global unless explicitly declared as local.
---

```

You can do a similar thing in a nested scope using the [`nonlocal`](https://docs.python.org/3/reference/simple_stmts.html#nonlocal) keyword:
>>>```
>>> deffoo():
...   x = 10
...   defbar():
...     nonlocal x
...     print(x)
...     x += 1
...   bar()
...   print(x)
...
>>> foo()
10
11

```

### [What are the rules for local and global variables in Python?](https://docs.python.org/3/faq/programming.html#id10)[¶](https://docs.python.org/3/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python "Link to this heading")
In Python, variables that are only referenced inside a function are implicitly global. If a variable is assigned a value anywhere within the function’s body, it’s assumed to be a local unless explicitly declared as global.
Though a bit surprising at first, a moment’s consideration explains this. On one hand, requiring [`global`](https://docs.python.org/3/reference/simple_stmts.html#global) for assigned variables provides a bar against unintended side-effects. On the other hand, if `global` was required for all global references, you’d be using `global` all the time. You’d have to declare as global every reference to a built-in function or to a component of an imported module. This clutter would defeat the usefulness of the `global` declaration for identifying side-effects.
### [Why do lambdas defined in a loop with different values all return the same result?](https://docs.python.org/3/faq/programming.html#id11)[¶](https://docs.python.org/3/faq/programming.html#why-do-lambdas-defined-in-a-loop-with-different-values-all-return-the-same-result "Link to this heading")
Assume you use a for loop to define a few different lambdas (or even plain functions), e.g.:
>>>```
>>> squares = []
>>> for x in range(5):
...   squares.append(lambda: x**2)

```

This gives you a list that contains 5 lambdas that calculate `x**2`. You might expect that, when called, they would return, respectively, `0`, `1`, `4`, `9`, and `16`. However, when you actually try you will see that they all return `16`:
>>>```
>>> squares[2]()
16
>>> squares[4]()
16

```

This happens because `x` is not local to the lambdas, but is defined in the outer scope, and it is accessed when the lambda is called — not when it is defined. At the end of the loop, the value of `x` is `4`, so all the functions now return `4**2`, i.e. `16`. You can also verify this by changing the value of `x` and see how the results of the lambdas change:
>>>```
>>> x = 8
>>> squares[2]()
64

```

In order to avoid this, you need to save the values in variables local to the lambdas, so that they don’t rely on the value of the global `x`:
>>>```
>>> squares = []
>>> for x in range(5):
...   squares.append(lambda n=x: n**2)

```

Here, `n=x` creates a new variable `n` local to the lambda and computed when the lambda is defined so that it has the same value that `x` had at that point in the loop. This means that the value of `n` will be `0` in the first lambda, `1` in the second, `2` in the third, and so on. Therefore each lambda will now return the correct result:
>>>```
>>> squares[2]()
4
>>> squares[4]()
16

```

Note that this behaviour is not peculiar to lambdas, but applies to regular functions too.
### [How do I share global variables across modules?](https://docs.python.org/3/faq/programming.html#id12)[¶](https://docs.python.org/3/faq/programming.html#how-do-i-share-global-variables-across-modules "Link to this heading")
The canonical way to share information across modules within a single program is to create a special module (often called config or cfg). Just import the config module in all modules of your application; the module then becomes available as a global name. Because there is only one instance of each module, any changes made to the module object get reflected everywhere. For example:
config.py:
```
x = 0  # Default value of the 'x' configuration setting

```

mod.py:
```
importconfig
config.x = 1

```

main.py:
```
importconfig
importmod
print(config.x)