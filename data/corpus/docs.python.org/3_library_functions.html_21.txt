Title: open() Function in Python
URL: https://docs.python.org/3/library/functions.html
Summary: The open() function is used to open a file and return a corresponding file object. It can raise an OSError if the file cannot be opened. The function accepts parameters for mode, buffering, encoding, and more, allowing for flexibility in file handling. For examples, refer to the Reading and Writing Files section.
---

```

See also [`format()`](https://docs.python.org/3/library/functions.html#format "format") for more information. 

open(_file_ , _mode ='r'_, _buffering =-1_, _encoding =None_, _errors =None_, _newline =None_, _closefd =True_, _opener =None_)[¶](https://docs.python.org/3/library/functions.html#open "Link to this definition")
    
Open _file_ and return a corresponding [file object](https://docs.python.org/3/glossary.html#term-file-object). If the file cannot be opened, an [`OSError`](https://docs.python.org/3/library/exceptions.html#OSError "OSError") is raised. See [Reading and Writing Files](https://docs.python.org/3/tutorial/inputoutput.html#tut-files) for more examples of how to use this function.
_file_ is a [path-like object](https://docs.python.org/3/glossary.html#term-path-like-object) giving the pathname (absolute or relative to the current working directory) of the file to be opened or an integer file descriptor of the file to be wrapped. (If a file descriptor is given, it is closed when the returned I/O object is closed unless _closefd_ is set to `False`.)
_mode_ is an optional string that specifies the mode in which the file is opened. It defaults to `'r'` which means open for reading in text mode. Other common values are `'w'` for writing (truncating the file if it already exists), `'x'` for exclusive creation, and `'a'` for appending (which on _some_ Unix systems, means that _all_ writes append to the end of the file regardless of the current seek position). In text mode, if _encoding_ is not specified the encoding used is platform-dependent: [`locale.getencoding()`](https://docs.python.org/3/library/locale.html#locale.getencoding "locale.getencoding") is called to get the current locale encoding. (For reading and writing raw bytes use binary mode and leave _encoding_ unspecified.) The available modes are:
Character | Meaning  
---|---  
`'r'` | open for reading (default)  
`'w'` | open for writing, truncating the file first  
`'x'` | open for exclusive creation, failing if the file already exists  
`'a'` | open for writing, appending to the end of file if it exists  
`'b'` | binary mode  
`'t'` | text mode (default)  
`'+'` | open for updating (reading and writing)  
The default mode is `'r'` (open for reading text, a synonym of `'rt'`). Modes `'w+'` and `'w+b'` open and truncate the file. Modes `'r+'` and `'r+b'` open the file with no truncation.
As mentioned in the [Overview](https://docs.python.org/3/library/io.html#io-overview), Python distinguishes between binary and text I/O. Files opened in binary mode (including `'b'` in the _mode_ argument) return contents as [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "bytes") objects without any decoding. In text mode (the default, or when `'t'` is included in the _mode_ argument), the contents of the file are returned as [`str`](https://docs.python.org/3/library/stdtypes.html#str "str"), the bytes having been first decoded using a platform-dependent encoding or using the specified _encoding_ if given.
Note
Python doesn’t depend on the underlying operating system’s notion of text files; all the processing is done by Python itself, and is therefore platform-independent.
_buffering_ is an optional integer used to set the buffering policy. Pass 0 to switch buffering off (only allowed in binary mode), 1 to select line buffering (only usable when writing in text mode), and an integer > 1 to indicate the size in bytes of a fixed-size chunk buffer. Note that specifying a buffer size this way applies for binary buffered I/O, but `TextIOWrapper` (i.e., files opened with `mode='r+'`) would have another buffering. To disable buffering in `TextIOWrapper`, consider using the `write_through` flag for [`io.TextIOWrapper.reconfigure()`](https://docs.python.org/3/library/io.html#io.TextIOWrapper.reconfigure "io.TextIOWrapper.reconfigure"). When no _buffering_ argument is given, the default buffering policy works as follows:
  * Binary files are buffered in fixed-size chunks; the size of the buffer is chosen using a heuristic trying to determine the underlying device’s “block size” and falling back on [`io.DEFAULT_BUFFER_SIZE`](https://docs.python.org/3/library/io.html#io.DEFAULT_BUFFER_SIZE "io.DEFAULT_BUFFER_SIZE"). On many systems, the buffer will typically be 4096 or 8192 bytes long.
  * “Interactive” text files (files for which [`isatty()`](https://docs.python.org/3/library/io.html#io.IOBase.isatty "io.IOBase.isatty") returns `True`) use line buffering. Other text files use the policy described above for binary files.