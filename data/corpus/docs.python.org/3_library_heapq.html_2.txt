Title: Heapq: Priority Queue Implementation
URL: https://docs.python.org/3/library/heapq.html
Summary: This section discusses the usage of the `heapq` module for implementing a priority queue, highlighting the differences from the `sorted()` function in terms of stability. It demonstrates how to push and pop items from the heap using tuples for priority assignment. It also outlines the challenges associated with maintaining order for tasks with equal priorities.
---

```

This is similar to `sorted(iterable)`, but unlike [`sorted()`](https://docs.python.org/3/library/functions.html#sorted "sorted"), this implementation is not stable.
Heap elements can be tuples. This is useful for assigning comparison values (such as task priorities) alongside the main record being tracked:
>>>```
>>> h = []
>>> heappush(h, (5, 'write code'))
>>> heappush(h, (7, 'release product'))
>>> heappush(h, (1, 'write spec'))
>>> heappush(h, (3, 'create tests'))
>>> heappop(h)
(1, 'write spec')

```

## Priority Queue Implementation Notes[¶](https://docs.python.org/3/library/heapq.html#priority-queue-implementation-notes "Link to this heading")
A [priority queue](https://en.wikipedia.org/wiki/Priority_queue) is common use for a heap, and it presents several implementation challenges:
  * Sort stability: how do you get two tasks with equal priorities to be returned in the order they were originally added?
  * Tuple comparison breaks for (priority, task) pairs if the priorities are equal and the tasks do not have a default comparison order.
  * If the priority of a task changes, how do you move it to a new position in the heap?
  * Or if a pending task needs to be deleted, how do you find it and remove it from the queue?


A solution to the first two challenges is to store entries as 3-element list including the priority, an entry count, and the task. The entry count serves as a tie-breaker so that two tasks with the same priority are returned in the order they were added. And since no two entry counts are the same, the tuple comparison will never attempt to directly compare two tasks.
Another solution to the problem of non-comparable tasks is to create a wrapper class that ignores the task item and only compares the priority field:
```
fromdataclassesimport dataclass, field
fromtypingimport Any
@dataclass(order=True)
classPrioritizedItem:
  priority: int
  item: Any=field(compare=False)

```

The remaining challenges revolve around finding a pending task and making changes to its priority or removing it entirely. Finding a task can be done with a dictionary pointing to an entry in the queue.
Removing the entry or changing its priority is more difficult because it would break the heap structure invariants. So, a possible solution is to mark the entry as removed and add a new entry with the revised priority:
```
pq = []             # list of entries arranged in a heap
entry_finder = {}        # mapping of tasks to entries
REMOVED = '<removed-task>'   # placeholder for a removed task
counter = itertools.count()   # unique sequence count
defadd_task(task, priority=0):
  'Add a new task or update the priority of an existing task'
  if task in entry_finder:
    remove_task(task)
  count = next(counter)
  entry = [priority, count, task]
  entry_finder[task] = entry
  heappush(pq, entry)
defremove_task(task):
  'Mark an existing task as REMOVED. Raise KeyError if not found.'
  entry = entry_finder.pop(task)
  entry[-1] = REMOVED
defpop_task():
  'Remove and return the lowest priority task. Raise KeyError if empty.'
  while pq:
    priority, count, task = heappop(pq)
    if task is not REMOVED:
      del entry_finder[task]
      return task
  raise KeyError('pop from an empty priority queue')

```

## Theory[¶](https://docs.python.org/3/library/heapq.html#theory "Link to this heading")
Heaps are arrays for which `a[k] <= a[2*k+1]` and `a[k] <= a[2*k+2]` for all _k_ , counting elements from 0. For the sake of comparison, non-existing elements are considered to be infinite. The interesting property of a heap is that `a[0]` is always its smallest element.
The strange invariant above is meant to be an efficient memory representation for a tournament. The numbers below are _k_ , not `a[k]`:
```
                0
       1                 2
   3        4        5        6
 7    8    9    10   11   12   13   14
15 16  17 18  19 20  21 22  23 24  25 26  27 28  29 30