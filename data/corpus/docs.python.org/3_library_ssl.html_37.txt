Title: Configuring SSL Context and Cipher Selection in Python
URL: https://docs.python.org/3/library/ssl.html
Summary: The SSL context allows only TLSv1.3 connections, with certificate validation and hostname checks enabled by default using PROTOCOL_TLS_CLIENT. Users can fine-tune supported ciphers with SSLContext.set_ciphers() for advanced security needs, alongside disabling weak ciphers since Python 3.2.3. Refer to OpenSSL’s documentation for cipher list formats.
---

```

The SSL context created above will only allow TLSv1.3 and later (if supported by your system) connections to a server. [`PROTOCOL_TLS_CLIENT`](https://docs.python.org/3/library/ssl.html#ssl.PROTOCOL_TLS_CLIENT "ssl.PROTOCOL_TLS_CLIENT") implies certificate validation and hostname checks by default. You have to load certificates into the context.
#### Cipher selection[¶](https://docs.python.org/3/library/ssl.html#cipher-selection "Link to this heading")
If you have advanced security requirements, fine-tuning of the ciphers enabled when negotiating a SSL session is possible through the [`SSLContext.set_ciphers()`](https://docs.python.org/3/library/ssl.html#ssl.SSLContext.set_ciphers "ssl.SSLContext.set_ciphers") method. Starting from Python 3.2.3, the ssl module disables certain weak ciphers by default, but you may want to further restrict the cipher choice. Be sure to read OpenSSL’s documentation about the [cipher list format](https://docs.openssl.org/1.1.1/man1/ciphers/#cipher-list-format). If you want to check which ciphers are enabled by a given cipher list, use [`SSLContext.get_ciphers()`](https://docs.python.org/3/library/ssl.html#ssl.SSLContext.get_ciphers "ssl.SSLContext.get_ciphers") or the `openssl ciphers` command on your system.
### Multi-processing[¶](https://docs.python.org/3/library/ssl.html#multi-processing "Link to this heading")
If using this module as part of a multi-processed application (using, for example the [`multiprocessing`](https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing "multiprocessing: Process-based parallelism.") or [`concurrent.futures`](https://docs.python.org/3/library/concurrent.futures.html#module-concurrent.futures "concurrent.futures: Execute computations concurrently using threads or processes.") modules), be aware that OpenSSL’s internal random number generator does not properly handle forked processes. Applications must change the PRNG state of the parent process if they use any SSL feature with [`os.fork()`](https://docs.python.org/3/library/os.html#os.fork "os.fork"). Any successful call of [`RAND_add()`](https://docs.python.org/3/library/ssl.html#ssl.RAND_add "ssl.RAND_add") or [`RAND_bytes()`](https://docs.python.org/3/library/ssl.html#ssl.RAND_bytes "ssl.RAND_bytes") is sufficient.
## TLS 1.3[¶](https://docs.python.org/3/library/ssl.html#tls-1-3 "Link to this heading")
Added in version 3.7.
The TLS 1.3 protocol behaves slightly differently than previous version of TLS/SSL. Some new TLS 1.3 features are not yet available.
  * TLS 1.3 uses a disjunct set of cipher suites. All AES-GCM and ChaCha20 cipher suites are enabled by default. The method [`SSLContext.set_ciphers()`](https://docs.python.org/3/library/ssl.html#ssl.SSLContext.set_ciphers "ssl.SSLContext.set_ciphers") cannot enable or disable any TLS 1.3 ciphers yet, but [`SSLContext.get_ciphers()`](https://docs.python.org/3/library/ssl.html#ssl.SSLContext.get_ciphers "ssl.SSLContext.get_ciphers") returns them.
  * Session tickets are no longer sent as part of the initial handshake and are handled differently. [`SSLSocket.session`](https://docs.python.org/3/library/ssl.html#ssl.SSLSocket.session "ssl.SSLSocket.session") and [`SSLSession`](https://docs.python.org/3/library/ssl.html#ssl.SSLSession "ssl.SSLSession") are not compatible with TLS 1.3.
  * Client-side certificates are also no longer verified during the initial handshake. A server can request a certificate at any time. Clients process certificate requests while they send or receive application data from the server.
  * TLS 1.3 features like early data, deferred TLS client cert request, signature algorithm configuration, and rekeying are not supported yet.


See also 

Class [`socket.socket`](https://docs.python.org/3/library/socket.html#socket.socket "socket.socket")
    
Documentation of underlying [`socket`](https://docs.python.org/3/library/socket.html#module-socket "socket: Low-level networking interface.") class 

[SSL/TLS Strong Encryption: An Introduction](https://httpd.apache.org/docs/trunk/en/ssl/ssl_intro.html)
    
Intro from the Apache HTTP Server documentation 

[**RFC 1422: Privacy Enhancement for Internet Electronic Mail: Part II: Certificate-Based Key Management**](https://datatracker.ietf.org/doc/html/rfc1422.html)
    
Steve Kent 

[**RFC 4086: Randomness Requirements for Security**](https://datatracker.ietf.org/doc/html/rfc4086.html)
    
Donald E., Jeffrey I. Schiller 

[**RFC 5280: Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile**](https://datatracker.ietf.org/doc/html/rfc5280.html)
    
D. Cooper 

[**RFC 5246: The Transport Layer Security (TLS) Protocol Version 1.2**](https://datatracker.ietf.org/doc/html/rfc5246.html)
    
T. Dierks et. al. 

[**RFC 6066: Transport Layer Security (TLS) Extensions**](https://datatracker.ietf.org/doc/html/rfc6066.html)
    
D. Eastlake