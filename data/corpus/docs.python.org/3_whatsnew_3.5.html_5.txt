Title: Enhanced Unpacking Features in Python 3.5
URL: https://docs.python.org/3/whatsnew/3.5.html
Summary: Python 3.5 introduces multiple unpacking capabilities for tuples, lists, sets, and dictionaries. Examples demonstrate how to unpack ranges and dictionaries using the new syntax. This feature is based on PEP 448, which outlines additional unpacking generalizations.
---

```

Similarly, tuple, list, set, and dictionary displays allow multiple unpackings (see [Expression lists](https://docs.python.org/3/reference/expressions.html#exprlists) and [Dictionary displays](https://docs.python.org/3/reference/expressions.html#dict)):
>>>```
>>> *range(4), 4
(0, 1, 2, 3, 4)
>>> [*range(4), 4]
[0, 1, 2, 3, 4]
>>> {*range(4), 4, *(5, 6, 7)}
{0, 1, 2, 3, 4, 5, 6, 7}
>>> {'x': 1, **{'y': 2}}
{'x': 1, 'y': 2}

```

See also 

[**PEP 448**](https://peps.python.org/pep-0448/) – Additional Unpacking Generalizations
    
PEP written by Joshua Landau; implemented by Neil Girdhar, Thomas Wouters, and Joshua Landau.
### PEP 461 - percent formatting support for bytes and bytearray[¶](https://docs.python.org/3/whatsnew/3.5.html#pep-461-percent-formatting-support-for-bytes-and-bytearray "Link to this heading")
[**PEP 461**](https://peps.python.org/pep-0461/) adds support for the `%` [interpolation operator](https://docs.python.org/3/library/stdtypes.html#bytes-formatting) to [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "bytes") and [`bytearray`](https://docs.python.org/3/library/stdtypes.html#bytearray "bytearray").
While interpolation is usually thought of as a string operation, there are cases where interpolation on `bytes` or `bytearrays` makes sense, and the work needed to make up for this missing functionality detracts from the overall readability of the code. This issue is particularly important when dealing with wire format protocols, which are often a mixture of binary and ASCII compatible text.
Examples:
>>>```
>>> b'Hello %b!' % b'World'
b'Hello World!'
>>> b'x=%i y=%f' % (1, 2.5)
b'x=1 y=2.500000'

```

Unicode is not allowed for `%b`, but it is accepted by `%a` (equivalent of `repr(obj).encode('ascii', 'backslashreplace')`):
>>>```
>>> b'Hello %b!' % 'World'
Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
TypeError: %b requires bytes, or an object that implements __bytes__, not 'str'
>>> b'price: %a' % '10€'
b"price: '10\\u20ac'"

```

Note that `%s` and `%r` conversion types, although supported, should only be used in codebases that need compatibility with Python 2.
See also 

[**PEP 461**](https://peps.python.org/pep-0461/) – Adding % formatting to bytes and bytearray
    
PEP written by Ethan Furman; implemented by Neil Schemenauer and Ethan Furman.
### PEP 484 - Type Hints[¶](https://docs.python.org/3/whatsnew/3.5.html#pep-484-type-hints "Link to this heading")
Function annotation syntax has been a Python feature since version 3.0 ([**PEP 3107**](https://peps.python.org/pep-3107/)), however the semantics of annotations has been left undefined.
Experience has shown that the majority of function annotation uses were to provide type hints to function parameters and return values. It became evident that it would be beneficial for Python users, if the standard library included the base definitions and tools for type annotations.
[**PEP 484**](https://peps.python.org/pep-0484/) introduces a [provisional module](https://docs.python.org/3/glossary.html#term-provisional-API) to provide these standard definitions and tools, along with some conventions for situations where annotations are not available.
For example, here is a simple function whose argument and return type are declared in the annotations:
```
defgreeting(name: str) -> str:
  return 'Hello ' + name