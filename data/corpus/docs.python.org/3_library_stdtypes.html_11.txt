Title: Slicing in Python Sequences
URL: https://docs.python.org/3/library/stdtypes.html
Summary: This section explains how to slice sequences in Python using indices. It covers handling negative indices, the definition of slices, handling omitted indices, and slicing with a step value. Key points include how to define the start and end of a slice based on given indices and the implications of index limits.
---

```

Further explanation is available in the FAQ entry [How do I create a multidimensional list?](https://docs.python.org/3/faq/programming.html#faq-multidimensional-list).
  3. If _i_ or _j_ is negative, the index is relative to the end of sequence _s_ : `len(s) + i` or `len(s) + j` is substituted. But note that `-0` is still `0`.
  4. The slice of _s_ from _i_ to _j_ is defined as the sequence of items with index _k_ such that `i <= k < j`. If _i_ or _j_ is greater than `len(s)`, use `len(s)`. If _i_ is omitted or `None`, use `0`. If _j_ is omitted or `None`, use `len(s)`. If _i_ is greater than or equal to _j_ , the slice is empty.
  5. The slice of _s_ from _i_ to _j_ with step _k_ is defined as the sequence of items with index `x = i + n*k` such that `0 <= n < (j-i)/k`. In other words, the indices are `i`, `i+k`, `i+2*k`, `i+3*k` and so on, stopping when _j_ is reached (but never including _j_). When _k_ is positive, _i_ and _j_ are reduced to `len(s)` if they are greater. When _k_ is negative, _i_ and _j_ are reduced to `len(s) - 1` if they are greater. If _i_ or _j_ are omitted or `None`, they become “end” values (which end depends on the sign of _k_). Note, _k_ cannot be zero. If _k_ is `None`, it is treated like `1`.
  6. Concatenating immutable sequences always results in a new object. This means that building up a sequence by repeated concatenation will have a quadratic runtime cost in the total sequence length. To get a linear runtime cost, you must switch to one of the alternatives below:
     * if concatenating [`str`](https://docs.python.org/3/library/stdtypes.html#str "str") objects, you can build a list and use [`str.join()`](https://docs.python.org/3/library/stdtypes.html#str.join "str.join") at the end or else write to an [`io.StringIO`](https://docs.python.org/3/library/io.html#io.StringIO "io.StringIO") instance and retrieve its value when complete
     * if concatenating [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "bytes") objects, you can similarly use [`bytes.join()`](https://docs.python.org/3/library/stdtypes.html#bytes.join "bytes.join") or [`io.BytesIO`](https://docs.python.org/3/library/io.html#io.BytesIO "io.BytesIO"), or you can do in-place concatenation with a [`bytearray`](https://docs.python.org/3/library/stdtypes.html#bytearray "bytearray") object. [`bytearray`](https://docs.python.org/3/library/stdtypes.html#bytearray "bytearray") objects are mutable and have an efficient overallocation mechanism
     * if concatenating [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "tuple") objects, extend a [`list`](https://docs.python.org/3/library/stdtypes.html#list "list") instead
     * for other types, investigate the relevant class documentation
  7. Some sequence types (such as [`range`](https://docs.python.org/3/library/stdtypes.html#range "range")) only support item sequences that follow specific patterns, and hence don’t support sequence concatenation or repetition.
  8. `index` raises [`ValueError`](https://docs.python.org/3/library/exceptions.html#ValueError "ValueError") when _x_ is not found in _s_. Not all implementations support passing the additional arguments _i_ and _j_. These arguments allow efficient searching of subsections of the sequence. Passing the extra arguments is roughly equivalent to using `s[i:j].index(x)`, only without copying any data and with the returned index being relative to the start of the sequence rather than the start of the slice.