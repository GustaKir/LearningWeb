Title: Python Built-in Functions Documentation
URL: https://docs.python.org/3/library/functions.html
Summary: This section discusses the use of keyword arguments in the three-argument form with class metaclasses, highlighting changes in version 3.6 regarding type subclasses. It also references additional documentation on class attributes, methods, and customizing class creation. The `vars()` function is mentioned with a link to its definition.
---

```

See also:
  * [Documentation on attributes and methods on classes](https://docs.python.org/3/reference/datamodel.html#class-attrs-and-methods).
  * [Type Objects](https://docs.python.org/3/library/stdtypes.html#bltin-type-objects)


Keyword arguments provided to the three argument form are passed to the appropriate metaclass machinery (usually [`__init_subclass__()`](https://docs.python.org/3/reference/datamodel.html#object.__init_subclass__ "object.__init_subclass__")) in the same way that keywords in a class definition (besides _metaclass_) would.
See also [Customizing class creation](https://docs.python.org/3/reference/datamodel.html#class-customization).
Changed in version 3.6: Subclasses of `type` which don’t override `type.__new__` may no longer use the one-argument form to get the type of an object. 

vars()[¶](https://docs.python.org/3/library/functions.html#vars "Link to this definition")


vars(_object_)
    
Return the [`__dict__`](https://docs.python.org/3/reference/datamodel.html#object.__dict__ "object.__dict__") attribute for a module, class, instance, or any other object with a `__dict__` attribute.
Objects such as modules and instances have an updateable [`__dict__`](https://docs.python.org/3/reference/datamodel.html#object.__dict__ "object.__dict__") attribute; however, other objects may have write restrictions on their `__dict__` attributes (for example, classes use a [`types.MappingProxyType`](https://docs.python.org/3/library/types.html#types.MappingProxyType "types.MappingProxyType") to prevent direct dictionary updates).
Without an argument, [`vars()`](https://docs.python.org/3/library/functions.html#vars "vars") acts like [`locals()`](https://docs.python.org/3/library/functions.html#locals "locals").
A [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError "TypeError") exception is raised if an object is specified but it doesn’t have a [`__dict__`](https://docs.python.org/3/reference/datamodel.html#object.__dict__ "object.__dict__") attribute (for example, if its class defines the [`__slots__`](https://docs.python.org/3/reference/datamodel.html#object.__slots__ "object.__slots__") attribute).
Changed in version 3.13: The result of calling this function without an argument has been updated as described for the [`locals()`](https://docs.python.org/3/library/functions.html#locals "locals") builtin. 

zip(_* iterables_, _strict =False_)[¶](https://docs.python.org/3/library/functions.html#zip "Link to this definition")
    
Iterate over several iterables in parallel, producing tuples with an item from each one.
Example:
>>>```
>>> for item in zip([1, 2, 3], ['sugar', 'spice', 'everything nice']):
...   print(item)
...
(1, 'sugar')
(2, 'spice')
(3, 'everything nice')

```

More formally: [`zip()`](https://docs.python.org/3/library/functions.html#zip "zip") returns an iterator of tuples, where the _i_ -th tuple contains the _i_ -th element from each of the argument iterables.
Another way to think of [`zip()`](https://docs.python.org/3/library/functions.html#zip "zip") is that it turns rows into columns, and columns into rows. This is similar to [transposing a matrix](https://en.wikipedia.org/wiki/Transpose).
[`zip()`](https://docs.python.org/3/library/functions.html#zip "zip") is lazy: The elements won’t be processed until the iterable is iterated on, e.g. by a `for` loop or by wrapping in a [`list`](https://docs.python.org/3/library/stdtypes.html#list "list").
One thing to consider is that the iterables passed to [`zip()`](https://docs.python.org/3/library/functions.html#zip "zip") could have different lengths; sometimes by design, and sometimes because of a bug in the code that prepared these iterables. Python offers three different approaches to dealing with this issue:
  * By default, [`zip()`](https://docs.python.org/3/library/functions.html#zip "zip") stops when the shortest iterable is exhausted. It will ignore the remaining items in the longer iterables, cutting off the result to the length of the shortest iterable:
>>>```
>>> list(zip(range(3), ['fee', 'fi', 'fo', 'fum']))
[(0, 'fee'), (1, 'fi'), (2, 'fo')]

```

  * [`zip()`](https://docs.python.org/3/library/functions.html#zip "zip") is often used in cases where the iterables are assumed to be of equal length. In such cases, it’s recommended to use the `strict=True` option. Its output is the same as regular [`zip()`](https://docs.python.org/3/library/functions.html#zip "zip"):
>>>```
>>> list(zip(('a', 'b', 'c'), (1, 2, 3), strict=True))
[('a', 1), ('b', 2), ('c', 3)]

```

Unlike the default behavior, it raises a [`ValueError`](https://docs.python.org/3/library/exceptions.html#ValueError "ValueError") if one iterable is exhausted before the others:
>>>```
>>> for item in zip(range(3), ['fee', 'fi', 'fo', 'fum'], strict=True):
...   print(item)
...
(0, 'fee')
(1, 'fi')
(2, 'fo')
Traceback (most recent call last):
...
ValueError: zip() argument 2 is longer than argument 1