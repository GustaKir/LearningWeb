Title: Multiprocessing Proxy Objects
URL: https://docs.python.org/3/library/multiprocessing.html
Summary: This section explains the behavior of proxy objects in Python's multiprocessing module. It highlights that applying `str()` to a proxy returns the referent's representation while `repr()` returns the proxy's representation. Proxy objects are picklable, allowing them to be passed between processes, enabling nesting of managed lists and dictionaries.
---

```

Notice that applying [`str()`](https://docs.python.org/3/library/stdtypes.html#str "str") to a proxy will return the representation of the referent, whereas applying [`repr()`](https://docs.python.org/3/library/functions.html#repr "repr") will return the representation of the proxy.
An important feature of proxy objects is that they are picklable so they can be passed between processes. As such, a referent can contain [Proxy Objects](https://docs.python.org/3/library/multiprocessing.html#multiprocessing-proxy-objects). This permits nesting of these managed lists, dicts, and other [Proxy Objects](https://docs.python.org/3/library/multiprocessing.html#multiprocessing-proxy-objects):
>>>```
>>> a = manager.list()
>>> b = manager.list()
>>> a.append(b)     # referent of a now contains referent of b
>>> print(a, b)
[<ListProxy object, typeid 'list' at ...>] []
>>> b.append('hello')
>>> print(a[0], b)
['hello'] ['hello']

```

Similarly, dict and list proxies may be nested inside one another:
>>>```
>>> l_outer = manager.list([ manager.dict() for i in range(2) ])
>>> d_first_inner = l_outer[0]
>>> d_first_inner['a'] = 1
>>> d_first_inner['b'] = 2
>>> l_outer[1]['c'] = 3
>>> l_outer[1]['z'] = 26
>>> print(l_outer[0])
{'a': 1, 'b': 2}
>>> print(l_outer[1])
{'c': 3, 'z': 26}

```

If standard (non-proxy) [`list`](https://docs.python.org/3/library/stdtypes.html#list "list") or [`dict`](https://docs.python.org/3/library/stdtypes.html#dict "dict") objects are contained in a referent, modifications to those mutable values will not be propagated through the manager because the proxy has no way of knowing when the values contained within are modified. However, storing a value in a container proxy (which triggers a `__setitem__` on the proxy object) does propagate through the manager and so to effectively modify such an item, one could re-assign the modified value to the container proxy:
```
# create a list proxy and append a mutable object (a dictionary)
lproxy = manager.list()
lproxy.append({})
# now mutate the dictionary
d = lproxy[0]
d['a'] = 1
d['b'] = 2
# at this point, the changes to d are not yet synced, but by
# updating the dictionary, the proxy is notified of the change
lproxy[0] = d

```

This approach is perhaps less convenient than employing nested [Proxy Objects](https://docs.python.org/3/library/multiprocessing.html#multiprocessing-proxy-objects) for most use cases but also demonstrates a level of control over the synchronization.
Note
The proxy types in [`multiprocessing`](https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing "multiprocessing: Process-based parallelism.") do nothing to support comparisons by value. So, for instance, we have:
>>>```
>>> manager.list([1,2,3]) == [1,2,3]
False

```

One should just use a copy of the referent instead when making comparisons. 

_class_ multiprocessing.managers.BaseProxy[¶](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.managers.BaseProxy "Link to this definition")
    
Proxy objects are instances of subclasses of [`BaseProxy`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.managers.BaseProxy "multiprocessing.managers.BaseProxy"). 

_callmethod(_methodname_[, _args_[, _kwds_]])[¶](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.managers.BaseProxy._callmethod "Link to this definition")
    
Call and return the result of a method of the proxy’s referent.
If `proxy` is a proxy whose referent is `obj` then the expression
```
proxy._callmethod(methodname, args, kwds)

```

will evaluate the expression
```
getattr(obj, methodname)(*args, **kwds)

```

in the manager’s process.
The returned value will be a copy of the result of the call or a proxy to a new shared object – see documentation for the _method_to_typeid_ argument of [`BaseManager.register()`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.managers.BaseManager.register "multiprocessing.managers.BaseManager.register").
If an exception is raised by the call, then is re-raised by [`_callmethod()`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.managers.BaseProxy._callmethod "multiprocessing.managers.BaseProxy._callmethod"). If some other exception is raised in the manager’s process then this is converted into a `RemoteError` exception and is raised by [`_callmethod()`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.managers.BaseProxy._callmethod "multiprocessing.managers.BaseProxy._callmethod").
Note in particular that an exception will be raised if _methodname_ has not been _exposed_.
An example of the usage of [`_callmethod()`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.managers.BaseProxy._callmethod "multiprocessing.managers.BaseProxy._callmethod"):
>>>