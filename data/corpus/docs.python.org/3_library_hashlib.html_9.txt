Title: Randomized Hashing
URL: https://docs.python.org/3/library/hashlib.html
Summary: Randomized hashing involves using a _salt_ parameter to introduce randomization into hash functions, enhancing security against collision attacks, particularly in digital signatures. It mitigates the risk of message preparers creating collisions that can manipulate the outcome of signed messages.
---

```

#### Randomized hashing[¶](https://docs.python.org/3/library/hashlib.html#randomized-hashing "Link to this heading")
By setting _salt_ parameter users can introduce randomization to the hash function. Randomized hashing is useful for protecting against collision attacks on the hash function used in digital signatures.
> Randomized hashing is designed for situations where one party, the message preparer, generates all or part of a message to be signed by a second party, the message signer. If the message preparer is able to find cryptographic hash function collisions (i.e., two messages producing the same hash value), then they might prepare meaningful versions of the message that would produce the same hash value and digital signature, but with different results (e.g., transferring $1,000,000 to an account, rather than $10). Cryptographic hash functions have been designed with collision resistance as a major goal, but the current concentration on attacking cryptographic hash functions may result in a given cryptographic hash function providing less collision resistance than expected. Randomized hashing offers the signer additional protection by reducing the likelihood that a preparer can generate two or more messages that ultimately yield the same hash value during the digital signature generation process — even if it is practical to find collisions for the hash function. However, the use of randomized hashing may reduce the amount of security provided by a digital signature when all portions of the message are prepared by the signer.
> ([NIST SP-800-106 “Randomized Hashing for Digital Signatures”](https://csrc.nist.gov/pubs/sp/800/106/final))
In BLAKE2 the salt is processed as a one-time input to the hash function during initialization, rather than as an input to each compression function.
Warning
_Salted hashing_ (or just hashing) with BLAKE2 or any other general-purpose cryptographic hash function, such as SHA-256, is not suitable for hashing passwords. See [BLAKE2 FAQ](https://www.blake2.net/#qa) for more information.
>>>```
>>> importos
>>> fromhashlibimport blake2b
>>> msg = b'some message'
>>> # Calculate the first hash with a random salt.
>>> salt1 = os.urandom(blake2b.SALT_SIZE)
>>> h1 = blake2b(salt=salt1)
>>> h1.update(msg)
>>> # Calculate the second hash with a different random salt.
>>> salt2 = os.urandom(blake2b.SALT_SIZE)
>>> h2 = blake2b(salt=salt2)
>>> h2.update(msg)
>>> # The digests are different.
>>> h1.digest() != h2.digest()
True

```

#### Personalization[¶](https://docs.python.org/3/library/hashlib.html#personalization "Link to this heading")
Sometimes it is useful to force hash function to produce different digests for the same input for different purposes. Quoting the authors of the Skein hash function:
> We recommend that all application designers seriously consider doing this; we have seen many protocols where a hash that is computed in one part of the protocol can be used in an entirely different part because two hash computations were done on similar or related data, and the attacker can force the application to make the hash inputs the same. Personalizing each hash function used in the protocol summarily stops this type of attack.
> ([The Skein Hash Function Family](https://www.schneier.com/wp-content/uploads/2016/02/skein.pdf), p. 21)
BLAKE2 can be personalized by passing bytes to the _person_ argument:
>>>```
>>> fromhashlibimport blake2b
>>> FILES_HASH_PERSON = b'MyApp Files Hash'
>>> BLOCK_HASH_PERSON = b'MyApp Block Hash'
>>> h = blake2b(digest_size=32, person=FILES_HASH_PERSON)
>>> h.update(b'the same content')
>>> h.hexdigest()
'20d9cd024d4fb086aae819a1432dd2466de12947831b75c5a30cf2676095d3b4'
>>> h = blake2b(digest_size=32, person=BLOCK_HASH_PERSON)
>>> h.update(b'the same content')
>>> h.hexdigest()
'cf68fb5761b9c44e7878bfb2c4c9aea52264a80b75005e65619778de59f383a3'

```

Personalization together with the keyed mode can also be used to derive different keys from a single one.
>>>```
>>> fromhashlibimport blake2s
>>> frombase64import b64decode, b64encode
>>> orig_key = b64decode(b'Rm5EPJai72qcK3RGBpW3vPNfZy5OZothY+kHY6h21KM=')
>>> enc_key = blake2s(key=orig_key, person=b'kEncrypt').digest()
>>> mac_key = blake2s(key=orig_key, person=b'kMAC').digest()
>>> print(b64encode(enc_key).decode('utf-8'))
rbPb15S/Z9t+agffno5wuhB77VbRi6F9Iv2qIxU7WHw=
>>> print(b64encode(mac_key).decode('utf-8'))
G9GtHFE1YluXY1zWPlYk1e/nWfu0WSEb0KRcjhDeP/o=

```

#### Tree mode[¶](https://docs.python.org/3/library/hashlib.html#tree-mode "Link to this heading")
Here’s an example of hashing a minimal tree with two leaf nodes:
```
 10
 / \
00 01

```

This example uses 64-byte internal digests, and returns the 32-byte final digest:
>>>