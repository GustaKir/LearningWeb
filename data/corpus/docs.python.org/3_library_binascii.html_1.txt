Title: binascii Module: Base64 Conversion Functions
URL: https://docs.python.org/3/library/binascii.html
Summary: The `binascii.a2b_base64` function converts base64 data back to binary, with an optional strict mode for validating data. The function complies with RFC 3548. The `binascii.b2a_base64` function is used to convert binary data to base64 format.
---

binascii.a2b_base64(_string_ , _/_ , _*_ , _strict_mode =False_)[¶](https://docs.python.org/3/library/binascii.html#binascii.a2b_base64 "Link to this definition")
    
Convert a block of base64 data back to binary and return the binary data. More than one line may be passed at a time.
If _strict_mode_ is true, only valid base64 data will be converted. Invalid base64 data will raise [`binascii.Error`](https://docs.python.org/3/library/binascii.html#binascii.Error "binascii.Error").
Valid base64:
  * Conforms to [**RFC 3548**](https://datatracker.ietf.org/doc/html/rfc3548.html).
  * Contains only characters from the base64 alphabet.
  * Contains no excess data after padding (including excess padding, newlines, etc.).
  * Does not start with a padding.


Changed in version 3.11: Added the _strict_mode_ parameter. 

binascii.b2a_base64(_data_ , _*_ , _newline =True_)[¶](https://docs.python.org/3/library/binascii.html#binascii.b2a_base64 "Link to this definition")
    
Convert binary data to a line of ASCII characters in base64 coding. The return value is the converted line, including a newline char if _newline_ is true. The output of this function conforms to [**RFC 3548**](https://datatracker.ietf.org/doc/html/rfc3548.html).
Changed in version 3.6: Added the _newline_ parameter. 

binascii.a2b_qp(_data_ , _header =False_)[¶](https://docs.python.org/3/library/binascii.html#binascii.a2b_qp "Link to this definition")
    
Convert a block of quoted-printable data back to binary and return the binary data. More than one line may be passed at a time. If the optional argument _header_ is present and true, underscores will be decoded as spaces. 

binascii.b2a_qp(_data_ , _quotetabs =False_, _istext =True_, _header =False_)[¶](https://docs.python.org/3/library/binascii.html#binascii.b2a_qp "Link to this definition")
    
Convert binary data to a line(s) of ASCII characters in quoted-printable encoding. The return value is the converted line(s). If the optional argument _quotetabs_ is present and true, all tabs and spaces will be encoded. If the optional argument _istext_ is present and true, newlines are not encoded but trailing whitespace will be encoded. If the optional argument _header_ is present and true, spaces will be encoded as underscores per [**RFC 1522**](https://datatracker.ietf.org/doc/html/rfc1522.html). If the optional argument _header_ is present and false, newline characters will be encoded as well; otherwise linefeed conversion might corrupt the binary data stream. 

binascii.crc_hqx(_data_ , _value_)[¶](https://docs.python.org/3/library/binascii.html#binascii.crc_hqx "Link to this definition")
    
Compute a 16-bit CRC value of _data_ , starting with _value_ as the initial CRC, and return the result. This uses the CRC-CCITT polynomial _x_ 16 + _x_ 12 + _x_ 5 + 1, often represented as 0x1021. This CRC is used in the binhex4 format. 

binascii.crc32(_data_[, _value_])[¶](https://docs.python.org/3/library/binascii.html#binascii.crc32 "Link to this definition")
    
Compute CRC-32, the unsigned 32-bit checksum of _data_ , starting with an initial CRC of _value_. The default initial CRC is zero. The algorithm is consistent with the ZIP file checksum. Since the algorithm is designed for use as a checksum algorithm, it is not suitable for use as a general hash algorithm. Use as follows:
```
print(binascii.crc32(b"hello world"))
# Or, in two pieces:
crc = binascii.crc32(b"hello")
crc = binascii.crc32(b" world", crc)
print('crc32 = {:#010x}'.format(crc))

```

Changed in version 3.0: The result is always unsigned. 

binascii.b2a_hex(_data_[, _sep_[, _bytes_per_sep=1_]])[¶](https://docs.python.org/3/library/binascii.html#binascii.b2a_hex "Link to this definition")


binascii.hexlify(_data_[, _sep_[, _bytes_per_sep=1_]])[¶](https://docs.python.org/3/library/binascii.html#binascii.hexlify "Link to this definition")
    
Return the hexadecimal representation of the binary _data_. Every byte of _data_ is converted into the corresponding 2-digit hex representation. The returned bytes object is therefore twice as long as the length of _data_.
Similar functionality (but returning a text string) is also conveniently accessible using the [`bytes.hex()`](https://docs.python.org/3/library/stdtypes.html#bytes.hex "bytes.hex") method.
If _sep_ is specified, it must be a single character str or bytes object. It will be inserted in the output after every _bytes_per_sep_ input bytes. Separator placement is counted from the right end of the output by default, if you wish to count from the left, supply a negative _bytes_per_sep_ value.
>>>```
>>> importbinascii
>>> binascii.b2a_hex(b'\xb9\x01\xef')
b'b901ef'
>>> binascii.hexlify(b'\xb9\x01\xef', '-')
b'b9-01-ef'
>>> binascii.b2a_hex(b'\xb9\x01\xef', b'_', 2)
b'b9_01ef'
>>> binascii.b2a_hex(b'\xb9\x01\xef', b' ', -2)
b'b901 ef'