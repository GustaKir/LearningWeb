Title: Using the `cast()` Function in ctypes
URL: https://docs.python.org/3/library/ctypes.html
Summary: The `cast()` function in the ctypes library allows users to convert a ctypes instance into a pointer of another ctypes data type. It takes a ctypes object and a ctypes pointer type and returns a new instance that references the same memory block.
---

```

For these cases, the [`cast()`](https://docs.python.org/3/library/ctypes.html#ctypes.cast "ctypes.cast") function is handy.
The [`cast()`](https://docs.python.org/3/library/ctypes.html#ctypes.cast "ctypes.cast") function can be used to cast a ctypes instance into a pointer to a different ctypes data type. [`cast()`](https://docs.python.org/3/library/ctypes.html#ctypes.cast "ctypes.cast") takes two parameters, a ctypes object that is or can be converted to a pointer of some kind, and a ctypes pointer type. It returns an instance of the second argument, which references the same memory block as the first argument:
>>>```
>>> a = (c_byte * 4)()
>>> cast(a, POINTER(c_int))
<ctypes.LP_c_long object at ...>
>>>

```

So, [`cast()`](https://docs.python.org/3/library/ctypes.html#ctypes.cast "ctypes.cast") can be used to assign to the `values` field of `Bar` the structure:
>>>```
>>> bar = Bar()
>>> bar.values = cast((c_byte * 4)(), POINTER(c_int))
>>> print(bar.values[0])
0
>>>

```

### Incomplete Types[¶](https://docs.python.org/3/library/ctypes.html#incomplete-types "Link to this heading")
_Incomplete Types_ are structures, unions or arrays whose members are not yet specified. In C, they are specified by forward declarations, which are defined later:
```
struct cell; /* forward declaration */
struct cell {
  char *name;
  struct cell *next;
};

```

The straightforward translation into ctypes code would be this, but it does not work:
>>>```
>>> classcell(Structure):
...   _fields_ = [("name", c_char_p),
...         ("next", POINTER(cell))]
...
Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
 File "<stdin>", line 2, in cell
NameError: name 'cell' is not defined
>>>

```

because the new `class cell` is not available in the class statement itself. In [`ctypes`](https://docs.python.org/3/library/ctypes.html#module-ctypes "ctypes: A foreign function library for Python."), we can define the `cell` class and set the [`_fields_`](https://docs.python.org/3/library/ctypes.html#ctypes.Structure._fields_ "ctypes.Structure._fields_") attribute later, after the class statement:
>>>```
>>> fromctypesimport *
>>> classcell(Structure):
...   pass
...
>>> cell._fields_ = [("name", c_char_p),
...          ("next", POINTER(cell))]
>>>

```

Let’s try it. We create two instances of `cell`, and let them point to each other, and finally follow the pointer chain a few times:
>>>```
>>> c1 = cell()
>>> c1.name = b"foo"
>>> c2 = cell()
>>> c2.name = b"bar"
>>> c1.next = pointer(c2)
>>> c2.next = pointer(c1)
>>> p = c1
>>> for i in range(8):
...   print(p.name, end=" ")
...   p = p.next[0]
...
foo bar foo bar foo bar foo bar
>>>

```

### Callback functions[¶](https://docs.python.org/3/library/ctypes.html#callback-functions "Link to this heading")
[`ctypes`](https://docs.python.org/3/library/ctypes.html#module-ctypes "ctypes: A foreign function library for Python.") allows creating C callable function pointers from Python callables. These are sometimes called _callback functions_.
First, you must create a class for the callback function. The class knows the calling convention, the return type, and the number and types of arguments this function will receive.
The [`CFUNCTYPE()`](https://docs.python.org/3/library/ctypes.html#ctypes.CFUNCTYPE "ctypes.CFUNCTYPE") factory function creates types for callback functions using the `cdecl` calling convention. On Windows, the [`WINFUNCTYPE()`](https://docs.python.org/3/library/ctypes.html#ctypes.WINFUNCTYPE "ctypes.WINFUNCTYPE") factory function creates types for callback functions using the `stdcall` calling convention.
Both of these factory functions are called with the result type as first argument, and the callback functions expected argument types as the remaining arguments.
I will present an example here which uses the standard C library’s `qsort()` function, that is used to sort items with the help of a callback function. `qsort()` will be used to sort an array of integers:
>>>```
>>> IntArray5 = c_int * 5
>>> ia = IntArray5(5, 1, 7, 33, 99)
>>> qsort = libc.qsort
>>> qsort.restype = None
>>>

```

`qsort()` must be called with a pointer to the data to sort, the number of items in the data array, the size of one item, and a pointer to the comparison function, the callback. The callback will then be called with two pointers to items, and it must return a negative integer if the first item is smaller than the second, a zero if they are equal, and a positive integer otherwise.
So our callback function receives pointers to integers, and must return an integer. First we create the `type` for the callback function:
>>>```
>>> CMPFUNC = CFUNCTYPE(c_int, POINTER(c_int), POINTER(c_int))
>>>

```

To get started, here is a simple callback that shows the values it gets passed:
>>>```
>>> defpy_cmp_func(a, b):
...   print("py_cmp_func", a[0], b[0])
...   return 0
...
>>> cmp_func = CMPFUNC(py_cmp_func)
>>>

```

The result:
>>>