Title: Using TestSuite for Test Discovery
URL: https://docs.python.org/3/library/unittest.html
Summary: This section explains how to return a TestSuite representing all tests in a package using a custom load_tests function. It includes an example implementation and notes a change made in version 3.5 regarding the pattern matching for package names during test discovery.
---

```

This should return a [`TestSuite`](https://docs.python.org/3/library/unittest.html#unittest.TestSuite "unittest.TestSuite") representing all the tests from the package. (`standard_tests` will only contain tests collected from `__init__.py`.)
Because the pattern is passed into `load_tests` the package is free to continue (and potentially modify) test discovery. A ‘do nothing’ `load_tests` function for a test package would look like:
```
defload_tests(loader, standard_tests, pattern):
  # top level directory cached on loader instance
  this_dir = os.path.dirname(__file__)
  package_tests = loader.discover(start_dir=this_dir, pattern=pattern)
  standard_tests.addTests(package_tests)
  return standard_tests

```

Changed in version 3.5: Discovery no longer checks package names for matching _pattern_ due to the impossibility of package names matching the default pattern.
## Class and Module Fixtures[¶](https://docs.python.org/3/library/unittest.html#class-and-module-fixtures "Link to this heading")
Class and module level fixtures are implemented in [`TestSuite`](https://docs.python.org/3/library/unittest.html#unittest.TestSuite "unittest.TestSuite"). When the test suite encounters a test from a new class then `tearDownClass()` from the previous class (if there is one) is called, followed by `setUpClass()` from the new class.
Similarly if a test is from a different module from the previous test then `tearDownModule` from the previous module is run, followed by `setUpModule` from the new module.
After all the tests have run the final `tearDownClass` and `tearDownModule` are run.
Note that shared fixtures do not play well with [potential] features like test parallelization and they break test isolation. They should be used with care.
The default ordering of tests created by the unittest test loaders is to group all tests from the same modules and classes together. This will lead to `setUpClass` / `setUpModule` (etc) being called exactly once per class and module. If you randomize the order, so that tests from different modules and classes are adjacent to each other, then these shared fixture functions may be called multiple times in a single test run.
Shared fixtures are not intended to work with suites with non-standard ordering. A `BaseTestSuite` still exists for frameworks that don’t want to support shared fixtures.
If there are any exceptions raised during one of the shared fixture functions the test is reported as an error. Because there is no corresponding test instance an `_ErrorHolder` object (that has the same interface as a [`TestCase`](https://docs.python.org/3/library/unittest.html#unittest.TestCase "unittest.TestCase")) is created to represent the error. If you are just using the standard unittest test runner then this detail doesn’t matter, but if you are a framework author it may be relevant.
### setUpClass and tearDownClass[¶](https://docs.python.org/3/library/unittest.html#setupclass-and-teardownclass "Link to this heading")
These must be implemented as class methods:
```
importunittest
classTest(unittest.TestCase):
  @classmethod
  defsetUpClass(cls):
    cls._connection = createExpensiveConnectionObject()
  @classmethod
  deftearDownClass(cls):
    cls._connection.destroy()

```

If you want the `setUpClass` and `tearDownClass` on base classes called then you must call up to them yourself. The implementations in [`TestCase`](https://docs.python.org/3/library/unittest.html#unittest.TestCase "unittest.TestCase") are empty.
If an exception is raised during a `setUpClass` then the tests in the class are not run and the `tearDownClass` is not run. Skipped classes will not have `setUpClass` or `tearDownClass` run. If the exception is a [`SkipTest`](https://docs.python.org/3/library/unittest.html#unittest.SkipTest "unittest.SkipTest") exception then the class will be reported as having been skipped instead of as an error.
### setUpModule and tearDownModule[¶](https://docs.python.org/3/library/unittest.html#setupmodule-and-teardownmodule "Link to this heading")
These should be implemented as functions:
```
defsetUpModule():
  createConnection()
deftearDownModule():
  closeConnection()