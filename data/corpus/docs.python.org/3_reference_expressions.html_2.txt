Title: Identifiers in Python Expressions
URL: https://docs.python.org/3/reference/expressions.html
Summary: This section discusses identifiers as names in Python expressions, explaining their binding to objects and the occurrence of `NameError` when unbound. It also mentions private name mangling for identifiers that start with two or more underscores in class definitions.
---

```

### 6.2.1. Identifiers (Names)[¶](https://docs.python.org/3/reference/expressions.html#atom-identifiers "Link to this heading")
An identifier occurring as an atom is a name. See section [Identifiers and keywords](https://docs.python.org/3/reference/lexical_analysis.html#identifiers) for lexical definition and section [Naming and binding](https://docs.python.org/3/reference/executionmodel.html#naming) for documentation of naming and binding.
When the name is bound to an object, evaluation of the atom yields that object. When a name is not bound, an attempt to evaluate it raises a [`NameError`](https://docs.python.org/3/library/exceptions.html#NameError "NameError") exception.
#### 6.2.1.1. Private name mangling[¶](https://docs.python.org/3/reference/expressions.html#index-5 "Link to this heading")
When an identifier that textually occurs in a class definition begins with two or more underscore characters and does not end in two or more underscores, it is considered a _private name_ of that class.
See also
The [class specifications](https://docs.python.org/3/reference/compound_stmts.html#class).
More precisely, private names are transformed to a longer form before code is generated for them. If the transformed name is longer than 255 characters, implementation-defined truncation may happen.
The transformation is independent of the syntactical context in which the identifier is used but only the following private identifiers are mangled:
  * Any name used as the name of a variable that is assigned or read or any name of an attribute being accessed.
The [`__name__`](https://docs.python.org/3/library/stdtypes.html#definition.__name__ "definition.__name__") attribute of nested functions, classes, and type aliases is however not mangled.
  * The name of imported modules, e.g., `__spam` in `import __spam`. If the module is part of a package (i.e., its name contains a dot), the name is _not_ mangled, e.g., the `__foo` in `import __foo.bar` is not mangled.
  * The name of an imported member, e.g., `__f` in `from spam import __f`.


The transformation rule is defined as follows:
  * The class name, with leading underscores removed and a single leading underscore inserted, is inserted in front of the identifier, e.g., the identifier `__spam` occurring in a class named `Foo`, `_Foo` or `__Foo` is transformed to `_Foo__spam`.
  * If the class name consists only of underscores, the transformation is the identity, e.g., the identifier `__spam` occurring in a class named `_` or `__` is left as is.


### 6.2.2. Literals[¶](https://docs.python.org/3/reference/expressions.html#literals "Link to this heading")
Python supports string and bytes literals and various numeric literals:
```
**literal** ::= [stringliteral](https://docs.python.org/3/reference/lexical_analysis.html#grammar-token-python-grammar-stringliteral) | [bytesliteral](https://docs.python.org/3/reference/lexical_analysis.html#grammar-token-python-grammar-bytesliteral)
      | [integer](https://docs.python.org/3/reference/lexical_analysis.html#grammar-token-python-grammar-integer) | [floatnumber](https://docs.python.org/3/reference/lexical_analysis.html#grammar-token-python-grammar-floatnumber) | [imagnumber](https://docs.python.org/3/reference/lexical_analysis.html#grammar-token-python-grammar-imagnumber)

```

Evaluation of a literal yields an object of the given type (string, bytes, integer, floating-point number, complex number) with the given value. The value may be approximated in the case of floating-point and imaginary (complex) literals. See section [Literals](https://docs.python.org/3/reference/lexical_analysis.html#literals) for details.
All literals correspond to immutable data types, and hence the object’s identity is less important than its value. Multiple evaluations of literals with the same value (either the same occurrence in the program text or a different occurrence) may obtain the same object or a different object with the same value.
### 6.2.3. Parenthesized forms[¶](https://docs.python.org/3/reference/expressions.html#parenthesized-forms "Link to this heading")
A parenthesized form is an optional expression list enclosed in parentheses:
```
**parenth_form** ::= "(" [[starred_expression](https://docs.python.org/3/reference/expressions.html#grammar-token-python-grammar-starred_expression)] ")"