Title: Introduction of Static Scoping in Python 2.2
URL: https://docs.python.org/3/whatsnew/2.2.html
Summary: Python 2.2 introduces static scoping to improve code readability by allowing variable references to be looked up in the enclosing scope's local namespace when not assigned within a function. This eliminates the need for the `name=name` default argument, although it may create compatibility issues for existing code using the same variable name in both local and module levels.
---

```

The readability of Python code written in a strongly functional style suffers greatly as a result.
The most significant change to Python 2.2 is that static scoping has been added to the language to fix this problem. As a first effect, the `name=name` default argument is now unnecessary in the above example. Put simply, when a given variable name is not assigned a value within a function (by an assignment, or the [`def`](https://docs.python.org/3/reference/compound_stmts.html#def), [`class`](https://docs.python.org/3/reference/compound_stmts.html#class), or [`import`](https://docs.python.org/3/reference/simple_stmts.html#import) statements), references to the variable will be looked up in the local namespace of the enclosing scope. A more detailed explanation of the rules, and a dissection of the implementation, can be found in the PEP.
This change may cause some compatibility problems for code where the same variable name is used both at the module level and as a local variable within a function that contains further function definitions. This seems rather unlikely though, since such code would have been pretty confusing to read in the first place.
One side effect of the change is that the `from module import *` and `exec` statements have been made illegal inside a function scope under certain conditions. The Python reference manual has said all along that `from module import *` is only legal at the top level of a module, but the CPython interpreter has never enforced this before. As part of the implementation of nested scopes, the compiler which turns Python source into bytecodes has to generate different code to access variables in a containing scope. `from module import *` and `exec` make it impossible for the compiler to figure this out, because they add names to the local namespace that are unknowable at compile time. Therefore, if a function contains function definitions or [`lambda`](https://docs.python.org/3/reference/expressions.html#lambda) expressions with free variables, the compiler will flag this by raising a [`SyntaxError`](https://docs.python.org/3/library/exceptions.html#SyntaxError "SyntaxError") exception.
To make the preceding explanation a bit clearer, here’s an example:
```
x = 1
deff():
  # The next line is a syntax error
  exec 'x=2'
  defg():
    return x

```

Line 4 containing the `exec` statement is a syntax error, since `exec` would define a new local variable named `x` whose value should be accessed by `g()`.
This shouldn’t be much of a limitation, since `exec` is rarely used in most Python code (and when it is used, it’s often a sign of a poor design anyway).
See also 

[**PEP 227**](https://peps.python.org/pep-0227/) - Statically Nested Scopes
    
Written and implemented by Jeremy Hylton.
## New and Improved Modules[¶](https://docs.python.org/3/whatsnew/2.2.html#new-and-improved-modules "Link to this heading")
  * The [`xmlrpclib`](https://docs.python.org/3/library/xmlrpc.client.html#module-xmlrpc.client "xmlrpc.client: XML-RPC client access.") module was contributed to the standard library by Fredrik Lundh, providing support for writing XML-RPC clients. XML-RPC is a simple remote procedure call protocol built on top of HTTP and XML. For example, the following snippet retrieves a list of RSS channels from the O’Reilly Network, and then lists the recent headlines for one channel:
```
importxmlrpclib
s = xmlrpclib.Server(
   'http://www.oreillynet.com/meerkat/xml-rpc/server.php')
channels = s.meerkat.getChannels()
# channels is a list of dictionaries, like this:
# [{'id': 4, 'title': 'Freshmeat Daily News'}
# {'id': 190, 'title': '32Bits Online'},
# {'id': 4549, 'title': '3DGamers'}, ... ]
# Get the items for one channel
items = s.meerkat.getItems( {'channel': 4} )
# 'items' is another list of dictionaries, like this:
# [{'link': 'http://freshmeat.net/releases/52719/',
#  'description': 'A utility which converts HTML to XSL FO.',
#  'title': 'html2fo 0.3 (Default)'}, ... ]