Title: Itertools Functions in Python
URL: https://docs.python.org/3/library/itertools.html
Summary: This section details several functions from the itertools module, including 'subslices' which returns all contiguous non-empty slices of a sequence, and 'iter_index' which yields indices of a specified value within an iterable. The algorithms utilize functions like 'map', 'cycle', and 'islice' to enhance iteration capabilities.
---

'EF') → A D E B F C
  # Algorithm credited to George Sakkis
  iterators = map(iter, iterables)
  for num_active in range(len(iterables), 0, -1):
    iterators = cycle(islice(iterators, num_active))
    yield from map(next, iterators)
defsubslices(seq):
  "Return all contiguous non-empty subslices of a sequence."
  # subslices('ABCD') → A AB ABC ABCD B BC BCD C CD D
  slices = starmap(slice, combinations(range(len(seq) + 1), 2))
  return map(getitem, repeat(seq), slices)
defiter_index(iterable, value, start=0, stop=None):
  "Return indices where a value occurs in a sequence or iterable."
  # iter_index('AABCADEAF', 'A') → 0 1 4 7
  seq_index = getattr(iterable, 'index', None)
  if seq_index is None:
    iterator = islice(iterable, start, stop)
    for i, element in enumerate(iterator, start):
      if element is value or element == value:
        yield i
  else:
    stop = len(iterable) if stop is None else stop
    i = start
    with suppress(ValueError):
      while True:
        yield (i := seq_index(value, i, stop))
        i += 1
defiter_except(function, exception, first=None):
  "Convert a call-until-exception interface to an iterator interface."
  # iter_except(d.popitem, KeyError) → non-blocking dictionary iterator
  with suppress(exception):
    if first is not None:
      yield first()
    while True:
      yield function()

```

The following recipes have a more mathematical flavor:
```
defmultinomial(*counts):
  "Number of distinct arrangements of a multiset."
  # Counter('abracadabra').values() → 5 2 2 1 1
  # multinomial(5, 2, 2, 1, 1) → 83160
  return prod(map(comb, accumulate(counts), counts))
defpowerset(iterable):
  "Subsequences of the iterable from shortest to longest."
  # powerset([1,2,3]) → () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)
  s = list(iterable)
  return chain.from_iterable(combinations(s, r) for r in range(len(s)+1))
defsum_of_squares(iterable):
  "Add up the squares of the input values."
  # sum_of_squares([10, 20, 30]) → 1400
  return sumprod(*tee(iterable))
defreshape(matrix, columns):
  "Reshape a 2-D matrix to have a given number of columns."
  # reshape([(0, 1), (2, 3), (4, 5)], 3) → (0, 1, 2), (3, 4, 5)
  return batched(chain.from_iterable(matrix), columns, strict=True)
deftranspose(matrix):
  "Swap the rows and columns of a 2-D matrix."
  # transpose([(1, 2, 3), (11, 22, 33)]) → (1, 11) (2, 22) (3, 33)
  return zip(*matrix, strict=True)
defmatmul(m1, m2):
  "Multiply two matrices."
  # matmul([(7, 5), (3, 5)], [(2, 5), (7, 9)]) → (49, 80), (41, 60)
  n = len(m2[0])
  return batched(starmap(sumprod, product(m1, transpose(m2))), n)
defconvolve(signal, kernel):
"""Discrete linear convolution of two iterables.
  Equivalent to polynomial multiplication.
  Convolutions are mathematically commutative; however, the inputs are
  evaluated differently. The signal is consumed lazily and can be
  infinite. The kernel is fully consumed before the calculations begin.
  Article: https://betterexplained.com/articles/intuitive-convolution/
  Video:  https://www.youtube.com/watch?v=KuXjwB4LzSA
  """
  # convolve([1, -1, -20], [1, -3]) → 1 -4 -17 60
  # convolve(data, [0.25, 0.25, 0.25, 0.25]) → Moving average (blur)
  # convolve(data, [1/2, 0, -1/2]) → 1st derivative estimate
  # convolve(data, [1, -2, 1]) → 2nd derivative estimate
  kernel = tuple(kernel)[::-1]
  n = len(kernel)
  padded_signal = chain(repeat(0, n-1), signal, repeat(0, n-1))
  windowed_signal = sliding_window(padded_signal, n)
  return map(sumprod, repeat(kernel), windowed_signal)
defpolynomial_from_roots(roots):
"""Compute a polynomial's coefficients from its roots.
    (x - 5) (x + 4) (x - 3) expands to:  x³ -4x² -17x + 60
  """
  # polynomial_from_roots([5, -4, 3]) → [1, -4, -17, 60]
  factors = zip(repeat(1), map(neg, roots))
  return list(reduce(convolve, factors, [1]))
defpolynomial_eval(coefficients, x):
"""Evaluate a polynomial at a specific value.
  Computes with better numeric stability than Horner's method.
  """
  # Evaluate x³ -4x² -17x + 60 at x = 5
  # polynomial_eval([1, -4, -17, 60], x=5) → 0
  n = len(coefficients)
  if not n:
    return type(x)(0)
  powers = map(pow, repeat(x), reversed(range(n)))
  return sumprod(coefficients, powers)
defpolynomial_derivative(coefficients):
"""Compute the first derivative of a polynomial.
    f(x) = x³ -4x² -17x + 60
    f'(x) = 3x² -8x -17
  """
  # polynomial_derivative([1, -4, -17, 60]) → [3, -8, -17]
  n = len(coefficients)
  powers = reversed(range(1, n))
  return list(map(mul, coefficients, powers))
defsieve(n):
  "Primes less than n."
  # sieve(30) → 2 3 5 7 11 13 17 19 23 29
  if n > 2:
    yield 2
  data = bytearray((0, 1)) * (n // 2)
  for p in iter_index(data, 1, start=3, stop=isqrt(n) + 1):
    data[p*p : n : p+p] = bytes(len(range(p*p, n, p+p)))
  yield from iter_index(data, 1, start=3)
deffactor(n):
  "Prime factors of n."
  # factor(99) → 3 3 11
  # factor(1_000_000_000_000_007) → 47 59 360620266859
  # factor(1_000_000_000_000_403) → 10000000000004