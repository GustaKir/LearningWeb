Title: Generating Secure Tokens with the Secrets Module
URL: https://docs.python.org/3/library/secrets.html
Summary: The `secrets` module in Python provides functions for generating secure random numbers and tokens. It includes the `randbits(_k_)` function to return a non-negative integer with _k_ random bits, and methods like `token_bytes(_nbytes)` and `token_hex(_nbytes)` for creating secure byte strings and hexadecimal representations of random tokens.
---

secrets.randbits(_k_)[¶](https://docs.python.org/3/library/secrets.html#secrets.randbits "Link to this definition")
    
Return a non-negative int with _k_ random bits.
## Generating tokens[¶](https://docs.python.org/3/library/secrets.html#generating-tokens "Link to this heading")
The [`secrets`](https://docs.python.org/3/library/secrets.html#module-secrets "secrets: Generate secure random numbers for managing secrets.") module provides functions for generating secure tokens, suitable for applications such as password resets, hard-to-guess URLs, and similar. 

secrets.token_bytes([_nbytes=None_])[¶](https://docs.python.org/3/library/secrets.html#secrets.token_bytes "Link to this definition")
    
Return a random byte string containing _nbytes_ number of bytes. If _nbytes_ is `None` or not supplied, a reasonable default is used.
>>>```
>>> token_bytes(16)
b'\xebr\x17D*t\xae\xd4\xe3S\xb6\xe2\xebP1\x8b'

```


secrets.token_hex([_nbytes=None_])[¶](https://docs.python.org/3/library/secrets.html#secrets.token_hex "Link to this definition")
    
Return a random text string, in hexadecimal. The string has _nbytes_ random bytes, each byte converted to two hex digits. If _nbytes_ is `None` or not supplied, a reasonable default is used.
>>>```
>>> token_hex(16)
'f9bf78b9a18ce6d46a0cd2b0b86df9da'

```


secrets.token_urlsafe([_nbytes=None_])[¶](https://docs.python.org/3/library/secrets.html#secrets.token_urlsafe "Link to this definition")
    
Return a random URL-safe text string, containing _nbytes_ random bytes. The text is Base64 encoded, so on average each byte results in approximately 1.3 characters. If _nbytes_ is `None` or not supplied, a reasonable default is used.
>>>```
>>> token_urlsafe(16)
'Drmhze6EPcv0fN_81Bj-nA'

```

### How many bytes should tokens use?[¶](https://docs.python.org/3/library/secrets.html#how-many-bytes-should-tokens-use "Link to this heading")
To be secure against [brute-force attacks](https://en.wikipedia.org/wiki/Brute-force_attack), tokens need to have sufficient randomness. Unfortunately, what is considered sufficient will necessarily increase as computers get more powerful and able to make more guesses in a shorter period. As of 2015, it is believed that 32 bytes (256 bits) of randomness is sufficient for the typical use-case expected for the [`secrets`](https://docs.python.org/3/library/secrets.html#module-secrets "secrets: Generate secure random numbers for managing secrets.") module.
For those who want to manage their own token length, you can explicitly specify how much randomness is used for tokens by giving an [`int`](https://docs.python.org/3/library/functions.html#int "int") argument to the various `token_*` functions. That argument is taken as the number of bytes of randomness to use.
Otherwise, if no argument is provided, or if the argument is `None`, the `token_*` functions will use a reasonable default instead.
Note
That default is subject to change at any time, including during maintenance releases.
## Other functions[¶](https://docs.python.org/3/library/secrets.html#other-functions "Link to this heading") 

secrets.compare_digest(_a_ , _b_)[¶](https://docs.python.org/3/library/secrets.html#secrets.compare_digest "Link to this definition")
    
Return `True` if strings or [bytes-like objects](https://docs.python.org/3/glossary.html#term-bytes-like-object) _a_ and _b_ are equal, otherwise `False`, using a “constant-time compare” to reduce the risk of [timing attacks](https://codahale.com/a-lesson-in-timing-attacks/). See [`hmac.compare_digest()`](https://docs.python.org/3/library/hmac.html#hmac.compare_digest "hmac.compare_digest") for additional details.
## Recipes and best practices[¶](https://docs.python.org/3/library/secrets.html#recipes-and-best-practices "Link to this heading")
This section shows recipes and best practices for using [`secrets`](https://docs.python.org/3/library/secrets.html#module-secrets "secrets: Generate secure random numbers for managing secrets.") to manage a basic level of security.
Generate an eight-character alphanumeric password:
```
importstring
importsecrets
alphabet = string.ascii_letters + string.digits
password = ''.join(secrets.choice(alphabet) for i in range(8))

```

Note
Applications should not [**store passwords in a recoverable format**](https://cwe.mitre.org/data/definitions/257.html), whether plain text or encrypted. They should be salted and hashed using a cryptographically strong one-way (irreversible) hash function.
Generate a ten-character alphanumeric password with at least one lowercase character, at least one uppercase character, and at least three digits:
```
importstring
importsecrets
alphabet = string.ascii_letters + string.digits
while True:
  password = ''.join(secrets.choice(alphabet) for i in range(10))
  if (any(c.islower() for c in password)
      and any(c.isupper() for c in password)
      and sum(c.isdigit() for c in password) >= 3):
    break