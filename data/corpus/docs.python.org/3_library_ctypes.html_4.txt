Title: Using Pointer Types in ctypes
URL: https://docs.python.org/3/library/ctypes.html
Summary: Assigning a new value to pointer types like c_char_p, c_wchar_p, and c_void_p in ctypes changes the memory location they reference, not the content of the memory, due to the immutability of Python strings. Caution is advised when passing these pointers to functions expecting mutable memory.
---

```

Assigning a new value to instances of the pointer types [`c_char_p`](https://docs.python.org/3/library/ctypes.html#ctypes.c_char_p "ctypes.c_char_p"), [`c_wchar_p`](https://docs.python.org/3/library/ctypes.html#ctypes.c_wchar_p "ctypes.c_wchar_p"), and [`c_void_p`](https://docs.python.org/3/library/ctypes.html#ctypes.c_void_p "ctypes.c_void_p") changes the _memory location_ they point to, _not the contents_ of the memory block (of course not, because Python string objects are immutable):
>>>```
>>> s = "Hello, World"
>>> c_s = c_wchar_p(s)
>>> print(c_s)
c_wchar_p(139966785747344)
>>> print(c_s.value)
Hello World
>>> c_s.value = "Hi, there"
>>> print(c_s)       # the memory location has changed
c_wchar_p(139966783348904)
>>> print(c_s.value)
Hi, there
>>> print(s)        # first object is unchanged
Hello, World
>>>

```

You should be careful, however, not to pass them to functions expecting pointers to mutable memory. If you need mutable memory blocks, ctypes has a [`create_string_buffer()`](https://docs.python.org/3/library/ctypes.html#ctypes.create_string_buffer "ctypes.create_string_buffer") function which creates these in various ways. The current memory block contents can be accessed (or changed) with the `raw` property; if you want to access it as NUL terminated string, use the `value` property:
>>>```
>>> fromctypesimport *
>>> p = create_string_buffer(3)      # create a 3 byte buffer, initialized to NUL bytes
>>> print(sizeof(p), repr(p.raw))
3 b'\x00\x00\x00'
>>> p = create_string_buffer(b"Hello")   # create a buffer containing a NUL terminated string
>>> print(sizeof(p), repr(p.raw))
6 b'Hello\x00'
>>> print(repr(p.value))
b'Hello'
>>> p = create_string_buffer(b"Hello", 10) # create a 10 byte buffer
>>> print(sizeof(p), repr(p.raw))
10 b'Hello\x00\x00\x00\x00\x00'
>>> p.value = b"Hi"
>>> print(sizeof(p), repr(p.raw))
10 b'Hi\x00lo\x00\x00\x00\x00\x00'
>>>

```

The [`create_string_buffer()`](https://docs.python.org/3/library/ctypes.html#ctypes.create_string_buffer "ctypes.create_string_buffer") function replaces the old `c_buffer()` function (which is still available as an alias). To create a mutable memory block containing unicode characters of the C type `wchar_t`, use the [`create_unicode_buffer()`](https://docs.python.org/3/library/ctypes.html#ctypes.create_unicode_buffer "ctypes.create_unicode_buffer") function.
### Calling functions, continued[¶](https://docs.python.org/3/library/ctypes.html#calling-functions-continued "Link to this heading")
Note that printf prints to the real standard output channel, _not_ to [`sys.stdout`](https://docs.python.org/3/library/sys.html#sys.stdout "sys.stdout"), so these examples will only work at the console prompt, not from within _IDLE_ or _PythonWin_ :
>>>```
>>> printf = libc.printf
>>> printf(b"Hello, %s\n", b"World!")
Hello, World!
14
>>> printf(b"Hello, %S\n", "World!")
Hello, World!
14
>>> printf(b"%d bottles of beer\n", 42)
42 bottles of beer
19
>>> printf(b"%f bottles of beer\n", 42.5)
Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
ctypes.ArgumentError: argument 2: TypeError: Don't know how to convert parameter 2
>>>

```

As has been mentioned before, all Python types except integers, strings, and bytes objects have to be wrapped in their corresponding [`ctypes`](https://docs.python.org/3/library/ctypes.html#module-ctypes "ctypes: A foreign function library for Python.") type, so that they can be converted to the required C data type:
>>>```
>>> printf(b"An int %d, a double %f\n", 1234, c_double(3.14))
An int 1234, a double 3.140000
31
>>>

```

### Calling variadic functions[¶](https://docs.python.org/3/library/ctypes.html#calling-variadic-functions "Link to this heading")
On a lot of platforms calling variadic functions through ctypes is exactly the same as calling functions with a fixed number of parameters. On some platforms, and in particular ARM64 for Apple Platforms, the calling convention for variadic functions is different than that for regular functions.
On those platforms it is required to specify the [`argtypes`](https://docs.python.org/3/library/ctypes.html#ctypes._CFuncPtr.argtypes "ctypes._CFuncPtr.argtypes") attribute for the regular, non-variadic, function arguments:
```
libc.printf.argtypes = [ctypes.c_char_p]