Title: Handling Signals in Python with the signal Library
URL: https://docs.python.org/3/library/signal.html
Summary: This document discusses how to set up signal handlers in Python, including a sample implementation that raises an exception when a specified signal is received. It also highlights the behavior of SIGPIPE when output is piped to external tools and suggests a method to handle the resulting BrokenPipeError.
---

```
importsignal,os
defhandler(signum, frame):
  signame = signal.Signals(signum).name
  print(f'Signal handler called with signal {signame} ({signum})')
  raise OSError("Couldn't open device!")
# Set the signal handler and a 5-second alarm
signal.signal(signal.SIGALRM, handler)
signal.alarm(5)
# This open() may hang indefinitely
fd = os.open('/dev/ttyS0', os.O_RDWR)
signal.alarm(0)     # Disable the alarm

```

## Note on SIGPIPE[¶](https://docs.python.org/3/library/signal.html#note-on-sigpipe "Link to this heading")
Piping output of your program to tools like _[head(1)](https://manpages.debian.org/head\(1\))_ will cause a [`SIGPIPE`](https://docs.python.org/3/library/signal.html#signal.SIGPIPE "signal.SIGPIPE") signal to be sent to your process when the receiver of its standard output closes early. This results in an exception like `BrokenPipeError: [Errno 32] Broken pipe`. To handle this case, wrap your entry point to catch this exception as follows:
```
importos
importsys
defmain():
  try:
    # simulate large output (your code replaces this loop)
    for x in range(10000):
      print("y")
    # flush output here to force SIGPIPE to be triggered
    # while inside this try block.
    sys.stdout.flush()
  except BrokenPipeError:
    # Python flushes standard streams on exit; redirect remaining output
    # to devnull to avoid another BrokenPipeError at shutdown
    devnull = os.open(os.devnull, os.O_WRONLY)
    os.dup2(devnull, sys.stdout.fileno())
    sys.exit(1) # Python exits with error code 1 on EPIPE
if __name__ == '__main__':
  main()

```

Do not set [`SIGPIPE`](https://docs.python.org/3/library/signal.html#signal.SIGPIPE "signal.SIGPIPE")’s disposition to [`SIG_DFL`](https://docs.python.org/3/library/signal.html#signal.SIG_DFL "signal.SIG_DFL") in order to avoid [`BrokenPipeError`](https://docs.python.org/3/library/exceptions.html#BrokenPipeError "BrokenPipeError"). Doing that would cause your program to exit unexpectedly whenever any socket connection is interrupted while your program is still writing to it.
## Note on Signal Handlers and Exceptions[¶](https://docs.python.org/3/library/signal.html#note-on-signal-handlers-and-exceptions "Link to this heading")
If a signal handler raises an exception, the exception will be propagated to the main thread and may be raised after any [bytecode](https://docs.python.org/3/glossary.html#term-bytecode) instruction. Most notably, a [`KeyboardInterrupt`](https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt "KeyboardInterrupt") may appear at any point during execution. Most Python code, including the standard library, cannot be made robust against this, and so a [`KeyboardInterrupt`](https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt "KeyboardInterrupt") (or any other exception resulting from a signal handler) may on rare occasions put the program in an unexpected state.
To illustrate this issue, consider the following code:
```
classSpamContext:
  def__init__(self):
    self.lock = threading.Lock()
  def__enter__(self):
    # If KeyboardInterrupt occurs here, everything is fine
    self.lock.acquire()
    # If KeyboardInterrupt occurs here, __exit__ will not be called
    ...
    # KeyboardInterrupt could occur just before the function returns
  def__exit__(self, exc_type, exc_val, exc_tb):
    ...
    self.lock.release()

```

For many programs, especially those that merely want to exit on [`KeyboardInterrupt`](https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt "KeyboardInterrupt"), this is not a problem, but applications that are complex or require high reliability should avoid raising exceptions from signal handlers. They should also avoid catching [`KeyboardInterrupt`](https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt "KeyboardInterrupt") as a means of gracefully shutting down. Instead, they should install their own [`SIGINT`](https://docs.python.org/3/library/signal.html#signal.SIGINT "signal.SIGINT") handler. Below is an example of an HTTP server that avoids [`KeyboardInterrupt`](https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt "KeyboardInterrupt"):
```
importsignal
importsocket
fromselectorsimport DefaultSelector, EVENT_READ
fromhttp.serverimport HTTPServer, SimpleHTTPRequestHandler
interrupt_read, interrupt_write = socket.socketpair()
defhandler(signum, frame):
  print('Signal handler called with signal', signum)
  interrupt_write.send(b'\0')
signal.signal(signal.SIGINT, handler)
defserve_forever(httpd):
  sel = DefaultSelector()
  sel.register(interrupt_read, EVENT_READ)
  sel.register(httpd, EVENT_READ)
  while True:
    for key, _ in sel.select():
      if key.fileobj == interrupt_read:
        interrupt_read.recv(1)
        return
      if key.fileobj == httpd:
        httpd.handle_request()
print("Serving on port 8000")
httpd = HTTPServer(('', 8000), SimpleHTTPRequestHandler)
serve_forever(httpd)
print("Shutdown...")