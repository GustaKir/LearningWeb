Title: Using patch.multiple() in unittest.mock
URL: https://docs.python.org/3/library/unittest.mock.html
Summary: This section explains how to use the `patch.multiple()` function as a context manager in the Python `unittest.mock` library, emphasizing that it returns a dictionary of created mocks keyed by name. It also introduces the `start()` and `stop()` methods of patchers, which facilitate patching in setup methods or when multiple patches are required without nesting decorators.
---

```

If [`patch.multiple()`](https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch.multiple "unittest.mock.patch.multiple") is used as a context manager, the value returned by the context manager is a dictionary where created mocks are keyed by name:
>>>```
>>> with patch.multiple('__main__', thing=DEFAULT, other=DEFAULT) as values:
...   assert 'other' in repr(values['other'])
...   assert 'thing' in repr(values['thing'])
...   assert values['thing'] is thing
...   assert values['other'] is other
...

```

### patch methods: start and stop[¶](https://docs.python.org/3/library/unittest.mock.html#patch-methods-start-and-stop "Link to this heading")
All the patchers have `start()` and `stop()` methods. These make it simpler to do patching in `setUp` methods or where you want to do multiple patches without nesting decorators or with statements.
To use them call [`patch()`](https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch "unittest.mock.patch"), [`patch.object()`](https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch.object "unittest.mock.patch.object") or [`patch.dict()`](https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch.dict "unittest.mock.patch.dict") as normal and keep a reference to the returned `patcher` object. You can then call `start()` to put the patch in place and `stop()` to undo it.
If you are using [`patch()`](https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch "unittest.mock.patch") to create a mock for you then it will be returned by the call to `patcher.start`.
>>>```
>>> patcher = patch('package.module.ClassName')
>>> frompackageimport module
>>> original = module.ClassName
>>> new_mock = patcher.start()
>>> assert module.ClassName is not original
>>> assert module.ClassName is new_mock
>>> patcher.stop()
>>> assert module.ClassName is original
>>> assert module.ClassName is not new_mock

```

A typical use case for this might be for doing multiple patches in the `setUp` method of a [`TestCase`](https://docs.python.org/3/library/unittest.html#unittest.TestCase "unittest.TestCase"):
>>>```
>>> classMyTest(unittest.TestCase):
...   defsetUp(self):
...     self.patcher1 = patch('package.module.Class1')
...     self.patcher2 = patch('package.module.Class2')
...     self.MockClass1 = self.patcher1.start()
...     self.MockClass2 = self.patcher2.start()
...
...   deftearDown(self):
...     self.patcher1.stop()
...     self.patcher2.stop()
...
...   deftest_something(self):
...     assert package.module.Class1 is self.MockClass1
...     assert package.module.Class2 is self.MockClass2
...
>>> MyTest('test_something').run()

```

Caution
If you use this technique you must ensure that the patching is “undone” by calling `stop`. This can be fiddlier than you might think, because if an exception is raised in the `setUp` then `tearDown` is not called. [`unittest.TestCase.addCleanup()`](https://docs.python.org/3/library/unittest.html#unittest.TestCase.addCleanup "unittest.TestCase.addCleanup") makes this easier:
>>>```
>>> classMyTest(unittest.TestCase):
...   defsetUp(self):
...     patcher = patch('package.module.Class')
...     self.MockClass = patcher.start()
...     self.addCleanup(patcher.stop)
...
...   deftest_something(self):
...     assert package.module.Class is self.MockClass
...

```

As an added bonus you no longer need to keep a reference to the `patcher` object.
It is also possible to stop all patches which have been started by using [`patch.stopall()`](https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch.stopall "unittest.mock.patch.stopall"). 

patch.stopall()[¶](https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch.stopall "Link to this definition")
    
Stop all active patches. Only stops patches started with `start`.
### patch builtins[¶](https://docs.python.org/3/library/unittest.mock.html#patch-builtins "Link to this heading")
You can patch any builtins within a module. The following example patches builtin [`ord()`](https://docs.python.org/3/library/functions.html#ord "ord"):
>>>```
>>> @patch('__main__.ord')
... deftest(mock_ord):
...   mock_ord.return_value = 101
...   print(ord('c'))
...
>>> test()
101

```

### TEST_PREFIX[¶](https://docs.python.org/3/library/unittest.mock.html#test-prefix "Link to this heading")
All of the patchers can be used as class decorators. When used in this way they wrap every test method on the class. The patchers recognise methods that start with `'test'` as being test methods. This is the same way that the [`unittest.TestLoader`](https://docs.python.org/3/library/unittest.html#unittest.TestLoader "unittest.TestLoader") finds test methods by default.
It is possible that you want to use a different prefix for your tests. You can inform the patchers of the different prefix by setting `patch.TEST_PREFIX`:
>>>