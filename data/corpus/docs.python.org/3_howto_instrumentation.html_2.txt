Title: Instrumentation Logging in Python
URL: https://docs.python.org/3/howto/instrumentation.html
Summary: This document provides a detailed log of function entries and returns in a Python script, illustrating the flow of execution through various functions in 'call_stack.py'. It captures timestamps alongside function calls, showing how functions are entered and exited, which can be useful for debugging and performance monitoring.
---

```
156641360502280 function-entry:call_stack.py:start:23
156641360518804 function-entry: call_stack.py:function_1:1
156641360532797 function-entry: call_stack.py:function_3:9
156641360546807 function-return: call_stack.py:function_3:10
156641360563367 function-return: call_stack.py:function_1:2
156641360578365 function-entry: call_stack.py:function_2:5
156641360591757 function-entry: call_stack.py:function_1:1
156641360605556 function-entry:  call_stack.py:function_3:9
156641360617482 function-return:  call_stack.py:function_3:10
156641360629814 function-return: call_stack.py:function_1:2
156641360642285 function-return: call_stack.py:function_2:6
156641360656770 function-entry: call_stack.py:function_3:9
156641360669707 function-return: call_stack.py:function_3:10
156641360687853 function-entry: call_stack.py:function_4:13
156641360700719 function-return: call_stack.py:function_4:14
156641360719640 function-entry: call_stack.py:function_5:18
156641360732567 function-return: call_stack.py:function_5:21
156641360747370 function-return:call_stack.py:start:28

```

## Static SystemTap markers[¶](https://docs.python.org/3/howto/instrumentation.html#static-systemtap-markers "Link to this heading")
The low-level way to use the SystemTap integration is to use the static markers directly. This requires you to explicitly state the binary file containing them.
For example, this SystemTap script can be used to show the call/return hierarchy of a Python script:
```
probe process("python").mark("function__entry") {
   filename = user_string($arg1);
   funcname = user_string($arg2);
   lineno = $arg3;
   printf("%s => %s in %s:%d\\n",
      thread_indent(1), funcname, filename, lineno);
}
probe process("python").mark("function__return") {
  filename = user_string($arg1);
  funcname = user_string($arg2);
  lineno = $arg3;
  printf("%s <= %s in %s:%d\\n",
      thread_indent(-1), funcname, filename, lineno);
}

```

It can be invoked like this:
```
$ stap\
show-call-hierarchy.stp\
-c"./python test.py"

```

The output looks like this:
```
11408 python(8274):    => __contains__ in Lib/_abcoll.py:362
11414 python(8274):     => __getitem__ in Lib/os.py:425
11418 python(8274):     => encode in Lib/os.py:490
11424 python(8274):     <= encode in Lib/os.py:493
11428 python(8274):     <= __getitem__ in Lib/os.py:426
11433 python(8274):    <= __contains__ in Lib/_abcoll.py:366

```

where the columns are:
  * time in microseconds since start of script
  * name of executable
  * PID of process


and the remainder indicates the call/return hierarchy as the script executes.
For a [`--enable-shared`](https://docs.python.org/3/using/configure.html#cmdoption-enable-shared) build of CPython, the markers are contained within the libpython shared library, and the probe’s dotted path needs to reflect this. For example, this line from the above example:
```
probe process("python").mark("function__entry") {

```

should instead read:
```
probe process("python").library("libpython3.6dm.so.1.0").mark("function__entry") {