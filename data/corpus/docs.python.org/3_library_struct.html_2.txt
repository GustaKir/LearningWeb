Title: struct Module Functions Overview
URL: https://docs.python.org/3/library/struct.html
Summary: The `struct.iter_unpack` function allows for iteratively unpacking equal-sized chunks from a buffer according to a specified format string. The buffer must be a multiple of the format's size. Additionally, the `struct.calcsize` function returns the size in bytes of the struct corresponding to a given format string.
---

struct.iter_unpack(_format_ , _buffer_)[¶](https://docs.python.org/3/library/struct.html#struct.iter_unpack "Link to this definition")
    
Iteratively unpack from the buffer _buffer_ according to the format string _format_. This function returns an iterator which will read equally sized chunks from the buffer until all its contents have been consumed. The buffer’s size in bytes must be a multiple of the size required by the format, as reflected by [`calcsize()`](https://docs.python.org/3/library/struct.html#struct.calcsize "struct.calcsize").
Each iteration yields a tuple as specified by the format string.
Added in version 3.4. 

struct.calcsize(_format_)[¶](https://docs.python.org/3/library/struct.html#struct.calcsize "Link to this definition")
    
Return the size of the struct (and hence of the bytes object produced by `pack(format, ...)`) corresponding to the format string _format_.
## Format Strings[¶](https://docs.python.org/3/library/struct.html#format-strings "Link to this heading")
Format strings describe the data layout when packing and unpacking data. They are built up from [format characters](https://docs.python.org/3/library/struct.html#format-characters), which specify the type of data being packed/unpacked. In addition, special characters control the [byte order, size and alignment](https://docs.python.org/3/library/struct.html#struct-alignment). Each format string consists of an optional prefix character which describes the overall properties of the data and one or more format characters which describe the actual data values and padding.
### Byte Order, Size, and Alignment[¶](https://docs.python.org/3/library/struct.html#byte-order-size-and-alignment "Link to this heading")
By default, C types are represented in the machine’s native format and byte order, and properly aligned by skipping pad bytes if necessary (according to the rules used by the C compiler). This behavior is chosen so that the bytes of a packed struct correspond exactly to the memory layout of the corresponding C struct. Whether to use native byte ordering and padding or standard formats depends on the application.
Alternatively, the first character of the format string can be used to indicate the byte order, size and alignment of the packed data, according to the following table:
Character | Byte order | Size | Alignment  
---|---|---|---  
`@` | native | native | native  
`=` | native | standard | none  
`<` | little-endian | standard | none  
`>` | big-endian | standard | none  
`!` | network (= big-endian) | standard | none  
If the first character is not one of these, `'@'` is assumed.
Note
The number 1023 (`0x3ff` in hexadecimal) has the following byte representations:
  * `03 ff` in big-endian (`>`)
  * `ff 03` in little-endian (`<`)


Python example:
>>>```
>>> importstruct
>>> struct.pack('>h', 1023)
b'\x03\xff'
>>> struct.pack('<h', 1023)
b'\xff\x03'