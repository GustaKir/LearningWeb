Title: Memory Views in Python
URL: https://docs.python.org/3/library/stdtypes.html
Summary: This documentation chunk demonstrates the use of memory views in Python. It shows how to create a memory view from an array, including properties like length and number of bytes. It also illustrates multi-dimensional arrays through struct packing and casting, detailing the read-only nature and format of memory views.
---

```
>>> importarray
>>> a = array.array('i', [1,2,3,4,5])
>>> m = memoryview(a)
>>> len(m)
5
>>> m.nbytes
20
>>> y = m[::2]
>>> len(y)
3
>>> y.nbytes
12
>>> len(y.tobytes())
12

```

Multi-dimensional arrays:
>>>```
>>> importstruct
>>> buf = struct.pack("d"*12, *[1.5*x for x in range(12)])
>>> x = memoryview(buf)
>>> y = x.cast('d', shape=[3,4])
>>> y.tolist()
[[0.0, 1.5, 3.0, 4.5], [6.0, 7.5, 9.0, 10.5], [12.0, 13.5, 15.0, 16.5]]
>>> len(y)
3
>>> y.nbytes
96

```

Added in version 3.3. 

readonly[¶](https://docs.python.org/3/library/stdtypes.html#memoryview.readonly "Link to this definition")
    
A bool indicating whether the memory is read only. 

format[¶](https://docs.python.org/3/library/stdtypes.html#memoryview.format "Link to this definition")
    
A string containing the format (in [`struct`](https://docs.python.org/3/library/struct.html#module-struct "struct: Interpret bytes as packed binary data.") module style) for each element in the view. A memoryview can be created from exporters with arbitrary format strings, but some methods (e.g. [`tolist()`](https://docs.python.org/3/library/stdtypes.html#memoryview.tolist "memoryview.tolist")) are restricted to native single element formats.
Changed in version 3.3: format `'B'` is now handled according to the struct module syntax. This means that `memoryview(b'abc')[0] == b'abc'[0] == 97`. 

itemsize[¶](https://docs.python.org/3/library/stdtypes.html#memoryview.itemsize "Link to this definition")
    
The size in bytes of each element of the memoryview:
>>>```
>>> importarray,struct
>>> m = memoryview(array.array('H', [32000, 32001, 32002]))
>>> m.itemsize
2
>>> m[0]
32000
>>> struct.calcsize('H') == m.itemsize
True