Title: Maintaining Fixed Point Invariance with Decimal Operations
URL: https://docs.python.org/3/library/decimal.html
Summary: To preserve fixed point with Decimal objects in Python, some operations like addition, subtraction, and integer multiplication maintain the number of decimal places automatically. However, division and non-integer multiplication may alter the decimal places, requiring a follow-up `quantize()` step to restore the specified precision. Examples illustrate how to perform these operations while maintaining a two-decimal-place format.
---

```
>>> Decimal('3.214').quantize(TWOPLACES, context=Context(traps=[Inexact]))
Traceback (most recent call last):
...
Inexact: None

```

Q. Once I have valid two place inputs, how do I maintain that invariant throughout an application?
A. Some operations like addition, subtraction, and multiplication by an integer will automatically preserve fixed point. Others operations, like division and non-integer multiplication, will change the number of decimal places and need to be followed-up with a [`quantize()`](https://docs.python.org/3/library/decimal.html#decimal.Decimal.quantize "decimal.Decimal.quantize") step:
>>>```
>>> a = Decimal('102.72')      # Initial fixed-point values
>>> b = Decimal('3.17')
>>> a + b              # Addition preserves fixed-point
Decimal('105.89')
>>> a - b
Decimal('99.55')
>>> a * 42             # So does integer multiplication
Decimal('4314.24')
>>> (a * b).quantize(TWOPLACES)   # Must quantize non-integer multiplication
Decimal('325.62')
>>> (b / a).quantize(TWOPLACES)   # And quantize division
Decimal('0.03')

```

In developing fixed-point applications, it is convenient to define functions to handle the [`quantize()`](https://docs.python.org/3/library/decimal.html#decimal.Decimal.quantize "decimal.Decimal.quantize") step:
>>>```
>>> defmul(x, y, fp=TWOPLACES):
...   return (x * y).quantize(fp)
...
>>> defdiv(x, y, fp=TWOPLACES):
...   return (x / y).quantize(fp)

```

>>>```
>>> mul(a, b)            # Automatically preserve fixed-point
Decimal('325.62')
>>> div(b, a)
Decimal('0.03')

```

Q. There are many ways to express the same value. The numbers `200`, `200.000`, `2E2`, and `.02E+4` all have the same value at various precisions. Is there a way to transform them to a single recognizable canonical value?
A. The [`normalize()`](https://docs.python.org/3/library/decimal.html#decimal.Decimal.normalize "decimal.Decimal.normalize") method maps all equivalent values to a single representative:
>>>```
>>> values = map(Decimal, '200 200.000 2E2 .02E+4'.split())
>>> [v.normalize() for v in values]
[Decimal('2E+2'), Decimal('2E+2'), Decimal('2E+2'), Decimal('2E+2')]

```

Q. When does rounding occur in a computation?
A. It occurs _after_ the computation. The philosophy of the decimal specification is that numbers are considered exact and are created independent of the current context. They can even have greater precision than current context. Computations process with those exact inputs and then rounding (or other context operations) is applied to the _result_ of the computation:
>>>```
>>> getcontext().prec = 5
>>> pi = Decimal('3.1415926535')  # More than 5 digits
>>> pi               # All digits are retained
Decimal('3.1415926535')
>>> pi + 0             # Rounded after an addition
Decimal('3.1416')
>>> pi - Decimal('0.00005')    # Subtract unrounded numbers, then round
Decimal('3.1415')
>>> pi + 0 - Decimal('0.00005').  # Intermediate values are rounded
Decimal('3.1416')

```

Q. Some decimal values always print with exponential notation. Is there a way to get a non-exponential representation?
A. For some values, exponential notation is the only way to express the number of significant places in the coefficient. For example, expressing `5.0E+3` as `5000` keeps the value constant but cannot show the originalâ€™s two-place significance.
If an application does not care about tracking significance, it is easy to remove the exponent and trailing zeroes, losing significance, but keeping the value unchanged:
>>>```
>>> defremove_exponent(d):
...   return d.quantize(Decimal(1)) if d == d.to_integral() else d.normalize()

```

>>>```
>>> remove_exponent(Decimal('5E+3'))
Decimal('5000')

```

Q. Is there a way to convert a regular float to a [`Decimal`](https://docs.python.org/3/library/decimal.html#decimal.Decimal "decimal.Decimal")?
A. Yes, any binary floating-point number can be exactly expressed as a Decimal though an exact conversion may take more precision than intuition would suggest:
>>>```
>>> Decimal(math.pi)
Decimal('3.141592653589793115997963468544185161590576171875')