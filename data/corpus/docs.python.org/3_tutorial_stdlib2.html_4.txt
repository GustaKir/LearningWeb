Title: Using bisect and heapq Modules in Python
URL: https://docs.python.org/3/tutorial/stdlib2.html
Summary: This section demonstrates how to use the bisect module to insert an element into a sorted list while maintaining order and showcases the heapq module for implementing heaps, allowing access to the smallest elements efficiently without full sorting.
---

```
>>> importbisect
>>> scores = [(100, 'perl'), (200, 'tcl'), (400, 'lua'), (500, 'python')]
>>> bisect.insort(scores, (300, 'ruby'))
>>> scores
[(100, 'perl'), (200, 'tcl'), (300, 'ruby'), (400, 'lua'), (500, 'python')]

```

The [`heapq`](https://docs.python.org/3/library/heapq.html#module-heapq "heapq: Heap queue algorithm \(a.k.a. priority queue\).") module provides functions for implementing heaps based on regular lists. The lowest valued entry is always kept at position zero. This is useful for applications which repeatedly access the smallest element but do not want to run a full list sort:
>>>```
>>> fromheapqimport heapify, heappop, heappush
>>> data = [1, 3, 5, 7, 9, 2, 4, 6, 8, 0]
>>> heapify(data)           # rearrange the list into heap order
>>> heappush(data, -5)         # add a new entry
>>> [heappop(data) for i in range(3)] # fetch the three smallest entries
[-5, 0, 1]

```

## 11.8. Decimal Floating-Point Arithmetic[Â¶](https://docs.python.org/3/tutorial/stdlib2.html#decimal-floating-point-arithmetic "Link to this heading")
The [`decimal`](https://docs.python.org/3/library/decimal.html#module-decimal "decimal: Implementation of the General Decimal Arithmetic Specification.") module offers a [`Decimal`](https://docs.python.org/3/library/decimal.html#decimal.Decimal "decimal.Decimal") datatype for decimal floating-point arithmetic. Compared to the built-in [`float`](https://docs.python.org/3/library/functions.html#float "float") implementation of binary floating point, the class is especially helpful for
  * financial applications and other uses which require exact decimal representation,
  * control over precision,
  * control over rounding to meet legal or regulatory requirements,
  * tracking of significant decimal places, or
  * applications where the user expects the results to match calculations done by hand.


For example, calculating a 5% tax on a 70 cent phone charge gives different results in decimal floating point and binary floating point. The difference becomes significant if the results are rounded to the nearest cent:
>>>```
>>> fromdecimalimport *
>>> round(Decimal('0.70') * Decimal('1.05'), 2)
Decimal('0.74')
>>> round(.70 * 1.05, 2)
0.73

```

The [`Decimal`](https://docs.python.org/3/library/decimal.html#decimal.Decimal "decimal.Decimal") result keeps a trailing zero, automatically inferring four place significance from multiplicands with two place significance. Decimal reproduces mathematics as done by hand and avoids issues that can arise when binary floating point cannot exactly represent decimal quantities.
Exact representation enables the [`Decimal`](https://docs.python.org/3/library/decimal.html#decimal.Decimal "decimal.Decimal") class to perform modulo calculations and equality tests that are unsuitable for binary floating point:
>>>```
>>> Decimal('1.00') % Decimal('.10')
Decimal('0.00')
>>> 1.00 % 0.10
0.09999999999999995
>>> sum([Decimal('0.1')]*10) == Decimal('1.0')
True
>>> 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 == 1.0
False

```

The [`decimal`](https://docs.python.org/3/library/decimal.html#module-decimal "decimal: Implementation of the General Decimal Arithmetic Specification.") module provides arithmetic with as much precision as needed:
>>>```
>>> getcontext().prec = 36
>>> Decimal(1) / Decimal(7)
Decimal('0.142857142857142857142857142857142857')