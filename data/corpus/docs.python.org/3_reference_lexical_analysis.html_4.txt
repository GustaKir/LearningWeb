Title: Soft Keywords in Python
URL: https://docs.python.org/3/reference/lexical_analysis.html
Summary: Introduced in Python 3.10, soft keywords are identifiers like 'match', 'case', 'type', and '_' that act as keywords in specific contexts, allowing existing code to remain compatible. Changes in version 3.12 include 'type' being recognized as a soft keyword.
---

```

### 2.3.2. Soft Keywords[¶](https://docs.python.org/3/reference/lexical_analysis.html#soft-keywords "Link to this heading")
Added in version 3.10.
Some identifiers are only reserved under specific contexts. These are known as _soft keywords_. The identifiers `match`, `case`, `type` and `_` can syntactically act as keywords in certain contexts, but this distinction is done at the parser level, not when tokenizing.
As soft keywords, their use in the grammar is possible while still preserving compatibility with existing code that uses these names as identifier names.
`match`, `case`, and `_` are used in the [`match`](https://docs.python.org/3/reference/compound_stmts.html#match) statement. `type` is used in the [`type`](https://docs.python.org/3/reference/simple_stmts.html#type) statement.
Changed in version 3.12: `type` is now a soft keyword.
### 2.3.3. Reserved classes of identifiers[¶](https://docs.python.org/3/reference/lexical_analysis.html#reserved-classes-of-identifiers "Link to this heading")
Certain classes of identifiers (besides keywords) have special meanings. These classes are identified by the patterns of leading and trailing underscore characters: 

`_*`
    
Not imported by `from module import *`. 

`_`
    
In a `case` pattern within a [`match`](https://docs.python.org/3/reference/compound_stmts.html#match) statement, `_` is a [soft keyword](https://docs.python.org/3/reference/lexical_analysis.html#soft-keywords) that denotes a [wildcard](https://docs.python.org/3/reference/compound_stmts.html#wildcard-patterns).
Separately, the interactive interpreter makes the result of the last evaluation available in the variable `_`. (It is stored in the [`builtins`](https://docs.python.org/3/library/builtins.html#module-builtins "builtins: The module that provides the built-in namespace.") module, alongside built-in functions like `print`.)
Elsewhere, `_` is a regular identifier. It is often used to name “special” items, but it is not special to Python itself.
Note
The name `_` is often used in conjunction with internationalization; refer to the documentation for the [`gettext`](https://docs.python.org/3/library/gettext.html#module-gettext "gettext: Multilingual internationalization services.") module for more information on this convention.
It is also commonly used for unused variables. 

`__*__`
    
System-defined names, informally known as “dunder” names. These names are defined by the interpreter and its implementation (including the standard library). Current system names are discussed in the [Special method names](https://docs.python.org/3/reference/datamodel.html#specialnames) section and elsewhere. More will likely be defined in future versions of Python. _Any_ use of `__*__` names, in any context, that does not follow explicitly documented use, is subject to breakage without warning. 

`__*`
    
Class-private names. Names in this category, when used within the context of a class definition, are re-written to use a mangled form to help avoid name clashes between “private” attributes of base and derived classes. See section [Identifiers (Names)](https://docs.python.org/3/reference/expressions.html#atom-identifiers).
## 2.4. Literals[¶](https://docs.python.org/3/reference/lexical_analysis.html#literals "Link to this heading")
Literals are notations for constant values of some built-in types.
### 2.4.1. String and Bytes literals[¶](https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals "Link to this heading")
String literals are described by the following lexical definitions: