Title: Translating Python Arguments to C Functions
URL: https://docs.python.org/3/extending/extending.html
Summary: This section explains how Python function arguments are translated into C function parameters, detailing the use of the _self_ and _args_ arguments. It discusses the conversion of Python tuple arguments to C values with the help of the `PyArg_ParseTuple()` function, which verifies argument types and stores them in C variables.
---

```

There is a straightforward translation from the argument list in Python (for example, the single expression `"ls -l"`) to the arguments passed to the C function. The C function always has two arguments, conventionally named _self_ and _args_.
The _self_ argument points to the module object for module-level functions; for a method it would point to the object instance.
The _args_ argument will be a pointer to a Python tuple object containing the arguments. Each item of the tuple corresponds to an argument in the call’s argument list. The arguments are Python objects — in order to do anything with them in our C function we have to convert them to C values. The function [`PyArg_ParseTuple()`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple "PyArg_ParseTuple") in the Python API checks the argument types and converts them to C values. It uses a template string to determine the required types of the arguments as well as the types of the C variables into which to store the converted values. More about this later.
[`PyArg_ParseTuple()`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple "PyArg_ParseTuple") returns true (nonzero) if all arguments have the right type and its components have been stored in the variables whose addresses are passed. It returns false (zero) if an invalid argument list was passed. In the latter case it also raises an appropriate exception so the calling function can return `NULL` immediately (as we saw in the example).
## 1.2. Intermezzo: Errors and Exceptions[¶](https://docs.python.org/3/extending/extending.html#intermezzo-errors-and-exceptions "Link to this heading")
An important convention throughout the Python interpreter is the following: when a function fails, it should set an exception condition and return an error value (usually `-1` or a `NULL` pointer). Exception information is stored in three members of the interpreter’s thread state. These are `NULL` if there is no exception. Otherwise they are the C equivalents of the members of the Python tuple returned by [`sys.exc_info()`](https://docs.python.org/3/library/sys.html#sys.exc_info "sys.exc_info"). These are the exception type, exception instance, and a traceback object. It is important to know about them to understand how errors are passed around.
The Python API defines a number of functions to set various types of exceptions.
The most common one is [`PyErr_SetString()`](https://docs.python.org/3/c-api/exceptions.html#c.PyErr_SetString "PyErr_SetString"). Its arguments are an exception object and a C string. The exception object is usually a predefined object like `PyExc_ZeroDivisionError`. The C string indicates the cause of the error and is converted to a Python string object and stored as the “associated value” of the exception.
Another useful function is [`PyErr_SetFromErrno()`](https://docs.python.org/3/c-api/exceptions.html#c.PyErr_SetFromErrno "PyErr_SetFromErrno"), which only takes an exception argument and constructs the associated value by inspection of the global variable `errno`. The most general function is [`PyErr_SetObject()`](https://docs.python.org/3/c-api/exceptions.html#c.PyErr_SetObject "PyErr_SetObject"), which takes two object arguments, the exception and its associated value. You don’t need to [`Py_INCREF()`](https://docs.python.org/3/c-api/refcounting.html#c.Py_INCREF "Py_INCREF") the objects passed to any of these functions.
You can test non-destructively whether an exception has been set with [`PyErr_Occurred()`](https://docs.python.org/3/c-api/exceptions.html#c.PyErr_Occurred "PyErr_Occurred"). This returns the current exception object, or `NULL` if no exception has occurred. You normally don’t need to call [`PyErr_Occurred()`](https://docs.python.org/3/c-api/exceptions.html#c.PyErr_Occurred "PyErr_Occurred") to see whether an error occurred in a function call, since you should be able to tell from the return value.
When a function _f_ that calls another function _g_ detects that the latter fails, _f_ should itself return an error value (usually `NULL` or `-1`). It should _not_ call one of the `PyErr_*` functions — one has already been called by _g_. _f_ ’s caller is then supposed to also return an error indication to _its_ caller, again _without_ calling `PyErr_*`, and so on — the most detailed cause of the error was already reported by the function that first detected it. Once the error reaches the Python interpreter’s main loop, this aborts the currently executing Python code and tries to find an exception handler specified by the Python programmer.
(There are situations where a module can actually give a more detailed error message by calling another `PyErr_*` function, and in such cases it is fine to do so. As a general rule, however, this is not necessary, and can cause information about the cause of the error to be lost: most operations can fail for a variety of reasons.)
To ignore an exception set by a function call that failed, the exception condition must be clear