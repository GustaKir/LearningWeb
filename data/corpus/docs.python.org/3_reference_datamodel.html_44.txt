Title: Reflected Binary Arithmetic Operations in Python
URL: https://docs.python.org/3/reference/datamodel.html
Summary: This section discusses the `__ror__` special method, used for implementing binary arithmetic operations with reflected operands when the left operand does not support the operation and the operands are of different types.
---

object.__ror__(_self_ , _other_)[¶](https://docs.python.org/3/reference/datamodel.html#object.__ror__ "Link to this definition")
    
These methods are called to implement the binary arithmetic operations (`+`, `-`, `*`, `@`, `/`, `//`, `%`, [`divmod()`](https://docs.python.org/3/library/functions.html#divmod "divmod"), [`pow()`](https://docs.python.org/3/library/functions.html#pow "pow"), `**`, `<<`, `>>`, `&`, `^`, `|`) with reflected (swapped) operands. These functions are only called if the left operand does not support the corresponding operation [[3]](https://docs.python.org/3/reference/datamodel.html#id21) and the operands are of different types. [[4]](https://docs.python.org/3/reference/datamodel.html#id22) For instance, to evaluate the expression `x - y`, where _y_ is an instance of a class that has an [`__rsub__()`](https://docs.python.org/3/reference/datamodel.html#object.__rsub__ "object.__rsub__") method, `type(y).__rsub__(y, x)` is called if `type(x).__sub__(x, y)` returns [`NotImplemented`](https://docs.python.org/3/library/constants.html#NotImplemented "NotImplemented").
Note that ternary [`pow()`](https://docs.python.org/3/library/functions.html#pow "pow") will not try calling [`__rpow__()`](https://docs.python.org/3/reference/datamodel.html#object.__rpow__ "object.__rpow__") (the coercion rules would become too complicated).
Note
If the right operand’s type is a subclass of the left operand’s type and that subclass provides a different implementation of the reflected method for the operation, this method will be called before the left operand’s non-reflected method. This behavior allows subclasses to override their ancestors’ operations. 

object.__iadd__(_self_ , _other_)[¶](https://docs.python.org/3/reference/datamodel.html#object.__iadd__ "Link to this definition")


object.__isub__(_self_ , _other_)[¶](https://docs.python.org/3/reference/datamodel.html#object.__isub__ "Link to this definition")


object.__imul__(_self_ , _other_)[¶](https://docs.python.org/3/reference/datamodel.html#object.__imul__ "Link to this definition")


object.__imatmul__(_self_ , _other_)[¶](https://docs.python.org/3/reference/datamodel.html#object.__imatmul__ "Link to this definition")


object.__itruediv__(_self_ , _other_)[¶](https://docs.python.org/3/reference/datamodel.html#object.__itruediv__ "Link to this definition")


object.__ifloordiv__(_self_ , _other_)[¶](https://docs.python.org/3/reference/datamodel.html#object.__ifloordiv__ "Link to this definition")


object.__imod__(_self_ , _other_)[¶](https://docs.python.org/3/reference/datamodel.html#object.__imod__ "Link to this definition")


object.__ipow__(_self_ , _other_[, _modulo_])[¶](https://docs.python.org/3/reference/datamodel.html#object.__ipow__ "Link to this definition")


object.__ilshift__(_self_ , _other_)[¶](https://docs.python.org/3/reference/datamodel.html#object.__ilshift__ "Link to this definition")


object.__irshift__(_self_ , _other_)[¶](https://docs.python.org/3/reference/datamodel.html#object.__irshift__ "Link to this definition")


object.__iand__(_self_ , _other_)[¶](https://docs.python.org/3/reference/datamodel.html#object.__iand__ "Link to this definition")


object.__ixor__(_self_ , _other_)[¶](https://docs.python.org/3/reference/datamodel.html#object.__ixor__ "Link to this definition")


object.__ior__(_self_ , _other_)[¶](https://docs.python.org/3/reference/datamodel.html#object.__ior__ "Link to this definition")
    
These methods are called to implement the augmented arithmetic assignments (`+=`, `-=`, `*=`, `@=`, `/=`, `//=`, `%=`, `**=`, `<<=`, `>>=`, `&=`, `^=`, `|=`). These methods should attempt to do the operation in-place (modifying _self_) and return the result (which could be, but does not have to be, _self_). If a specific method is not defined, or if that method returns [`NotImplemented`](https://docs.python.org/3/library/constants.html#NotImplemented "NotImplemented"), the augmented assignment falls back to the normal methods. For instance, if _x_ is an instance of a class with an [`__iadd__()`](https://docs.python.org/3/reference/datamodel.html#object.__iadd__ "object.__iadd__") method, `x += y` is equivalent to `x = x.__iadd__(y)` . If [`__iadd__()`](https://docs.python.org/3/reference/datamodel.html#object.__iadd__ "object.__iadd__") does not exist, or if `x.__iadd__(y)` returns `NotImplemented`, `x.__add__(y)` and `y.__radd__(x)` are considered, as with the evaluation of `x + y`. In certain situations, augmented assignment can result in unexpected errors (see [Why does a_tuple[i] += [‘item’] raise an exception when the addition works?](https://docs.python.org/3/faq/programming.html#faq-augmented-assignment-tuple-error)), but this behavior is in fact part of the data model. 

object.__neg__(_self_)[¶](https://docs.python.org/3/reference/datamodel.html#object.__neg__ "Link to this definition")