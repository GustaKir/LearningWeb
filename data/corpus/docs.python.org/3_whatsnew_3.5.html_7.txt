Title: PEP 475 - Automatic Retry of System Calls on EINTR
URL: https://docs.python.org/3/whatsnew/3.5.html
Summary: PEP 475 introduces automatic retries for system calls interrupted by EINTR, relieving user code of handling InterruptedError in most scenarios. This enhancement improves the robustness of Python programs, including the standard library. The systems calls affected include open(), io.open(), faulthandler functions, and various os module functions.
---

```

[**PEP 475**](https://peps.python.org/pep-0475/) implements automatic retry of system calls on `EINTR`. This removes the burden of dealing with `EINTR` or [`InterruptedError`](https://docs.python.org/3/library/exceptions.html#InterruptedError "InterruptedError") in user code in most situations and makes Python programs, including the standard library, more robust. Note that the system call is only retried if the signal handler does not raise an exception.
Below is a list of functions which are now retried when interrupted by a signal:
  * [`open()`](https://docs.python.org/3/library/functions.html#open "open") and [`io.open()`](https://docs.python.org/3/library/io.html#io.open "io.open");
  * functions of the [`faulthandler`](https://docs.python.org/3/library/faulthandler.html#module-faulthandler "faulthandler: Dump the Python traceback.") module;
  * [`os`](https://docs.python.org/3/library/os.html#module-os "os: Miscellaneous operating system interfaces.") functions: [`fchdir()`](https://docs.python.org/3/library/os.html#os.fchdir "os.fchdir"), [`fchmod()`](https://docs.python.org/3/library/os.html#os.fchmod "os.fchmod"), [`fchown()`](https://docs.python.org/3/library/os.html#os.fchown "os.fchown"), [`fdatasync()`](https://docs.python.org/3/library/os.html#os.fdatasync "os.fdatasync"), [`fstat()`](https://docs.python.org/3/library/os.html#os.fstat "os.fstat"), [`fstatvfs()`](https://docs.python.org/3/library/os.html#os.fstatvfs "os.fstatvfs"), [`fsync()`](https://docs.python.org/3/library/os.html#os.fsync "os.fsync"), [`ftruncate()`](https://docs.python.org/3/library/os.html#os.ftruncate "os.ftruncate"), [`mkfifo()`](https://docs.python.org/3/library/os.html#os.mkfifo "os.mkfifo"), [`mknod()`](https://docs.python.org/3/library/os.html#os.mknod "os.mknod"), [`open()`](https://docs.python.org/3/library/os.html#os.open "os.open"), [`posix_fadvise()`](https://docs.python.org/3/library/os.html#os.posix_fadvise "os.posix_fadvise"), [`posix_fallocate()`](https://docs.python.org/3/library/os.html#os.posix_fallocate "os.posix_fallocate"), [`pread()`](https://docs.python.org/3/library/os.html#os.pread "os.pread"), [`pwrite()`](https://docs.python.org/3/library/os.html#os.pwrite "os.pwrite"), [`read()`](https://docs.python.org/3/library/os.html#os.read "os.read"), [`readv()`](https://docs.python.org/3/library/os.html#os.readv "os.readv"), [`sendfile()`](https://docs.python.org/3/library/os.html#os.sendfile "os.sendfile"), [`wait3()`](https://docs.python.org/3/library/os.html#os.wait3 "os.wait3"), [`wait4()`](https://docs.python.org/3/library/os.html#os.wait4 "os.wait4"), [`wait()`](https://docs.python.org/3/library/os.html#os.wait "os.wait"), [`waitid()`](https://docs.python.org/3/library/os.html#os.waitid "os.waitid"), [`waitpid()`](https://docs.python.org/3/library/os.html#os.waitpid "os.waitpid"), [`write()`](https://docs.python.org/3/library/os.html#os.write "os.write"), [`writev()`](https://docs.python.org/3/library/os.html#os.writev "os.writev");
  * special cases: [`os.close()`](https://docs.python.org/3/library/os.html#os.close "os.close") and [`os.dup2()`](https://docs.python.org/3/library/os.html#os.dup2 "os.dup2") now ignore [`EINTR`](https://docs.python.org/3/library/errno.html#errno.EINTR "errno.EINTR") errors; the syscall is not retried (see the PEP for the rationale);
  * [`select`](https://docs.python.org/3/library/select.html#module-select "select: Wait for I/O completion on multiple streams.") functions: [`devpoll.poll()`](https://docs.python.org/3/library/select.html#select.devpoll.poll "select.devpoll.poll"), [`epoll.poll()`](https://docs.python.org/3/library/select.html#select.epoll.poll "select.epoll.poll"), [`kqueue.control()`](https://docs.python.org/3/library/select.html#select.kqueue.control "select.kqueue.control"), [`poll.poll()`](https://docs.python.org/3/library/select.html#select.poll.poll "select.poll.poll"), [`select()`](https://docs.python.org/3/library/select.html#select.select "select.select");
  * methods of the [`socket`](https://docs.python.org/3/library/socket.html#socket.socket "socket.socket") class: [`accept()`](https://docs.python.org/3/library/socket.html#socket.socket.accept "socket.socket.accept"), [`connect()`](https://docs.python.org/3/library/socket.html#socket.socket.connect "socket.socket.connect") (except for non-blocking sockets), [`recv()`](https://docs.python.org/3/library/socket.html#socket.socket.recv "socket.socket.recv"), [`recvfrom()`](https://docs.python.org/3/library/socket.html#socket.socket.recvfrom "socket.socket.recvfrom"), [`recvmsg()`](https://docs.python.org/3/library/socket.html#socket.socket.recvmsg "socket.socket.recvmsg"), [`send()`](https://docs.python.org/3/library/socket.html#socket.socket.send "socket.socket.send"), [`sendall()`](https://docs.python.org/3/library/socket.html#socket.socket.sendall "socket.socket.sendall"), [`sendmsg()`](https://docs.python.org/3/library/socket.html#socket.socket.sendmsg "socket.socket.sendmsg"), [`send