Title: Hashing of Numeric Types in Python
URL: https://docs.python.org/3/library/stdtypes.html
Summary: In Python, the `hash()` function for numeric types ensures that `hash(x) == hash(y)` whenever `x == y`, regardless of the numeric types of `x` and `y`. This is achieved through a unified hashing approach based on a single mathematical function applicable to all rational numbers.
---

```

### Hashing of numeric types[¶](https://docs.python.org/3/library/stdtypes.html#hashing-of-numeric-types "Link to this heading")
For numbers `x` and `y`, possibly of different types, it’s a requirement that `hash(x) == hash(y)` whenever `x == y` (see the [`__hash__()`](https://docs.python.org/3/reference/datamodel.html#object.__hash__ "object.__hash__") method documentation for more details). For ease of implementation and efficiency across a variety of numeric types (including [`int`](https://docs.python.org/3/library/functions.html#int "int"), [`float`](https://docs.python.org/3/library/functions.html#float "float"), [`decimal.Decimal`](https://docs.python.org/3/library/decimal.html#decimal.Decimal "decimal.Decimal") and [`fractions.Fraction`](https://docs.python.org/3/library/fractions.html#fractions.Fraction "fractions.Fraction")) Python’s hash for numeric types is based on a single mathematical function that’s defined for any rational number, and hence applies to all instances of [`int`](https://docs.python.org/3/library/functions.html#int "int") and [`fractions.Fraction`](https://docs.python.org/3/library/fractions.html#fractions.Fraction "fractions.Fraction"), and all finite instances of [`float`](https://docs.python.org/3/library/functions.html#float "float") and [`decimal.Decimal`](https://docs.python.org/3/library/decimal.html#decimal.Decimal "decimal.Decimal"). Essentially, this function is given by reduction modulo `P` for a fixed prime `P`. The value of `P` is made available to Python as the [`modulus`](https://docs.python.org/3/library/sys.html#sys.hash_info.modulus "sys.hash_info.modulus") attribute of [`sys.hash_info`](https://docs.python.org/3/library/sys.html#sys.hash_info "sys.hash_info").
**CPython implementation detail:** Currently, the prime used is `P = 2**31 - 1` on machines with 32-bit C longs and `P = 2**61 - 1` on machines with 64-bit C longs.
Here are the rules in detail:
  * If `x = m / n` is a nonnegative rational number and `n` is not divisible by `P`, define `hash(x)` as `m * invmod(n, P) % P`, where `invmod(n, P)` gives the inverse of `n` modulo `P`.
  * If `x = m / n` is a nonnegative rational number and `n` is divisible by `P` (but `m` is not) then `n` has no inverse modulo `P` and the rule above doesn’t apply; in this case define `hash(x)` to be the constant value `sys.hash_info.inf`.
  * If `x = m / n` is a negative rational number define `hash(x)` as `-hash(-x)`. If the resulting hash is `-1`, replace it with `-2`.
  * The particular values `sys.hash_info.inf` and `-sys.hash_info.inf` are used as hash values for positive infinity or negative infinity (respectively).
  * For a [`complex`](https://docs.python.org/3/library/functions.html#complex "complex") number `z`, the hash values of the real and imaginary parts are combined by computing `hash(z.real) + sys.hash_info.imag * hash(z.imag)`, reduced modulo `2**sys.hash_info.width` so that it lies in `range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - 1))`. Again, if the result is `-1`, it’s replaced with `-2`.


To clarify the above rules, here’s some example Python code, equivalent to the built-in hash, for computing the hash of a rational number, [`float`](https://docs.python.org/3/library/functions.html#float "float"), or [`complex`](https://docs.python.org/3/library/functions.html#complex "complex"):
```
importsys,math
defhash_fraction(m, n):
"""Compute the hash of a rational number m / n.
  Assumes m and n are integers, with n positive.
  Equivalent to hash(fractions.Fraction(m, n)).
  """
  P = sys.hash_info.modulus
  # Remove common factors of P. (Unnecessary if m and n already coprime.)
  while m % P == n % P == 0:
    m, n = m // P, n // P
  if n % P == 0:
    hash_value = sys.hash_info.inf
  else:
    # Fermat's Little Theorem: pow(n, P-1, P) is 1, so
    # pow(n, P-2, P) gives the inverse of n modulo P.
    hash_value = (abs(m) % P) * pow(n, P - 2, P) % P
  if m < 0:
    hash_value = -hash_value
  if hash_value == -1:
    hash_value = -2
  return hash_value
defhash_float(x):
"""Compute the hash of a float x."""
  if math.isnan(x):
    return object.__hash__(x)
  elif math.isinf(x):
    return sys.hash_info.inf if x > 0 else -sys.hash_info.inf
  else:
    return hash_fraction(*x.as_integer_ratio())
defhash_complex(z):
"""Compute the hash of a complex number z."""
  hash_value = hash_float(z.real) + sys.hash_info.imag * hash_float(z.imag)
  # do a signed reduction modulo 2**sys.hash_info.width
  M = 2**(sys.hash_info.width - 1)
  hash_value = (hash_value & (M - 1)) - (hash_value & M)
  if hash_value == -1:
    hash_value = -2
  return hash_value