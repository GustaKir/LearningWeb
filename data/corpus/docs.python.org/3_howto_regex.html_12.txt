Title: Using Named Groups and Lookahead Assertions in Python Regular Expressions
URL: https://docs.python.org/3/howto/regex.html
Summary: This section discusses the use of named groups in Python regular expressions, allowing for easier retrieval of matched groups using names rather than numbers. It also introduces backreferences with named groups and provides an example for finding doubled words. Additionally, it briefly mentions lookahead assertions, which can be either positive or negative.
---

```

It’s obviously much easier to retrieve `m.group('zonem')`, instead of having to remember to retrieve group 9.
The syntax for backreferences in an expression such as `(...)\1` refers to the number of the group. There’s naturally a variant that uses the group name instead of the number. This is another Python extension: `(?P=name)` indicates that the contents of the group called _name_ should again be matched at the current point. The regular expression for finding doubled words, `\b(\w+)\s+\1\b` can also be written as `\b(?P<word>\w+)\s+(?P=word)\b`:
>>>```
>>> p = re.compile(r'\b(?P<word>\w+)\s+(?P=word)\b')
>>> p.search('Paris in the the spring').group()
'the the'

```

### Lookahead Assertions[¶](https://docs.python.org/3/howto/regex.html#lookahead-assertions "Link to this heading")
Another zero-width assertion is the lookahead assertion. Lookahead assertions are available in both positive and negative form, and look like this: 

`(?=...)`
    
Positive lookahead assertion. This succeeds if the contained regular expression, represented here by `...`, successfully matches at the current location, and fails otherwise. But, once the contained expression has been tried, the matching engine doesn’t advance at all; the rest of the pattern is tried right where the assertion started. 

`(?!...)`
    
Negative lookahead assertion. This is the opposite of the positive assertion; it succeeds if the contained expression _doesn’t_ match at the current position in the string.
To make this concrete, let’s look at a case where a lookahead is useful. Consider a simple pattern to match a filename and split it apart into a base name and an extension, separated by a `.`. For example, in `news.rc`, `news` is the base name, and `rc` is the filename’s extension.
The pattern to match this is quite simple:
`.*[.].*$`
Notice that the `.` needs to be treated specially because it’s a metacharacter, so it’s inside a character class to only match that specific character. Also notice the trailing `$`; this is added to ensure that all the rest of the string must be included in the extension. This regular expression matches `foo.bar` and `autoexec.bat` and `sendmail.cf` and `printers.conf`.
Now, consider complicating the problem a bit; what if you want to match filenames where the extension is not `bat`? Some incorrect attempts:
`.*[.][^b].*$` The first attempt above tries to exclude `bat` by requiring that the first character of the extension is not a `b`. This is wrong, because the pattern also doesn’t match `foo.bar`.
`.*[.]([^b]..|.[^a].|..[^t])$`
The expression gets messier when you try to patch up the first solution by requiring one of the following cases to match: the first character of the extension isn’t `b`; the second character isn’t `a`; or the third character isn’t `t`. This accepts `foo.bar` and rejects `autoexec.bat`, but it requires a three-letter extension and won’t accept a filename with a two-letter extension such as `sendmail.cf`. We’ll complicate the pattern again in an effort to fix it.
`.*[.]([^b].?.?|.[^a]?.?|..?[^t]?)$`
In the third attempt, the second and third letters are all made optional in order to allow matching extensions shorter than three characters, such as `sendmail.cf`.
The pattern’s getting really complicated now, which makes it hard to read and understand. Worse, if the problem changes and you want to exclude both `bat` and `exe` as extensions, the pattern would get even more complicated and confusing.
A negative lookahead cuts through all this confusion:
`.*[.](?!bat$)[^.]*$` The negative lookahead means: if the expression `bat` doesn’t match at this point, try the rest of the pattern; if `bat$` does match, the whole pattern will fail. The trailing `$` is required to ensure that something like `sample.batch`, where the extension only starts with `bat`, will be allowed. The `[^.]*` makes sure that the pattern works when there are multiple dots in the filename.
Excluding another filename extension is now easy; simply add it as an alternative inside the assertion. The following pattern excludes filenames that end in either `bat` or `exe`:
`.*[.](?!bat$|exe$)[^.]*$`
## Modifying Strings[¶](https://docs.python.org/3/howto/regex.html#modifying-strings "Link to this heading")
Up to this point, we’ve simply performed searches against a static string. Regular expressions are also commonly used to modify strings in various ways, using the following pattern methods:
Method/Attribute | Purpose  
---|---  
`split()` | Split the string into a list, splitting it wherever the RE matches  
`sub()` | Find all substrings where the RE matches, and replace them with a different string  
`subn()` | Does the same thing as `sub()`, but returns the new string and the number of replacements  
### Splitting Strings[¶](https://docs.python.org/3/howto/regex.html#splitting-strings "Link to this heading")
The [`split()`](https://docs.python.org/3/library/re.html#re.Pattern.split "re.Pattern.split") method of a pattern split