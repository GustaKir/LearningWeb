Title: Simple Assignment Targets in Python
URL: https://docs.python.org/3/reference/simple_stmts.html
Summary: This section outlines the rules for simple assignment targets in Python, which allow only a single unparenthesized name. It describes how annotations are evaluated and stored in class or module scope within the `__annotations__` attribute, while noting that only simple targets have their annotations saved. In function scopes, annotations are local and are not evaluated or stored.
---

```

The difference from normal [Assignment statements](https://docs.python.org/3/reference/simple_stmts.html#assignment) is that only a single target is allowed.
The assignment target is considered “simple” if it consists of a single name that is not enclosed in parentheses. For simple assignment targets, if in class or module scope, the annotations are evaluated and stored in a special class or module attribute `__annotations__` that is a dictionary mapping from variable names (mangled if private) to evaluated annotations. This attribute is writable and is automatically created at the start of class or module body execution, if annotations are found statically.
If the assignment target is not simple (an attribute, subscript node, or parenthesized name), the annotation is evaluated if in class or module scope, but not stored.
If a name is annotated in a function scope, then this name is local for that scope. Annotations are never evaluated and stored in function scopes.
If the right hand side is present, an annotated assignment performs the actual assignment before evaluating annotations (where applicable). If the right hand side is not present for an expression target, then the interpreter evaluates the target except for the last [`__setitem__()`](https://docs.python.org/3/reference/datamodel.html#object.__setitem__ "object.__setitem__") or [`__setattr__()`](https://docs.python.org/3/reference/datamodel.html#object.__setattr__ "object.__setattr__") call.
See also 

[**PEP 526**](https://peps.python.org/pep-0526/) - Syntax for Variable Annotations
    
The proposal that added syntax for annotating the types of variables (including class variables and instance variables), instead of expressing them through comments. 

[**PEP 484**](https://peps.python.org/pep-0484/) - Type hints
    
The proposal that added the [`typing`](https://docs.python.org/3/library/typing.html#module-typing "typing: Support for type hints \(see :pep:`484`\).") module to provide a standard syntax for type annotations that can be used in static analysis tools and IDEs.
Changed in version 3.8: Now annotated assignments allow the same expressions in the right hand side as regular assignments. Previously, some expressions (like un-parenthesized tuple expressions) caused a syntax error.
## 7.3. The `assert` statement[¶](https://docs.python.org/3/reference/simple_stmts.html#the-assert-statement "Link to this heading")
Assert statements are a convenient way to insert debugging assertions into a program:
```
**assert_stmt** ::= "assert" [expression](https://docs.python.org/3/reference/expressions.html#grammar-token-python-grammar-expression) ["," [expression](https://docs.python.org/3/reference/expressions.html#grammar-token-python-grammar-expression)]

```

The simple form, `assert expression`, is equivalent to
```
if __debug__:
  if not expression: raise AssertionError

```

The extended form, `assert expression1, expression2`, is equivalent to
```
if __debug__:
  if not expression1: raise AssertionError(expression2)

```

These equivalences assume that [`__debug__`](https://docs.python.org/3/library/constants.html#debug__ "__debug__") and [`AssertionError`](https://docs.python.org/3/library/exceptions.html#AssertionError "AssertionError") refer to the built-in variables with those names. In the current implementation, the built-in variable `__debug__` is `True` under normal circumstances, `False` when optimization is requested (command line option [`-O`](https://docs.python.org/3/using/cmdline.html#cmdoption-O)). The current code generator emits no code for an [`assert`](https://docs.python.org/3/reference/simple_stmts.html#assert) statement when optimization is requested at compile time. Note that it is unnecessary to include the source code for the expression that failed in the error message; it will be displayed as part of the stack trace.
Assignments to [`__debug__`](https://docs.python.org/3/library/constants.html#debug__ "__debug__") are illegal. The value for the built-in variable is determined when the interpreter starts.
## 7.4. The `pass` statement[¶](https://docs.python.org/3/reference/simple_stmts.html#the-pass-statement "Link to this heading")
```
**pass_stmt** ::= "pass"

```

[`pass`](https://docs.python.org/3/reference/simple_stmts.html#pass) is a null operation — when it is executed, nothing happens. It is useful as a placeholder when a statement is required syntactically, but no code needs to be executed, for example:
```
deff(arg): pass  # a function that does nothing (yet)
classC: pass    # a class with no methods (yet)

```

## 7.5. The `del` statement[¶](https://docs.python.org/3/reference/simple_stmts.html#the-del-statement "Link to this heading")
```
**del_stmt** ::= "del" [target_list](https://docs.python.org/3/reference/simple_stmts.html#grammar-token-python-grammar-target_list)