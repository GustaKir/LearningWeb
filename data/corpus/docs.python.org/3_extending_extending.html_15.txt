Title: Header File for Spam Module in Python C API
URL: https://docs.python.org/3/extending/extending.html
Summary: This document outlines the header file for the 'spammodule', defining C API functions, including the PySpam_System, and the mechanism for importing the API using PyCapsule. It differentiates between the module compilation and its usage in client modules, along with error handling in the import process.
---

```
#ifndef Py_SPAMMODULE_H
#define Py_SPAMMODULE_H
#ifdef __cplusplus
extern"C"{
#endif
/* Header file for spammodule */
/* C API functions */
#define PySpam_System_NUM 0
#define PySpam_System_RETURN int
#define PySpam_System_PROTO (const char *command)
/* Total number of C API pointers */
#define PySpam_API_pointers 1

#ifdef SPAM_MODULE
/* This section is used when compiling spammodule.c */
staticPySpam_System_RETURNPySpam_SystemPySpam_System_PROTO;
#else
/* This section is used in modules that use spammodule's API */
staticvoid**PySpam_API;
#define PySpam_System \
 (*(PySpam_System_RETURN (*)PySpam_System_PROTO) PySpam_API[PySpam_System_NUM])
/* Return -1 on error, 0 on success.
 * PyCapsule_Import will set an exception if there's an error.
 */
staticint
import_spam(void)
{
PySpam_API=(void**)PyCapsule_Import("spam._C_API",0);
return(PySpam_API!=NULL)?0:-1;
}
#endif
#ifdef __cplusplus
}
#endif
#endif /* !defined(Py_SPAMMODULE_H) */

```

All that a client module must do in order to have access to the function `PySpam_System()` is to call the function (or rather macro) `import_spam()` in its initialization function:
```
PyMODINIT_FUNC
PyInit_client(void)
{
PyObject*m;
m=PyModule_Create(&clientmodule);
if(m==NULL)
returnNULL;
if(import_spam()<0)
returnNULL;
/* additional initialization can happen here */
returnm;
}

```

The main disadvantage of this approach is that the file `spammodule.h` is rather complicated. However, the basic structure is the same for each function that is exported, so it has to be learned only once.
Finally it should be mentioned that Capsules offer additional functionality, which is especially useful for memory allocation and deallocation of the pointer stored in a Capsule. The details are described in the Python/C API Reference Manual in the section [Capsules](https://docs.python.org/3/c-api/capsule.html#capsules) and in the implementation of Capsules (files `Include/pycapsule.h` and `Objects/pycapsule.c` in the Python source code distribution).
Footnotes
[[1](https://docs.python.org/3/extending/extending.html#id1)]
An interface for this function already exists in the standard module [`os`](https://docs.python.org/3/library/os.html#module-os "os: Miscellaneous operating system interfaces.") — it was chosen as a simple and straightforward example.
[[2](https://docs.python.org/3/extending/extending.html#id2)]
The metaphor of “borrowing” a reference is not completely correct: the owner still has a copy of the reference.
[[3](https://docs.python.org/3/extending/extending.html#id3)]
Checking that the reference count is at least 1 **does not work** — the reference count itself could be in freed memory and may thus be reused for another object!
[[4](https://docs.python.org/3/extending/extending.html#id4)]
These guarantees don’t hold when you use the “old” style calling convention — this is still found in much existing code.
### [Table of Contents](https://docs.python.org/3/contents.html)
  * [1. Extending Python with C or C++](https://docs.python.org/3/extending/extending.html)
    * [1.1. A Simple Example](https://docs.python.org/3/extending/extending.html#a-simple-example)
    * [1.2. Intermezzo: Errors and Exceptions](https://docs.python.org/3/extending/extending.html#intermezzo-errors-and-exceptions)
    * [1.3. Back to the Example](https://docs.python.org/3/extending/extending.html#back-to-the-example)
    * [1.4. The Module’s Method Table and Initialization Function](https://docs.python.org/3/extending/extending.html#the-module-s-method-table-and-initialization-function)
    * [1.5. Compilation and Linkage](https://docs.python.org/3/extending/extending.html#compilation-and-linkage)
    * [1.6. Calling Python Functions from C](https://docs.python.org/3/extending/extending.html#calling-python-functions-from-c)
    * [1.7. Extracting Parameters in Extension Functions](https://docs.python.org/3/extending/extending.html#extracting-parameters-in-extension-functions)
    * [1.8. Keyword Parameters for Extension Functions](https://docs.python.org/3/extending/extending.html#keyword-parameters-for-extension-functions)
    * [1.9. Building Arbitrary Values](https://docs.python.org/3/extending/extending.html#building-arbitrary-values)
    * [1.10. Reference Counts](https://docs.python.org/3/extending/extending.html#reference-counts)
      * [1.10.1. Reference Counting in Python](https://docs.python.org/3/extending/extending.html#reference-counting-in-python)
      * [1.10.2. Ownership Rules](https://docs.python.org/3/extending/extending.html#ownership-rules)
      * [1.10.3. Thin Ice](https://docs.python.org/3/extending/extending.html#thin-ice)
      * [1.10.4. NULL Pointers](https://docs.python.org/3/extending/extending.html#null-pointers)
    * [1.11. Writing Extensions in C++](https://docs.python.org/3/extending/extending.html#writing-extensions-in-c)
    * [1.12. Providing a C API for an Extension Module](https://docs.python.org/3/extending/extending.html#providing-a-c-api-for-an-extensio