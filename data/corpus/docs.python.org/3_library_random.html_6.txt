Title: Random Number Generation Methods in Python
URL: https://docs.python.org/3/library/random.html
Summary: This section discusses the `getrandbits()` method for customizing random bit generation in subclasses of `Random`. It also describes the `random.SystemRandom` class, which uses the `os.urandom()` function for generating random numbers based on operating system sources, ensuring non-reproducible sequences unaffected by software state.
---

getrandbits(_k_)[¶](https://docs.python.org/3/library/random.html#random.Random.getrandbits "Link to this definition")
    
Override this method in subclasses to customise the [`getrandbits()`](https://docs.python.org/3/library/random.html#random.getrandbits "random.getrandbits") behaviour of `Random` instances. 

_class_ random.SystemRandom([_seed_])[¶](https://docs.python.org/3/library/random.html#random.SystemRandom "Link to this definition")
    
Class that uses the [`os.urandom()`](https://docs.python.org/3/library/os.html#os.urandom "os.urandom") function for generating random numbers from sources provided by the operating system. Not available on all systems. Does not rely on software state, and sequences are not reproducible. Accordingly, the [`seed()`](https://docs.python.org/3/library/random.html#random.seed "random.seed") method has no effect and is ignored. The [`getstate()`](https://docs.python.org/3/library/random.html#random.getstate "random.getstate") and [`setstate()`](https://docs.python.org/3/library/random.html#random.setstate "random.setstate") methods raise [`NotImplementedError`](https://docs.python.org/3/library/exceptions.html#NotImplementedError "NotImplementedError") if called.
## Notes on Reproducibility[¶](https://docs.python.org/3/library/random.html#notes-on-reproducibility "Link to this heading")
Sometimes it is useful to be able to reproduce the sequences given by a pseudo-random number generator. By reusing a seed value, the same sequence should be reproducible from run to run as long as multiple threads are not running.
Most of the random module’s algorithms and seeding functions are subject to change across Python versions, but two aspects are guaranteed not to change:
  * If a new seeding method is added, then a backward compatible seeder will be offered.
  * The generator’s [`random()`](https://docs.python.org/3/library/random.html#random.Random.random "random.Random.random") method will continue to produce the same sequence when the compatible seeder is given the same seed.


## Examples[¶](https://docs.python.org/3/library/random.html#examples "Link to this heading")
Basic examples:
>>>```
>>> random()             # Random float: 0.0 <= x < 1.0
0.37444887175646646
>>> uniform(2.5, 10.0)        # Random float: 2.5 <= x <= 10.0
3.1800146073117523
>>> expovariate(1 / 5)        # Interval between arrivals averaging 5 seconds
5.148957571865031
>>> randrange(10)           # Integer from 0 to 9 inclusive
7
>>> randrange(0, 101, 2)       # Even integer from 0 to 100 inclusive
26
>>> choice(['win', 'lose', 'draw'])  # Single random element from a sequence
'draw'
>>> deck = 'ace two three four'.split()
>>> shuffle(deck)           # Shuffle a list
>>> deck
['four', 'two', 'ace', 'three']
>>> sample([10, 20, 30, 40, 50], k=4) # Four samples without replacement
[40, 10, 50, 30]

```

Simulations:
>>>```
>>> # Six roulette wheel spins (weighted sampling with replacement)
>>> choices(['red', 'black', 'green'], [18, 18, 2], k=6)
['red', 'green', 'black', 'black', 'red', 'black']
>>> # Deal 20 cards without replacement from a deck
>>> # of 52 playing cards, and determine the proportion of cards
>>> # with a ten-value: ten, jack, queen, or king.
>>> deal = sample(['tens', 'low cards'], counts=[16, 36], k=20)
>>> deal.count('tens') / 20
0.15
>>> # Estimate the probability of getting 5 or more heads from 7 spins
>>> # of a biased coin that settles on heads 60% of the time.
>>> sum(binomialvariate(n=7, p=0.6) >= 5 for i in range(10_000)) / 10_000
0.4169
>>> # Probability of the median of 5 samples being in middle two quartiles
>>> deftrial():
...   return 2_500 <= sorted(choices(range(10_000), k=5))[2] < 7_500
...
>>> sum(trial() for i in range(10_000)) / 10_000
0.7958

```

Example of [statistical bootstrapping](https://en.wikipedia.org/wiki/Bootstrapping_\(statistics\)) using resampling with replacement to estimate a confidence interval for the mean of a sample:
```
# https://www.thoughtco.com/example-of-bootstrapping-3126155
fromstatisticsimport fmean as mean
fromrandomimport choices
data = [41, 50, 29, 37, 81, 30, 73, 63, 20, 35, 68, 22, 60, 31, 95]
means = sorted(mean(choices(data, k=len(data))) for i in range(100))
print(f'The sample mean of {mean(data):.1f} has a 90% confidence '
   f'interval from {means[5]:.1f} to {means[94]:.1f}')

```

Example of a [resampling permutation test](https://en.wikipedia.org/wiki/Resampling_\(statistics\)#Permutation_tests) to determine the statistical significance or [p-value](https://en.wikipedia.org/wiki/P-value) of an observed difference between the effects of a drug versus a placebo: