Title: socket.recvmsg Function
URL: https://docs.python.org/3/library/socket.html
Summary: The `socket.recvmsg` function receives normal and ancillary data from a socket, with the buffer size specified by `_bufsize_`. It optionally accepts an `_ancbufsize_` for ancillary data, which defaults to 0. The function returns a 4-tuple containing the data, ancillary data, message flags, and address. Proper buffer sizes for ancillary data should be calculated using `CMSG_SPACE()` or `CMSG_LEN()`, as data exceeding the buffer may be truncated.
---

socket.recvmsg(_bufsize_[, _ancbufsize_[, _flags_]])[Â¶](https://docs.python.org/3/library/socket.html#socket.socket.recvmsg "Link to this definition")
    
Receive normal data (up to _bufsize_ bytes) and ancillary data from the socket. The _ancbufsize_ argument sets the size in bytes of the internal buffer used to receive the ancillary data; it defaults to 0, meaning that no ancillary data will be received. Appropriate buffer sizes for ancillary data can be calculated using [`CMSG_SPACE()`](https://docs.python.org/3/library/socket.html#socket.CMSG_SPACE "socket.CMSG_SPACE") or [`CMSG_LEN()`](https://docs.python.org/3/library/socket.html#socket.CMSG_LEN "socket.CMSG_LEN"), and items which do not fit into the buffer might be truncated or discarded. The _flags_ argument defaults to 0 and has the same meaning as for [`recv()`](https://docs.python.org/3/library/socket.html#socket.socket.recv "socket.socket.recv").
The return value is a 4-tuple: `(data, ancdata, msg_flags, address)`. The _data_ item is a [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "bytes") object holding the non-ancillary data received. The _ancdata_ item is a list of zero or more tuples `(cmsg_level, cmsg_type, cmsg_data)` representing the ancillary data (control messages) received: _cmsg_level_ and _cmsg_type_ are integers specifying the protocol level and protocol-specific type respectively, and _cmsg_data_ is a [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "bytes") object holding the associated data. The _msg_flags_ item is the bitwise OR of various flags indicating conditions on the received message; see your system documentation for details. If the receiving socket is unconnected, _address_ is the address of the sending socket, if available; otherwise, its value is unspecified.
On some systems, [`sendmsg()`](https://docs.python.org/3/library/socket.html#socket.socket.sendmsg "socket.socket.sendmsg") and [`recvmsg()`](https://docs.python.org/3/library/socket.html#socket.socket.recvmsg "socket.socket.recvmsg") can be used to pass file descriptors between processes over an [`AF_UNIX`](https://docs.python.org/3/library/socket.html#socket.AF_UNIX "socket.AF_UNIX") socket. When this facility is used (it is often restricted to [`SOCK_STREAM`](https://docs.python.org/3/library/socket.html#socket.SOCK_STREAM "socket.SOCK_STREAM") sockets), [`recvmsg()`](https://docs.python.org/3/library/socket.html#socket.socket.recvmsg "socket.socket.recvmsg") will return, in its ancillary data, items of the form `(socket.SOL_SOCKET, socket.SCM_RIGHTS, fds)`, where _fds_ is a [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "bytes") object representing the new file descriptors as a binary array of the native C int type. If [`recvmsg()`](https://docs.python.org/3/library/socket.html#socket.socket.recvmsg "socket.socket.recvmsg") raises an exception after the system call returns, it will first attempt to close any file descriptors received via this mechanism.
Some systems do not indicate the truncated length of ancillary data items which have been only partially received. If an item appears to extend beyond the end of the buffer, [`recvmsg()`](https://docs.python.org/3/library/socket.html#socket.socket.recvmsg "socket.socket.recvmsg") will issue a [`RuntimeWarning`](https://docs.python.org/3/library/exceptions.html#RuntimeWarning "RuntimeWarning"), and will return the part of it which is inside the buffer provided it has not been truncated before the start of its associated data.
On systems which support the `SCM_RIGHTS` mechanism, the following function will receive up to _maxfds_ file descriptors, returning the message data and a list containing the descriptors (while ignoring unexpected conditions such as unrelated control messages being received). See also [`sendmsg()`](https://docs.python.org/3/library/socket.html#socket.socket.sendmsg "socket.socket.sendmsg").
```
importsocket,array
defrecv_fds(sock, msglen, maxfds):
  fds = array.array("i")  # Array of ints
  msg, ancdata, flags, addr = sock.recvmsg(msglen, socket.CMSG_LEN(maxfds * fds.itemsize))
  for cmsg_level, cmsg_type, cmsg_data in ancdata:
    if cmsg_level == socket.SOL_SOCKET and cmsg_type == socket.SCM_RIGHTS:
      # Append data, ignoring any truncated integers at the end.
      fds.frombytes(cmsg_data[:len(cmsg_data) - (len(cmsg_data) % fds.itemsize)])
  return msg, list(fds)