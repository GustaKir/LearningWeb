Title: IP Address Module Changes and Version Information
URL: https://docs.python.org/3/library/ipaddress.html
Summary: This section discusses recent changes to the Python IP address module, specifically regarding handling leading zeros in version 3.8 and 3.9.5. It defines key attributes such as 'version' which indicates the IP type, and 'max_prefixlen', which specifies the total bits for IPv4 and IPv6, affecting how addresses are compared in the network.
---

```

Changed in version 3.8: Leading zeros are tolerated, even in ambiguous cases that look like octal notation.
Changed in version 3.9.5: Leading zeros are no longer tolerated and are treated as an error. IPv4 address strings are now parsed as strict as glibc [`inet_pton()`](https://docs.python.org/3/library/socket.html#socket.inet_pton "socket.inet_pton"). 

version[¶](https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv4Address.version "Link to this definition")
    
The appropriate version number: `4` for IPv4, `6` for IPv6. 

max_prefixlen[¶](https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv4Address.max_prefixlen "Link to this definition")
    
The total number of bits in the address representation for this version: `32` for IPv4, `128` for IPv6.
The prefix defines the number of leading bits in an address that are compared to determine whether or not an address is part of a network. 

compressed[¶](https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv4Address.compressed "Link to this definition")


exploded[¶](https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv4Address.exploded "Link to this definition")
    
The string representation in dotted decimal notation. Leading zeroes are never included in the representation.
As IPv4 does not define a shorthand notation for addresses with octets set to zero, these two attributes are always the same as `str(addr)` for IPv4 addresses. Exposing these attributes makes it easier to write display code that can handle both IPv4 and IPv6 addresses. 

packed[¶](https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv4Address.packed "Link to this definition")
    
The binary representation of this address - a [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "bytes") object of the appropriate length (most significant octet first). This is 4 bytes for IPv4 and 16 bytes for IPv6. 

reverse_pointer[¶](https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv4Address.reverse_pointer "Link to this definition")
    
The name of the reverse DNS PTR record for the IP address, e.g.:
>>>```
>>> ipaddress.ip_address("127.0.0.1").reverse_pointer
'1.0.0.127.in-addr.arpa'
>>> ipaddress.ip_address("2001:db8::1").reverse_pointer
'1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.b.d.0.1.0.0.2.ip6.arpa'

```

This is the name that could be used for performing a PTR lookup, not the resolved hostname itself.
Added in version 3.5. 

is_multicast[¶](https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv4Address.is_multicast "Link to this definition")
    
`True` if the address is reserved for multicast use. See [**RFC 3171**](https://datatracker.ietf.org/doc/html/rfc3171.html) (for IPv4) or [**RFC 2373**](https://datatracker.ietf.org/doc/html/rfc2373.html) (for IPv6). 

is_private[¶](https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv4Address.is_private "Link to this definition")
    
`True` if the address is defined as not globally reachable by [iana-ipv4-special-registry](https://www.iana.org/assignments/iana-ipv4-special-registry/iana-ipv4-special-registry.xhtml) (for IPv4) or [iana-ipv6-special-registry](https://www.iana.org/assignments/iana-ipv6-special-registry/iana-ipv6-special-registry.xhtml) (for IPv6) with the following exceptions:
  * `is_private` is `False` for the shared address space (`100.64.0.0/10`)
  * For IPv4-mapped IPv6-addresses the `is_private` value is determined by the semantics of the underlying IPv4 addresses and the following condition holds (see [`IPv6Address.ipv4_mapped`](https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv6Address.ipv4_mapped "ipaddress.IPv6Address.ipv4_mapped")):
```
address.is_private == address.ipv4_mapped.is_private