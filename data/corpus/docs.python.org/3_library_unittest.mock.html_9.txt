Title: Understanding the __class__ Attribute in Mock Objects
URL: https://docs.python.org/3/library/unittest.mock.html
Summary: This section explains the behavior of the `__class__` attribute in mock objects created using the unittest.mock module in Python. When a mock object has a specified spec, `__class__` returns the spec class, allowing it to pass `isinstance()` checks for the object it mimics. Additionally, `__class__` can be assigned to enable passing checks without a spec.
---

```


__class__[¶](https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.__class__ "Link to this definition")
    
Normally the `__class__` attribute of an object will return its type. For a mock object with a `spec`, `__class__` returns the spec class instead. This allows mock objects to pass [`isinstance()`](https://docs.python.org/3/library/functions.html#isinstance "isinstance") tests for the object they are replacing / masquerading as:
>>>```
>>> mock = Mock(spec=3)
>>> isinstance(mock, int)
True

```

`__class__` is assignable to, this allows a mock to pass an [`isinstance()`](https://docs.python.org/3/library/functions.html#isinstance "isinstance") check without forcing you to use a spec:
>>>```
>>> mock = Mock()
>>> mock.__class__ = dict
>>> isinstance(mock, dict)
True

```


_class_ unittest.mock.NonCallableMock(_spec =None_, _wraps =None_, _name =None_, _spec_set =None_, _** kwargs_)[¶](https://docs.python.org/3/library/unittest.mock.html#unittest.mock.NonCallableMock "Link to this definition")
    
A non-callable version of [`Mock`](https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock "unittest.mock.Mock"). The constructor parameters have the same meaning of [`Mock`](https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock "unittest.mock.Mock"), with the exception of _return_value_ and _side_effect_ which have no meaning on a non-callable mock.
Mock objects that use a class or an instance as a `spec` or `spec_set` are able to pass [`isinstance()`](https://docs.python.org/3/library/functions.html#isinstance "isinstance") tests:
>>>```
>>> mock = Mock(spec=SomeClass)
>>> isinstance(mock, SomeClass)
True
>>> mock = Mock(spec_set=SomeClass())
>>> isinstance(mock, SomeClass)
True

```

The [`Mock`](https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock "unittest.mock.Mock") classes have support for mocking magic methods. See [magic methods](https://docs.python.org/3/library/unittest.mock.html#magic-methods) for the full details.
The mock classes and the [`patch()`](https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch "unittest.mock.patch") decorators all take arbitrary keyword arguments for configuration. For the [`patch()`](https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch "unittest.mock.patch") decorators the keywords are passed to the constructor of the mock being created. The keyword arguments are for configuring attributes of the mock:
>>>```
>>> m = MagicMock(attribute=3, other='fish')
>>> m.attribute
3
>>> m.other
'fish'

```

The return value and side effect of child mocks can be set in the same way, using dotted notation. As you can’t use dotted names directly in a call you have to create a dictionary and unpack it using `**`:
>>>```
>>> attrs = {'method.return_value': 3, 'other.side_effect': KeyError}
>>> mock = Mock(some_attribute='eggs', **attrs)
>>> mock.some_attribute
'eggs'
>>> mock.method()
3
>>> mock.other()
Traceback (most recent call last):
...
KeyError

```

A callable mock which was created with a _spec_ (or a _spec_set_) will introspect the specification object’s signature when matching calls to the mock. Therefore, it can match the actual call’s arguments regardless of whether they were passed positionally or by name:
>>>```
>>> deff(a, b, c): pass
...
>>> mock = Mock(spec=f)
>>> mock(1, 2, c=3)
<Mock name='mock()' id='140161580456576'>
>>> mock.assert_called_with(1, 2, 3)
>>> mock.assert_called_with(a=1, b=2, c=3)