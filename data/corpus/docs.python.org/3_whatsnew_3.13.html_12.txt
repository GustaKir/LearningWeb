Title: Improvements to asyncio in Python 3.13
URL: https://docs.python.org/3/whatsnew/3.13.html
Summary: The asyncio module in Python 3.13 introduces enhancements, including 'asyncio.as_completed()' now yielding both an asynchronous and a plain iterator of awaitables, helping to associate results with their corresponding tasks. Additionally, 'asyncio.loop.create_unix_server()' will automatically remove the Unix socket when the server is stopped.
---

### asyncio[¶](https://docs.python.org/3/whatsnew/3.13.html#asyncio "Link to this heading")
  * [`asyncio.as_completed()`](https://docs.python.org/3/library/asyncio-task.html#asyncio.as_completed "asyncio.as_completed") now returns an object that is both an [asynchronous iterator](https://docs.python.org/3/glossary.html#term-asynchronous-iterator) and a plain [iterator](https://docs.python.org/3/glossary.html#term-iterator) of [awaitables](https://docs.python.org/3/glossary.html#term-awaitable). The awaitables yielded by asynchronous iteration include original task or future objects that were passed in, making it easier to associate results with the tasks being completed. (Contributed by Justin Arthur in [gh-77714](https://github.com/python/cpython/issues/77714).)
  * [`asyncio.loop.create_unix_server()`](https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.create_unix_server "asyncio.loop.create_unix_server") will now automatically remove the Unix socket when the server is closed. (Contributed by Pierre Ossman in [gh-111246](https://github.com/python/cpython/issues/111246).)
  * [`DatagramTransport.sendto()`](https://docs.python.org/3/library/asyncio-protocol.html#asyncio.DatagramTransport.sendto "asyncio.DatagramTransport.sendto") will now send zero-length datagrams if called with an empty bytes object. The transport flow control also now accounts for the datagram header when calculating the buffer size. (Contributed by Jamie Phan in [gh-115199](https://github.com/python/cpython/issues/115199).)
  * Add [`Queue.shutdown`](https://docs.python.org/3/library/asyncio-queue.html#asyncio.Queue.shutdown "asyncio.Queue.shutdown") and [`QueueShutDown`](https://docs.python.org/3/library/asyncio-queue.html#asyncio.QueueShutDown "asyncio.QueueShutDown") to manage queue termination. (Contributed by Laurie Opperman and Yves Duprat in [gh-104228](https://github.com/python/cpython/issues/104228).)
  * Add the [`Server.close_clients()`](https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.Server.close_clients "asyncio.Server.close_clients") and [`Server.abort_clients()`](https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.Server.abort_clients "asyncio.Server.abort_clients") methods, which more forcefully close an asyncio server. (Contributed by Pierre Ossman in [gh-113538](https://github.com/python/cpython/issues/113538).)
  * Accept a tuple of separators in [`StreamReader.readuntil()`](https://docs.python.org/3/library/asyncio-stream.html#asyncio.StreamReader.readuntil "asyncio.StreamReader.readuntil"), stopping when any one of them is encountered. (Contributed by Bruce Merry in [gh-81322](https://github.com/python/cpython/issues/81322).)
  * Improve the behavior of [`TaskGroup`](https://docs.python.org/3/library/asyncio-task.html#asyncio.TaskGroup "asyncio.TaskGroup") when an external cancellation collides with an internal cancellation. For example, when two task groups are nested and both experience an exception in a child task simultaneously, it was possible that the outer task group would hang, because its internal cancellation was swallowed by the inner task group.
In the case where a task group is cancelled externally and also must raise an [`ExceptionGroup`](https://docs.python.org/3/library/exceptions.html#ExceptionGroup "ExceptionGroup"), it will now call the parent task’s [`cancel()`](https://docs.python.org/3/library/asyncio-task.html#asyncio.Task.cancel "asyncio.Task.cancel") method. This ensures that a [`CancelledError`](https://docs.python.org/3/library/asyncio-exceptions.html#asyncio.CancelledError "asyncio.CancelledError") will be raised at the next [`await`](https://docs.python.org/3/reference/expressions.html#await), so the cancellation is not lost.
An added benefit of these changes is that task groups now preserve the cancellation count ([`cancelling()`](https://docs.python.org/3/library/asyncio-task.html#asyncio.Task.cancelling "asyncio.Task.cancelling")).
In order to handle some corner cases, [`uncancel()`](https://docs.python.org/3/library/asyncio-task.html#asyncio.Task.uncancel "asyncio.Task.uncancel") may now reset the undocumented `_must_cancel` flag when the cancellation count reaches zero.
(Inspired by an issue reported by Arthur Tacca in [gh-116720](https://github.com/python/cpython/issues/116720).)
  * When [`TaskGroup.create_task()`](https://docs.python.org/3/library/asyncio-task.html#asyncio.TaskGroup.create_task "asyncio.TaskGroup.create_task") is called on an inactive [`TaskGroup`](https://docs.python.org/3/library/asyncio-task.html#asyncio.TaskGroup "asyncio.TaskGroup"), the given coroutine will be closed (which prevents a [`RuntimeWarning`](https://docs.python.org/3/library/exceptions.html#RuntimeWarning "RuntimeWarning") about the given coroutine being never awaited). (Contributed by Arthur Tacca and Jason Zhang in [gh-115957](https://github.com/python/cpython/issues/115957).)