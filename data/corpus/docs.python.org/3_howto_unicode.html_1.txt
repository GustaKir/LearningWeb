Title: Python Unicode HOWTO
URL: https://docs.python.org/3/howto/unicode.html
Summary: This document discusses Python's support for the Unicode specification in representing textual data, highlighting common issues encountered when working with Unicode, and emphasizing the need for programs to handle a variety of characters in multiple languages.
---

Release:
    
1.12
This HOWTO discusses Python’s support for the Unicode specification for representing textual data, and explains various problems that people commonly encounter when trying to work with Unicode.
## Introduction to Unicode[¶](https://docs.python.org/3/howto/unicode.html#introduction-to-unicode "Link to this heading")
### Definitions[¶](https://docs.python.org/3/howto/unicode.html#definitions "Link to this heading")
Today’s programs need to be able to handle a wide variety of characters. Applications are often internationalized to display messages and output in a variety of user-selectable languages; the same program might need to output an error message in English, French, Japanese, Hebrew, or Russian. Web content can be written in any of these languages and can also include a variety of emoji symbols. Python’s string type uses the Unicode Standard for representing characters, which lets Python programs work with all these different possible characters.
Unicode (<https://www.unicode.org/>) is a specification that aims to list every character used by human languages and give each character its own unique code. The Unicode specifications are continually revised and updated to add new languages and symbols.
A **character** is the smallest possible component of a text. ‘A’, ‘B’, ‘C’, etc., are all different characters. So are ‘È’ and ‘Í’. Characters vary depending on the language or context you’re talking about. For example, there’s a character for “Roman Numeral One”, ‘Ⅰ’, that’s separate from the uppercase letter ‘I’. They’ll usually look the same, but these are two different characters that have different meanings.
The Unicode standard describes how characters are represented by **code points**. A code point value is an integer in the range 0 to 0x10FFFF (about 1.1 million values, the [actual number assigned](https://www.unicode.org/versions/latest/#Summary) is less than that). In the standard and in this document, a code point is written using the notation `U+265E` to mean the character with value `0x265e` (9,822 in decimal).
The Unicode standard contains a lot of tables listing characters and their corresponding code points:
```
0061  'a'; LATIN SMALL LETTER A
0062  'b'; LATIN SMALL LETTER B
0063  'c'; LATIN SMALL LETTER C
...
007B  '{'; LEFT CURLY BRACKET
...
2167  'Ⅷ'; ROMAN NUMERAL EIGHT
2168  'Ⅸ'; ROMAN NUMERAL NINE
...
265E  '♞'; BLACK CHESS KNIGHT
265F  '♟'; BLACK CHESS PAWN
...
1F600  '😀'; GRINNING FACE
1F609  '😉'; WINKING FACE
...

```

Strictly, these definitions imply that it’s meaningless to say ‘this is character `U+265E`’. `U+265E` is a code point, which represents some particular character; in this case, it represents the character ‘BLACK CHESS KNIGHT’, ‘♞’. In informal contexts, this distinction between code points and characters will sometimes be forgotten.
A character is represented on a screen or on paper by a set of graphical elements that’s called a **glyph**. The glyph for an uppercase A, for example, is two diagonal strokes and a horizontal stroke, though the exact details will depend on the font being used. Most Python code doesn’t need to worry about glyphs; figuring out the correct glyph to display is generally the job of a GUI toolkit or a terminal’s font renderer.
### Encodings[¶](https://docs.python.org/3/howto/unicode.html#encodings "Link to this heading")
To summarize the previous section: a Unicode string is a sequence of code points, which are numbers from 0 through `0x10FFFF` (1,114,111 decimal). This sequence of code points needs to be represented in memory as a set of **code units** , and **code units** are then mapped to 8-bit bytes. The rules for translating a Unicode string into a sequence of bytes are called a **character encoding** , or just an **encoding**.
The first encoding you might think of is using 32-bit integers as the code unit, and then using the CPU’s representation of 32-bit integers. In this representation, the string “Python” might look like this:
```
  P      y      t      h      o      n
0x50 00 00 00 79 00 00 00 74 00 00 00 68 00 00 00 6f 00 00 00 6e 00 00 00
  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23