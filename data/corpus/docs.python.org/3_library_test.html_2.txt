Title: Regression Testing Guidelines in Python
URL: https://docs.python.org/3/library/test.html
Summary: This section discusses the code pattern for running the testing suite using `test.regrtest` or `unittest` CLI. It emphasizes the importance of regression testing to identify code breaks, outlines guidelines for comprehensively testing all code components, and suggests a preference for whitebox testing over blackbox testing to ensure thorough coverage of boundary and edge cases.
---

```

This code pattern allows the testing suite to be run by [`test.regrtest`](https://docs.python.org/3/library/test.html#module-test.regrtest "test.regrtest: Drives the regression test suite."), on its own as a script that supports the [`unittest`](https://docs.python.org/3/library/unittest.html#module-unittest "unittest: Unit testing framework for Python.") CLI, or via the `python -m unittest` CLI.
The goal for regression testing is to try to break code. This leads to a few guidelines to be followed:
  * The testing suite should exercise all classes, functions, and constants. This includes not just the external API that is to be presented to the outside world but also “private” code.
  * Whitebox testing (examining the code being tested when the tests are being written) is preferred. Blackbox testing (testing only the published user interface) is not complete enough to make sure all boundary and edge cases are tested.
  * Make sure all possible values are tested including invalid ones. This makes sure that not only all valid values are acceptable but also that improper values are handled correctly.
  * Exhaust as many code paths as possible. Test where branching occurs and thus tailor input to make sure as many different paths through the code are taken.
  * Add an explicit test for any bugs discovered for the tested code. This will make sure that the error does not crop up again if the code is changed in the future.
  * Make sure to clean up after your tests (such as close and remove all temporary files).
  * If a test is dependent on a specific condition of the operating system then verify the condition already exists before attempting the test.
  * Import as few modules as possible and do it as soon as possible. This minimizes external dependencies of tests and also minimizes possible anomalous behavior from side-effects of importing a module.
  * Try to maximize code reuse. On occasion, tests will vary by something as small as what type of input is used. Minimize code duplication by subclassing a basic test class with a class that specifies the input:
```
classTestFuncAcceptsSequencesMixin:
  func = mySuperWhammyFunction
  deftest_func(self):
    self.func(self.arg)
classAcceptLists(TestFuncAcceptsSequencesMixin, unittest.TestCase):
  arg = [1, 2, 3]
classAcceptStrings(TestFuncAcceptsSequencesMixin, unittest.TestCase):
  arg = 'abc'
classAcceptTuples(TestFuncAcceptsSequencesMixin, unittest.TestCase):
  arg = (1, 2, 3)