Title: Overview of the Decimal Module in Python
URL: https://docs.python.org/3/library/decimal.html
Summary: The decimal module in Python extends binary and decimal floating point standards, offering complete control over rounding and signal handling. It supports exact unrounded decimal arithmetic and rounded floating-point arithmetic. The design focuses on decimal numbers, arithmetic context, and signals, ensuring immutability and preservation of significant digits.
---

```

  * Both binary and decimal floating point are implemented in terms of published standards. While the built-in float type exposes only a modest portion of its capabilities, the decimal module exposes all required parts of the standard. When needed, the programmer has full control over rounding and signal handling. This includes an option to enforce exact arithmetic by using exceptions to block any inexact operations.
  * The decimal module was designed to support “without prejudice, both exact unrounded decimal arithmetic (sometimes called fixed-point arithmetic) and rounded floating-point arithmetic.” – excerpt from the decimal arithmetic specification.


The module design is centered around three concepts: the decimal number, the context for arithmetic, and signals.
A decimal number is immutable. It has a sign, coefficient digits, and an exponent. To preserve significance, the coefficient digits do not truncate trailing zeros. Decimals also include special values such as `Infinity`, `-Infinity`, and `NaN`. The standard also differentiates `-0` from `+0`.
The context for arithmetic is an environment specifying precision, rounding rules, limits on exponents, flags indicating the results of operations, and trap enablers which determine whether signals are treated as exceptions. Rounding options include [`ROUND_CEILING`](https://docs.python.org/3/library/decimal.html#decimal.ROUND_CEILING "decimal.ROUND_CEILING"), [`ROUND_DOWN`](https://docs.python.org/3/library/decimal.html#decimal.ROUND_DOWN "decimal.ROUND_DOWN"), [`ROUND_FLOOR`](https://docs.python.org/3/library/decimal.html#decimal.ROUND_FLOOR "decimal.ROUND_FLOOR"), [`ROUND_HALF_DOWN`](https://docs.python.org/3/library/decimal.html#decimal.ROUND_HALF_DOWN "decimal.ROUND_HALF_DOWN"), [`ROUND_HALF_EVEN`](https://docs.python.org/3/library/decimal.html#decimal.ROUND_HALF_EVEN "decimal.ROUND_HALF_EVEN"), [`ROUND_HALF_UP`](https://docs.python.org/3/library/decimal.html#decimal.ROUND_HALF_UP "decimal.ROUND_HALF_UP"), [`ROUND_UP`](https://docs.python.org/3/library/decimal.html#decimal.ROUND_UP "decimal.ROUND_UP"), and [`ROUND_05UP`](https://docs.python.org/3/library/decimal.html#decimal.ROUND_05UP "decimal.ROUND_05UP").
Signals are groups of exceptional conditions arising during the course of computation. Depending on the needs of the application, signals may be ignored, considered as informational, or treated as exceptions. The signals in the decimal module are: [`Clamped`](https://docs.python.org/3/library/decimal.html#decimal.Clamped "decimal.Clamped"), [`InvalidOperation`](https://docs.python.org/3/library/decimal.html#decimal.InvalidOperation "decimal.InvalidOperation"), [`DivisionByZero`](https://docs.python.org/3/library/decimal.html#decimal.DivisionByZero "decimal.DivisionByZero"), [`Inexact`](https://docs.python.org/3/library/decimal.html#decimal.Inexact "decimal.Inexact"), [`Rounded`](https://docs.python.org/3/library/decimal.html#decimal.Rounded "decimal.Rounded"), [`Subnormal`](https://docs.python.org/3/library/decimal.html#decimal.Subnormal "decimal.Subnormal"), [`Overflow`](https://docs.python.org/3/library/decimal.html#decimal.Overflow "decimal.Overflow"), [`Underflow`](https://docs.python.org/3/library/decimal.html#decimal.Underflow "decimal.Underflow") and [`FloatOperation`](https://docs.python.org/3/library/decimal.html#decimal.FloatOperation "decimal.FloatOperation").
For each signal there is a flag and a trap enabler. When a signal is encountered, its flag is set to one, then, if the trap enabler is set to one, an exception is raised. Flags are sticky, so the user needs to reset them before monitoring a calculation.
See also
  * IBM’s General Decimal Arithmetic Specification, [The General Decimal Arithmetic Specification](https://speleotrove.com/decimal/decarith.html).


## Quick-start Tutorial[¶](https://docs.python.org/3/library/decimal.html#quick-start-tutorial "Link to this heading")
The usual start to using decimals is importing the module, viewing the current context with [`getcontext()`](https://docs.python.org/3/library/decimal.html#decimal.getcontext "decimal.getcontext") and, if necessary, setting new values for precision, rounding, or enabled traps:
>>>```
>>> fromdecimalimport *
>>> getcontext()
Context(prec=28, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,
    capitals=1, clamp=0, flags=[], traps=[Overflow, DivisionByZero,
    InvalidOperation])
>>> getcontext().prec = 7    # Set a new precision

```

Decimal instances can be constructed from integers, strings, floats, or tuples. Construction from an integer or a float performs an exact conversion of the value of that integer or float. Decimal numbers include special values such as `NaN` which stands for “Not a number”, positive and negative `Infinity`, and `-0`:
>>>