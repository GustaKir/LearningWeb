Title: Unpacking a MIME Message into Files
URL: https://docs.python.org/3/library/email.examples.html
Summary: This script unpacks a MIME message from a specified file into a designated directory. It uses command-line arguments to determine the output directory and handles the message's multipart content, ensuring that files are extracted appropriately while avoiding name collisions.
---

```
#!/usr/bin/env python3
"""Unpack a MIME message into a directory of files."""
importos
importemail
importmimetypes
fromemail.policyimport default
fromargparseimport ArgumentParser

defmain():
  parser = ArgumentParser(description="""\
Unpack a MIME message into a directory of files.
""")
  parser.add_argument('-d', '--directory', required=True,
            help="""Unpack the MIME message into the named
            directory, which will be created if it doesn't already
            exist.""")
  parser.add_argument('msgfile')
  args = parser.parse_args()
  with open(args.msgfile, 'rb') as fp:
    msg = email.message_from_binary_file(fp, policy=default)
  try:
    os.mkdir(args.directory)
  except FileExistsError:
    pass
  counter = 1
  for part in msg.walk():
    # multipart/* are just containers
    if part.get_content_maintype() == 'multipart':
      continue
    # Applications should really sanitize the given filename so that an
    # email message can't be used to overwrite important files
    filename = part.get_filename()
    if not filename:
      ext = mimetypes.guess_extension(part.get_content_type())
      if not ext:
        # Use a generic bag-of-bits extension
        ext = '.bin'
      filename = f'part-{counter:03d}{ext}'
    counter += 1
    with open(os.path.join(args.directory, filename), 'wb') as fp:
      fp.write(part.get_payload(decode=True))

if __name__ == '__main__':
  main()

```

Here’s an example of how to create an HTML message with an alternative plain text version. To make things a bit more interesting, we include a related image in the html part, and we save a copy of what we are going to send to disk, as well as sending it.
```
#!/usr/bin/env python3
importsmtplib
fromemail.messageimport EmailMessage
fromemail.headerregistryimport Address
fromemail.utilsimport make_msgid
# Create the base text message.
msg = EmailMessage()
msg['Subject'] = "Pourquoi pas des asperges pour ce midi ?"
msg['From'] = Address("Pepé Le Pew", "pepe", "example.com")
msg['To'] = (Address("Penelope Pussycat", "penelope", "example.com"),
       Address("Fabrette Pussycat", "fabrette", "example.com"))
msg.set_content("""\
Salut!
Cette recette [1] sera sûrement un très bon repas.
[1] http://www.yummly.com/recipe/Roasted-Asparagus-Epicurious-203718
--Pepé
""")
# Add the html version. This converts the message into a multipart/alternative
# container, with the original text message as the first part and the new html
# message as the second part.
asparagus_cid = make_msgid()
msg.add_alternative("""\
<html>
 <head></head>
 <body>
  <p>Salut!</p>
  <p>Cette
    <a href="http://www.yummly.com/recipe/Roasted-Asparagus-Epicurious-203718">
      recette
    </a> sera sûrement un très bon repas.
  </p>
  <img src="cid:{asparagus_cid}">
 </body>
</html>
""".format(asparagus_cid=asparagus_cid[1:-1]), subtype='html')
# note that we needed to peel the <> off the msgid for use in the html.
# Now add the related image to the html part.
with open("roasted-asparagus.jpg", 'rb') as img:
  msg.get_payload()[1].add_related(img.read(), 'image', 'jpeg',
                   cid=asparagus_cid)
# Make a local copy of what we are going to send.
with open('outgoing.msg', 'wb') as f:
  f.write(bytes(msg))
# Send the message via local SMTP server.
with smtplib.SMTP('localhost') as s:
  s.send_message(msg)

```

If we were sent the message from the last example, here is one way we could process it: