Title: Creating Functions in C and C++ for Python
URL: https://docs.python.org/3/faq/extending.html
Summary: This section explains how to create built-in modules in Python using C and C++. It details the process for implementing functions, variables, exceptions, and types in C and advises on using C compatibility features in C++. It also cautions against using global or static C++ objects with constructors.
---

## [Can I create my own functions in C?](https://docs.python.org/3/faq/extending.html#id3)[¶](https://docs.python.org/3/faq/extending.html#can-i-create-my-own-functions-in-c "Link to this heading")
Yes, you can create built-in modules containing functions, variables, exceptions and even new types in C. This is explained in the document [Extending and Embedding the Python Interpreter](https://docs.python.org/3/extending/index.html#extending-index).
Most intermediate or advanced Python books will also cover this topic.
## [Can I create my own functions in C++?](https://docs.python.org/3/faq/extending.html#id4)[¶](https://docs.python.org/3/faq/extending.html#id1 "Link to this heading")
Yes, using the C compatibility features found in C++. Place `extern "C" { ... }` around the Python include files and put `extern "C"` before each function that is going to be called by the Python interpreter. Global or static C++ objects with constructors are probably not a good idea.
## [Writing C is hard; are there any alternatives?](https://docs.python.org/3/faq/extending.html#id5)[¶](https://docs.python.org/3/faq/extending.html#writing-c-is-hard-are-there-any-alternatives "Link to this heading")
There are a number of alternatives to writing your own C extensions, depending on what you’re trying to do.
[Cython](https://cython.org) and its relative [Pyrex](https://www.csse.canterbury.ac.nz/greg.ewing/python/Pyrex/) are compilers that accept a slightly modified form of Python and generate the corresponding C code. Cython and Pyrex make it possible to write an extension without having to learn Python’s C API.
If you need to interface to some C or C++ library for which no Python extension currently exists, you can try wrapping the library’s data types and functions with a tool such as [SWIG](https://www.swig.org). [SIP](https://github.com/Python-SIP/sip), [CXX](https://cxx.sourceforge.net/) [Boost](https://www.boost.org/libs/python/doc/index.html), or [Weave](https://github.com/scipy/weave) are also alternatives for wrapping C++ libraries.
## [How can I execute arbitrary Python statements from C?](https://docs.python.org/3/faq/extending.html#id6)[¶](https://docs.python.org/3/faq/extending.html#how-can-i-execute-arbitrary-python-statements-from-c "Link to this heading")
The highest-level function to do this is [`PyRun_SimpleString()`](https://docs.python.org/3/c-api/veryhigh.html#c.PyRun_SimpleString "PyRun_SimpleString") which takes a single string argument to be executed in the context of the module `__main__` and returns `0` for success and `-1` when an exception occurred (including [`SyntaxError`](https://docs.python.org/3/library/exceptions.html#SyntaxError "SyntaxError")). If you want more control, use [`PyRun_String()`](https://docs.python.org/3/c-api/veryhigh.html#c.PyRun_String "PyRun_String"); see the source for [`PyRun_SimpleString()`](https://docs.python.org/3/c-api/veryhigh.html#c.PyRun_SimpleString "PyRun_SimpleString") in `Python/pythonrun.c`.
## [How can I evaluate an arbitrary Python expression from C?](https://docs.python.org/3/faq/extending.html#id7)[¶](https://docs.python.org/3/faq/extending.html#how-can-i-evaluate-an-arbitrary-python-expression-from-c "Link to this heading")
Call the function [`PyRun_String()`](https://docs.python.org/3/c-api/veryhigh.html#c.PyRun_String "PyRun_String") from the previous question with the start symbol [`Py_eval_input`](https://docs.python.org/3/c-api/veryhigh.html#c.Py_eval_input "Py_eval_input"); it parses an expression, evaluates it and returns its value.
## [How do I extract C values from a Python object?](https://docs.python.org/3/faq/extending.html#id8)[¶](https://docs.python.org/3/faq/extending.html#how-do-i-extract-c-values-from-a-python-object "Link to this heading")
That depends on the object’s type. If it’s a tuple, [`PyTuple_Size()`](https://docs.python.org/3/c-api/tuple.html#c.PyTuple_Size "PyTuple_Size") returns its length and [`PyTuple_GetItem()`](https://docs.python.org/3/c-api/tuple.html#c.PyTuple_GetItem "PyTuple_GetItem") returns the item at a specified index. Lists have similar functions, [`PyList_Size()`](https://docs.python.org/3/c-api/list.html#c.PyList_Size "PyList_Size") and [`PyList_GetItem()`](https://docs.python.org/3/c-api/list.html#c.PyList_GetItem "PyList_GetItem").
For bytes, [`PyBytes_Size()`](https://docs.python.org/3/c-api/bytes.html#c.PyBytes_Size "PyBytes_Size") returns its length and [`PyBytes_AsStringAndSize()`](https://docs.python.org/3/c-api/bytes.html#c.PyBytes_AsStringAndSize "PyBytes_AsStringAndSize") provides a pointer to its value and its length. Note that Python bytes objects may contain null bytes so C’s `strlen()` should not be used.
To test the type of an object, first make sure it isn’t `NULL`, and then use [`PyBytes_Check()`](https://docs.python.org/3/c-api/bytes.html#c.PyBytes_Check "PyBytes_Check"), [`PyTuple_Check()`](https://docs.python.org/3/c-api/tuple.html#c.PyTuple_Check "PyTuple_Check"), [`PyList_Check()`](https://d