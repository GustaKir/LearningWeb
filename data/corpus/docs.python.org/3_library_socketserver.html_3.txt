Title: Introduction to ThreadingUnixDatagramServer
URL: https://docs.python.org/3/library/socketserver.html
Summary: The `ThreadingUnixDatagramServer` class allows for concurrent handling of datagram requests. To build a service, derive from `BaseRequestHandler` and override the `handle()` method. New classes `ForkingUnixStreamServer` and `ForkingUnixDatagramServer` were introduced in version 3.12 for enhanced functionality.
---

_class_ socketserver.ThreadingUnixDatagramServer[¶](https://docs.python.org/3/library/socketserver.html#socketserver.ThreadingUnixDatagramServer "Link to this definition")
    
These classes are pre-defined using the mix-in classes.
Added in version 3.12: The `ForkingUnixStreamServer` and `ForkingUnixDatagramServer` classes were added.
To implement a service, you must derive a class from [`BaseRequestHandler`](https://docs.python.org/3/library/socketserver.html#socketserver.BaseRequestHandler "socketserver.BaseRequestHandler") and redefine its [`handle()`](https://docs.python.org/3/library/socketserver.html#socketserver.BaseRequestHandler.handle "socketserver.BaseRequestHandler.handle") method. You can then run various versions of the service by combining one of the server classes with your request handler class. The request handler class must be different for datagram or stream services. This can be hidden by using the handler subclasses [`StreamRequestHandler`](https://docs.python.org/3/library/socketserver.html#socketserver.StreamRequestHandler "socketserver.StreamRequestHandler") or [`DatagramRequestHandler`](https://docs.python.org/3/library/socketserver.html#socketserver.DatagramRequestHandler "socketserver.DatagramRequestHandler").
Of course, you still have to use your head! For instance, it makes no sense to use a forking server if the service contains state in memory that can be modified by different requests, since the modifications in the child process would never reach the initial state kept in the parent process and passed to each child. In this case, you can use a threading server, but you will probably have to use locks to protect the integrity of the shared data.
On the other hand, if you are building an HTTP server where all data is stored externally (for instance, in the file system), a synchronous class will essentially render the service “deaf” while one request is being handled – which may be for a very long time if a client is slow to receive all the data it has requested. Here a threading or forking server is appropriate.
In some cases, it may be appropriate to process part of a request synchronously, but to finish processing in a forked child depending on the request data. This can be implemented by using a synchronous server and doing an explicit fork in the request handler class [`handle()`](https://docs.python.org/3/library/socketserver.html#socketserver.BaseRequestHandler.handle "socketserver.BaseRequestHandler.handle") method.
Another approach to handling multiple simultaneous requests in an environment that supports neither threads nor [`fork()`](https://docs.python.org/3/library/os.html#os.fork "os.fork") (or where these are too expensive or inappropriate for the service) is to maintain an explicit table of partially finished requests and to use [`selectors`](https://docs.python.org/3/library/selectors.html#module-selectors "selectors: High-level I/O multiplexing.") to decide which request to work on next (or whether to handle a new incoming request). This is particularly important for stream services where each client can potentially be connected for a long time (if threads or subprocesses cannot be used).
## Server Objects[¶](https://docs.python.org/3/library/socketserver.html#server-objects "Link to this heading") 

_class_ socketserver.BaseServer(_server_address_ , _RequestHandlerClass_)[¶](https://docs.python.org/3/library/socketserver.html#socketserver.BaseServer "Link to this definition")
    
This is the superclass of all Server objects in the module. It defines the interface, given below, but does not implement most of the methods, which is done in subclasses. The two parameters are stored in the respective [`server_address`](https://docs.python.org/3/library/socketserver.html#socketserver.BaseServer.server_address "socketserver.BaseServer.server_address") and [`RequestHandlerClass`](https://docs.python.org/3/library/socketserver.html#socketserver.BaseServer.RequestHandlerClass "socketserver.BaseServer.RequestHandlerClass") attributes. 

fileno()[¶](https://docs.python.org/3/library/socketserver.html#socketserver.BaseServer.fileno "Link to this definition")
    
Return an integer file descriptor for the socket on which the server is listening. This function is most commonly passed to [`selectors`](https://docs.python.org/3/library/selectors.html#module-selectors "selectors: High-level I/O multiplexing."), to allow monitoring multiple servers in the same process.