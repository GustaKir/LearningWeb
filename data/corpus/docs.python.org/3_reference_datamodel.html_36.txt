Title: Class Body Execution in Python
URL: https://docs.python.org/3/reference/datamodel.html
Summary: This section discusses the execution of class bodies in Python, which is performed using `exec(body, globals(), namespace)`. It highlights the lexical scoping that allows access to names from current and outer scopes, but notes that methods defined in the class cannot access class scope variables directly. Access to class variables must be done through the parameters of instance or class methods.
---

[**PEP 3115**](https://peps.python.org/pep-3115/) - Metaclasses in Python 3000
    
Introduced the `__prepare__` namespace hook
#### 3.3.3.5. Executing the class body[¶](https://docs.python.org/3/reference/datamodel.html#executing-the-class-body "Link to this heading")
The class body is executed (approximately) as `exec(body, globals(), namespace)`. The key difference from a normal call to [`exec()`](https://docs.python.org/3/library/functions.html#exec "exec") is that lexical scoping allows the class body (including any methods) to reference names from the current and outer scopes when the class definition occurs inside a function.
However, even when the class definition occurs inside the function, methods defined inside the class still cannot see names defined at the class scope. Class variables must be accessed through the first parameter of instance or class methods, or through the implicit lexically scoped `__class__` reference described in the next section.
#### 3.3.3.6. Creating the class object[¶](https://docs.python.org/3/reference/datamodel.html#creating-the-class-object "Link to this heading")
Once the class namespace has been populated by executing the class body, the class object is created by calling `metaclass(name, bases, namespace, **kwds)` (the additional keywords passed here are the same as those passed to `__prepare__`).
This class object is the one that will be referenced by the zero-argument form of [`super()`](https://docs.python.org/3/library/functions.html#super "super"). `__class__` is an implicit closure reference created by the compiler if any methods in a class body refer to either `__class__` or `super`. This allows the zero argument form of [`super()`](https://docs.python.org/3/library/functions.html#super "super") to correctly identify the class being defined based on lexical scoping, while the class or instance that was used to make the current call is identified based on the first argument passed to the method.
**CPython implementation detail:** In CPython 3.6 and later, the `__class__` cell is passed to the metaclass as a `__classcell__` entry in the class namespace. If present, this must be propagated up to the `type.__new__` call in order for the class to be initialised correctly. Failing to do so will result in a [`RuntimeError`](https://docs.python.org/3/library/exceptions.html#RuntimeError "RuntimeError") in Python 3.8.
When using the default metaclass [`type`](https://docs.python.org/3/library/functions.html#type "type"), or any metaclass that ultimately calls `type.__new__`, the following additional customization steps are invoked after creating the class object:
  1. The `type.__new__` method collects all of the attributes in the class namespace that define a [`__set_name__()`](https://docs.python.org/3/reference/datamodel.html#object.__set_name__ "object.__set_name__") method;
  2. Those `__set_name__` methods are called with the class being defined and the assigned name of that particular attribute;
  3. The [`__init_subclass__()`](https://docs.python.org/3/reference/datamodel.html#object.__init_subclass__ "object.__init_subclass__") hook is called on the immediate parent of the new class in its method resolution order.


After the class object is created, it is passed to the class decorators included in the class definition (if any) and the resulting object is bound in the local namespace as the defined class.
When a new class is created by `type.__new__`, the object provided as the namespace parameter is copied to a new ordered mapping and the original object is discarded. The new copy is wrapped in a read-only proxy, which becomes the [`__dict__`](https://docs.python.org/3/reference/datamodel.html#type.__dict__ "type.__dict__") attribute of the class object.
See also