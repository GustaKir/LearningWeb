Title: Daemon Threads in Python
URL: https://docs.python.org/3/library/threading.html
Summary: This section explains the 'daemon' attribute of threads in Python, which indicates if a thread runs as a daemon. It must be set before calling 'start()' to avoid 'RuntimeError'. The main thread is not a daemon, and the program exits when only non-daemon threads are alive.
---

daemon[¶](https://docs.python.org/3/library/threading.html#threading.Thread.daemon "Link to this definition")
    
A boolean value indicating whether this thread is a daemon thread (`True`) or not (`False`). This must be set before [`start()`](https://docs.python.org/3/library/threading.html#threading.Thread.start "threading.Thread.start") is called, otherwise [`RuntimeError`](https://docs.python.org/3/library/exceptions.html#RuntimeError "RuntimeError") is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to [`daemon`](https://docs.python.org/3/library/threading.html#threading.Thread.daemon "threading.Thread.daemon") = `False`.
The entire Python program exits when no alive non-daemon threads are left. 

isDaemon()[¶](https://docs.python.org/3/library/threading.html#threading.Thread.isDaemon "Link to this definition")


setDaemon()[¶](https://docs.python.org/3/library/threading.html#threading.Thread.setDaemon "Link to this definition")
    
Deprecated getter/setter API for [`daemon`](https://docs.python.org/3/library/threading.html#threading.Thread.daemon "threading.Thread.daemon"); use it directly as a property instead.
Deprecated since version 3.10.
## Lock Objects[¶](https://docs.python.org/3/library/threading.html#lock-objects "Link to this heading")
A primitive lock is a synchronization primitive that is not owned by a particular thread when locked. In Python, it is currently the lowest level synchronization primitive available, implemented directly by the [`_thread`](https://docs.python.org/3/library/_thread.html#module-_thread "_thread: Low-level threading API.") extension module.
A primitive lock is in one of two states, “locked” or “unlocked”. It is created in the unlocked state. It has two basic methods, [`acquire()`](https://docs.python.org/3/library/threading.html#threading.Lock.acquire "threading.Lock.acquire") and [`release()`](https://docs.python.org/3/library/threading.html#threading.Lock.release "threading.Lock.release"). When the state is unlocked, [`acquire()`](https://docs.python.org/3/library/threading.html#threading.Lock.acquire "threading.Lock.acquire") changes the state to locked and returns immediately. When the state is locked, [`acquire()`](https://docs.python.org/3/library/threading.html#threading.Lock.acquire "threading.Lock.acquire") blocks until a call to [`release()`](https://docs.python.org/3/library/threading.html#threading.Lock.release "threading.Lock.release") in another thread changes it to unlocked, then the [`acquire()`](https://docs.python.org/3/library/threading.html#threading.Lock.acquire "threading.Lock.acquire") call resets it to locked and returns. The [`release()`](https://docs.python.org/3/library/threading.html#threading.Lock.release "threading.Lock.release") method should only be called in the locked state; it changes the state to unlocked and returns immediately. If an attempt is made to release an unlocked lock, a [`RuntimeError`](https://docs.python.org/3/library/exceptions.html#RuntimeError "RuntimeError") will be raised.
Locks also support the [context management protocol](https://docs.python.org/3/library/threading.html#with-locks).
When more than one thread is blocked in [`acquire()`](https://docs.python.org/3/library/threading.html#threading.Lock.acquire "threading.Lock.acquire") waiting for the state to turn to unlocked, only one thread proceeds when a [`release()`](https://docs.python.org/3/library/threading.html#threading.Lock.release "threading.Lock.release") call resets the state to unlocked; which one of the waiting threads proceeds is not defined, and may vary across implementations.
All methods are executed atomically. 

_class_ threading.Lock[¶](https://docs.python.org/3/library/threading.html#threading.Lock "Link to this definition")
    
The class implementing primitive lock objects. Once a thread has acquired a lock, subsequent attempts to acquire it block, until it is released; any thread may release it.
Changed in version 3.13: `Lock` is now a class. In earlier Pythons, `Lock` was a factory function which returned an instance of the underlying private lock type.