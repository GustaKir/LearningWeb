Title: Python 3.12 and 3.13 Updates on Annotation Scopes
URL: https://docs.python.org/3/reference/executionmodel.html
Summary: Python 3.12 introduced annotation scopes per PEP 695, while version 3.13 expanded their usage for type parameter defaults, as outlined in PEP 696. The section also covers lazy evaluation for type aliases and type variables, emphasizing that their values are only computed when needed.
---

Added in version 3.12: Annotation scopes were introduced in Python 3.12 as part of [**PEP 695**](https://peps.python.org/pep-0695/).
Changed in version 3.13: Annotation scopes are also used for type parameter defaults, as introduced by [**PEP 696**](https://peps.python.org/pep-0696/).
### 4.2.4. Lazy evaluation[¶](https://docs.python.org/3/reference/executionmodel.html#lazy-evaluation "Link to this heading")
The values of type aliases created through the [`type`](https://docs.python.org/3/reference/simple_stmts.html#type) statement are _lazily evaluated_. The same applies to the bounds, constraints, and default values of type variables created through the [type parameter syntax](https://docs.python.org/3/reference/compound_stmts.html#type-params). This means that they are not evaluated when the type alias or type variable is created. Instead, they are only evaluated when doing so is necessary to resolve an attribute access.
Example:
>>>```
>>> type Alias = 1/0
>>> Alias.__value__
Traceback (most recent call last):
...
ZeroDivisionError: division by zero
>>> deffunc[T: 1/0](): pass
>>> T = func.__type_params__[0]
>>> T.__bound__
Traceback (most recent call last):
...
ZeroDivisionError: division by zero

```

Here the exception is raised only when the `__value__` attribute of the type alias or the `__bound__` attribute of the type variable is accessed.
This behavior is primarily useful for references to types that have not yet been defined when the type alias or type variable is created. For example, lazy evaluation enables creation of mutually recursive type aliases:
```
fromtypingimport Literal
type SimpleExpr = int | Parenthesized
type Parenthesized = tuple[Literal["("], Expr, Literal[")"]]
type Expr = SimpleExpr | tuple[SimpleExpr, Literal["+", "-"], Expr]

```

Lazily evaluated values are evaluated in [annotation scope](https://docs.python.org/3/reference/executionmodel.html#annotation-scopes), which means that names that appear inside the lazily evaluated value are looked up as if they were used in the immediately enclosing scope.
Added in version 3.12.
### 4.2.5. Builtins and restricted execution[¶](https://docs.python.org/3/reference/executionmodel.html#builtins-and-restricted-execution "Link to this heading")
**CPython implementation detail:** Users should not touch `__builtins__`; it is strictly an implementation detail. Users wanting to override values in the builtins namespace should [`import`](https://docs.python.org/3/reference/simple_stmts.html#import) the [`builtins`](https://docs.python.org/3/library/builtins.html#module-builtins "builtins: The module that provides the built-in namespace.") module and modify its attributes appropriately.
The builtins namespace associated with the execution of a code block is actually found by looking up the name `__builtins__` in its global namespace; this should be a dictionary or a module (in the latter case the module’s dictionary is used). By default, when in the [`__main__`](https://docs.python.org/3/library/__main__.html#module-__main__ "__main__: The environment where top-level code is run. Covers command-line interfaces, import-time behavior, and ``__name__ == '__main__'``.") module, `__builtins__` is the built-in module [`builtins`](https://docs.python.org/3/library/builtins.html#module-builtins "builtins: The module that provides the built-in namespace."); when in any other module, `__builtins__` is an alias for the dictionary of the [`builtins`](https://docs.python.org/3/library/builtins.html#module-builtins "builtins: The module that provides the built-in namespace.") module itself.
### 4.2.6. Interaction with dynamic features[¶](https://docs.python.org/3/reference/executionmodel.html#interaction-with-dynamic-features "Link to this heading")
Name resolution of free variables occurs at runtime, not at compile time. This means that the following code will print 42:
```
i = 10
deff():
  print(i)
i = 42
f()