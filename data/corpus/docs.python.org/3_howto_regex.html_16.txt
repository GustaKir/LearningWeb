Title: Optimizing Regular Expressions with re.search()
URL: https://docs.python.org/3/howto/regex.html
Summary: This section advises against using re.match() with a preceding '.*' in regular expressions. Instead, it recommends using re.search(), which utilizes character analysis for optimization and improves search efficiency by avoiding unnecessary backtracking.
---

```

Sometimes you’ll be tempted to keep using [`re.match()`](https://docs.python.org/3/library/re.html#re.match "re.match"), and just add `.*` to the front of your RE. Resist this temptation and use [`re.search()`](https://docs.python.org/3/library/re.html#re.search "re.search") instead. The regular expression compiler does some analysis of REs in order to speed up the process of looking for a match. One such analysis figures out what the first character of a match must be; for example, a pattern starting with `Crow` must match starting with a `'C'`. The analysis lets the engine quickly scan through the string looking for the starting character, only trying the full match if a `'C'` is found.
Adding `.*` defeats this optimization, requiring scanning to the end of the string and then backtracking to find a match for the rest of the RE. Use [`re.search()`](https://docs.python.org/3/library/re.html#re.search "re.search") instead.
### Greedy versus Non-Greedy[¶](https://docs.python.org/3/howto/regex.html#greedy-versus-non-greedy "Link to this heading")
When repeating a regular expression, as in `a*`, the resulting action is to consume as much of the pattern as possible. This fact often bites you when you’re trying to match a pair of balanced delimiters, such as the angle brackets surrounding an HTML tag. The naive pattern for matching a single HTML tag doesn’t work because of the greedy nature of `.*`.
>>>```
>>> s = '<html><head><title>Title</title>'
>>> len(s)
32
>>> print(re.match('<.*>', s).span())
(0, 32)
>>> print(re.match('<.*>', s).group())
<html><head><title>Title</title>

```

The RE matches the `'<'` in `'<html>'`, and the `.*` consumes the rest of the string. There’s still more left in the RE, though, and the `>` can’t match at the end of the string, so the regular expression engine has to backtrack character by character until it finds a match for the `>`. The final match extends from the `'<'` in `'<html>'` to the `'>'` in `'</title>'`, which isn’t what you want.
In this case, the solution is to use the non-greedy quantifiers `*?`, `+?`, `??`, or `{m,n}?`, which match as _little_ text as possible. In the above example, the `'>'` is tried immediately after the first `'<'` matches, and when it fails, the engine advances a character at a time, retrying the `'>'` at every step. This produces just the right result:
>>>```
>>> print(re.match('<.*?>', s).group())
<html>

```

(Note that parsing HTML or XML with regular expressions is painful. Quick-and-dirty patterns will handle common cases, but HTML and XML have special cases that will break the obvious regular expression; by the time you’ve written a regular expression that handles all of the possible cases, the patterns will be _very_ complicated. Use an HTML or XML parser module for such tasks.)
### Using re.VERBOSE[¶](https://docs.python.org/3/howto/regex.html#using-re-verbose "Link to this heading")
By now you’ve probably noticed that regular expressions are a very compact notation, but they’re not terribly readable. REs of moderate complexity can become lengthy collections of backslashes, parentheses, and metacharacters, making them difficult to read and understand.
For such REs, specifying the [`re.VERBOSE`](https://docs.python.org/3/library/re.html#re.VERBOSE "re.VERBOSE") flag when compiling the regular expression can be helpful, because it allows you to format the regular expression more clearly.
The `re.VERBOSE` flag has several effects. Whitespace in the regular expression that _isn’t_ inside a character class is ignored. This means that an expression such as `dog | cat` is equivalent to the less readable `dog|cat`, but `[a b]` will still match the characters `'a'`, `'b'`, or a space. In addition, you can also put comments inside a RE; comments extend from a `#` character to the next newline. When used with triple-quoted strings, this enables REs to be formatted more neatly:
```
pat = re.compile(r"""
 \s*         # Skip leading whitespace
 (?P<header>[^:]+)  # Header name
 \s* :        # Whitespace, and a colon
 (?P<value>.*?)   # The header's value -- *? used to
           # lose the following trailing whitespace
 \s*$        # Trailing whitespace to end-of-line
""", re.VERBOSE)

```

This is far more readable than:
```
pat = re.compile(r"\s*(?P<header>[^:]+)\s*:(?P<value>.*?)\s*$")