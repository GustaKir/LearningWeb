Title: Line Continuation and Implicit Line Joining in Python
URL: https://docs.python.org/3/reference/lexical_analysis.html
Summary: This section details the rules around line endings and comments in Python. It explains that a backslash cannot be used to continue a comment or to continue tokens outside string literals. Additionally, it covers implicit line joining within parentheses, square brackets, or curly braces, allowing expressions to span multiple lines without backslashes, and notes that comments can be included on these implicitly continued lines.
---

```

A line ending in a backslash cannot carry a comment. A backslash does not continue a comment. A backslash does not continue a token except for string literals (i.e., tokens other than string literals cannot be split across physical lines using a backslash). A backslash is illegal elsewhere on a line outside a string literal.
### 2.1.6. Implicit line joining[¶](https://docs.python.org/3/reference/lexical_analysis.html#implicit-line-joining "Link to this heading")
Expressions in parentheses, square brackets or curly braces can be split over more than one physical line without using backslashes. For example:
```
month_names = ['Januari', 'Februari', 'Maart',   # These are the
        'April',  'Mei',   'Juni',    # Dutch names
        'Juli',  'Augustus', 'September', # for the months
        'Oktober', 'November', 'December']  # of the year

```

Implicitly continued lines can carry comments. The indentation of the continuation lines is not important. Blank continuation lines are allowed. There is no NEWLINE token between implicit continuation lines. Implicitly continued lines can also occur within triple-quoted strings (see below); in that case they cannot carry comments.
### 2.1.7. Blank lines[¶](https://docs.python.org/3/reference/lexical_analysis.html#blank-lines "Link to this heading")
A logical line that contains only spaces, tabs, formfeeds and possibly a comment, is ignored (i.e., no NEWLINE token is generated). During interactive input of statements, handling of a blank line may differ depending on the implementation of the read-eval-print loop. In the standard interactive interpreter, an entirely blank logical line (i.e. one containing not even whitespace or a comment) terminates a multi-line statement.
### 2.1.8. Indentation[¶](https://docs.python.org/3/reference/lexical_analysis.html#indentation "Link to this heading")
Leading whitespace (spaces and tabs) at the beginning of a logical line is used to compute the indentation level of the line, which in turn is used to determine the grouping of statements.
Tabs are replaced (from left to right) by one to eight spaces such that the total number of characters up to and including the replacement is a multiple of eight (this is intended to be the same rule as used by Unix). The total number of spaces preceding the first non-blank character then determines the line’s indentation. Indentation cannot be split over multiple physical lines using backslashes; the whitespace up to the first backslash determines the indentation.
Indentation is rejected as inconsistent if a source file mixes tabs and spaces in a way that makes the meaning dependent on the worth of a tab in spaces; a [`TabError`](https://docs.python.org/3/library/exceptions.html#TabError "TabError") is raised in that case.
**Cross-platform compatibility note:** because of the nature of text editors on non-UNIX platforms, it is unwise to use a mixture of spaces and tabs for the indentation in a single source file. It should also be noted that different platforms may explicitly limit the maximum indentation level.
A formfeed character may be present at the start of the line; it will be ignored for the indentation calculations above. Formfeed characters occurring elsewhere in the leading whitespace have an undefined effect (for instance, they may reset the space count to zero).
The indentation levels of consecutive lines are used to generate INDENT and DEDENT tokens, using a stack, as follows.
Before the first line of the file is read, a single zero is pushed on the stack; this will never be popped off again. The numbers pushed on the stack will always be strictly increasing from bottom to top. At the beginning of each logical line, the line’s indentation level is compared to the top of the stack. If it is equal, nothing happens. If it is larger, it is pushed on the stack, and one INDENT token is generated. If it is smaller, it _must_ be one of the numbers occurring on the stack; all numbers on the stack that are larger are popped off, and for each number popped off a DEDENT token is generated. At the end of the file, a DEDENT token is generated for each number remaining on the stack that is larger than zero.
Here is an example of a correctly (though confusingly) indented piece of Python code:
```
defperm(l):
    # Compute the list of all permutations of l
  if len(l) <= 1:
         return [l]
  r = []
  for i in range(len(l)):
       s = l[:i] + l[i+1:]
       p = perm(s)
       for x in p:
       r.append(l[i:i+1] + x)
  return r

```

The following example shows various indentation errors:
```
 defperm(l):            # error: first line indented
for i in range(len(l)):       # error: not indented
  s = l[:i] + l[i+1:]
    p = perm(l[:i] + l[i+1:])  # error: unexpected indent
    for x in p:
        r.append(l[i:i+1] + x)
      return r        # error: inconsistent dedent