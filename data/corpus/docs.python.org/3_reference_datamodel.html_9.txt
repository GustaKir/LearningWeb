Title: Method Attributes in Python
URL: https://docs.python.org/3/reference/datamodel.html
Summary: This section describes key attributes of methods in Python, including `__doc__` for documentation, `__name__` for the method's name, and `__module__` indicating the module the method is defined in. It notes that methods can access attributes of the underlying function object.
---

method.__doc__[¶](https://docs.python.org/3/reference/datamodel.html#method.__doc__ "Link to this definition")
| The method’s documentation (same as [`method.__func__.__doc__`](https://docs.python.org/3/reference/datamodel.html#function.__doc__ "function.__doc__")). A [`string`](https://docs.python.org/3/library/stdtypes.html#str "str") if the original function had a docstring, else `None`. 

method.__name__[¶](https://docs.python.org/3/reference/datamodel.html#method.__name__ "Link to this definition")
| The name of the method (same as [`method.__func__.__name__`](https://docs.python.org/3/reference/datamodel.html#function.__name__ "function.__name__")) 

method.__module__[¶](https://docs.python.org/3/reference/datamodel.html#method.__module__ "Link to this definition")
| The name of the module the method was defined in, or `None` if unavailable.  
Methods also support accessing (but not setting) the arbitrary function attributes on the underlying [function object](https://docs.python.org/3/reference/datamodel.html#user-defined-funcs).
User-defined method objects may be created when getting an attribute of a class (perhaps via an instance of that class), if that attribute is a user-defined [function object](https://docs.python.org/3/reference/datamodel.html#user-defined-funcs) or a [`classmethod`](https://docs.python.org/3/library/functions.html#classmethod "classmethod") object.
When an instance method object is created by retrieving a user-defined [function object](https://docs.python.org/3/reference/datamodel.html#user-defined-funcs) from a class via one of its instances, its [`__self__`](https://docs.python.org/3/reference/datamodel.html#method.__self__ "method.__self__") attribute is the instance, and the method object is said to be _bound_. The new method’s [`__func__`](https://docs.python.org/3/reference/datamodel.html#method.__func__ "method.__func__") attribute is the original function object.
When an instance method object is created by retrieving a [`classmethod`](https://docs.python.org/3/library/functions.html#classmethod "classmethod") object from a class or instance, its [`__self__`](https://docs.python.org/3/reference/datamodel.html#method.__self__ "method.__self__") attribute is the class itself, and its [`__func__`](https://docs.python.org/3/reference/datamodel.html#method.__func__ "method.__func__") attribute is the function object underlying the class method.
When an instance method object is called, the underlying function ([`__func__`](https://docs.python.org/3/reference/datamodel.html#method.__func__ "method.__func__")) is called, inserting the class instance ([`__self__`](https://docs.python.org/3/reference/datamodel.html#method.__self__ "method.__self__")) in front of the argument list. For instance, when `C` is a class which contains a definition for a function `f()`, and `x` is an instance of `C`, calling `x.f(1)` is equivalent to calling `C.f(x, 1)`.
When an instance method object is derived from a [`classmethod`](https://docs.python.org/3/library/functions.html#classmethod "classmethod") object, the “class instance” stored in [`__self__`](https://docs.python.org/3/reference/datamodel.html#method.__self__ "method.__self__") will actually be the class itself, so that calling either `x.f(1)` or `C.f(1)` is equivalent to calling `f(C,1)` where `f` is the underlying function.
It is important to note that user-defined functions which are attributes of a class instance are not converted to bound methods; this _only_ happens when the function is an attribute of the class.
#### 3.2.8.3. Generator functions[¶](https://docs.python.org/3/reference/datamodel.html#generator-functions "Link to this heading")
A function or method which uses the [`yield`](https://docs.python.org/3/reference/simple_stmts.html#yield) statement (see section [The yield statement](https://docs.python.org/3/reference/simple_stmts.html#yield)) is called a _generator function_. Such a function, when called, always returns an [iterator](https://docs.python.org/3/glossary.html#term-iterator) object which can be used to execute the body of the function: calling the iterator’s [`iterator.__next__()`](https://docs.python.org/3/library/stdtypes.html#iterator.__next__ "iterator.__next__") method will cause the function to execute until it provides a value using the `yield` statement. When the function executes a [`return`](https://docs.python.org/3/reference/simple_stmts.html#return) statement or falls off the end, a [`StopIteration`](https://docs.python.org/3/library/exceptions.html#StopIteration "StopIteration") exception is raised and the iterator will have reached the end of the set of values to be returned.
#### 3.2.8.4. Coroutine functions[¶](https://docs.python.org/3/reference/datamodel.html#coroutine-functions "Link to this heading")
A function or method which is defined using [`async def`](https://docs.python.org/3/reference/compound_stmts.html#async-def) is called a _coroutine function_. Such a function, when call