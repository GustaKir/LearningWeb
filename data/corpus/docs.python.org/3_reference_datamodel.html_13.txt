Title: __loader__ Attribute in Python Modules
URL: https://docs.python.org/3/reference/datamodel.html
Summary: The `__loader__` attribute of a module provides the loader object used by the import machinery to load the module, primarily for introspection purposes. It defaults to `None` for dynamically created modules using `types.ModuleType`. To ensure it is set, use `importlib.util.module_from_spec()`. It is recommended to use `module.__spec__.loader` for reliable access to the loader.
---

module.__loader__[¶](https://docs.python.org/3/reference/datamodel.html#module.__loader__ "Link to this definition")
    
The [loader](https://docs.python.org/3/glossary.html#term-loader) object that the import machinery used to load the module.
This attribute is mostly useful for introspection, but can be used for additional loader-specific functionality, for example getting data associated with a loader.
`__loader__` defaults to `None` for modules created dynamically using the [`types.ModuleType`](https://docs.python.org/3/library/types.html#types.ModuleType "types.ModuleType") constructor; use [`importlib.util.module_from_spec()`](https://docs.python.org/3/library/importlib.html#importlib.util.module_from_spec "importlib.util.module_from_spec") instead to ensure the attribute is set to a [loader](https://docs.python.org/3/glossary.html#term-loader) object.
It is **strongly** recommended that you use [`module.__spec__.loader`](https://docs.python.org/3/library/importlib.html#importlib.machinery.ModuleSpec.loader "importlib.machinery.ModuleSpec.loader") instead of `module.__loader__`.
Changed in version 3.4: This attribute now defaults to `None` for modules created dynamically using the [`types.ModuleType`](https://docs.python.org/3/library/types.html#types.ModuleType "types.ModuleType") constructor. Previously the attribute was optional.
Deprecated since version 3.12, will be removed in version 3.16: Setting `__loader__` on a module while failing to set `__spec__.loader` is deprecated. In Python 3.16, `__loader__` will cease to be set or taken into consideration by the import system or the standard library. 

module.__path__[¶](https://docs.python.org/3/reference/datamodel.html#module.__path__ "Link to this definition")
    
A (possibly empty) [sequence](https://docs.python.org/3/glossary.html#term-sequence) of strings enumerating the locations where the package’s submodules will be found. Non-package modules should not have a `__path__` attribute. See [__path__ attributes on modules](https://docs.python.org/3/reference/import.html#package-path-rules) for more details.
It is **strongly** recommended that you use [`module.__spec__.submodule_search_locations`](https://docs.python.org/3/library/importlib.html#importlib.machinery.ModuleSpec.submodule_search_locations "importlib.machinery.ModuleSpec.submodule_search_locations") instead of `module.__path__`. 

module.__file__[¶](https://docs.python.org/3/reference/datamodel.html#module.__file__ "Link to this definition")


module.__cached__[¶](https://docs.python.org/3/reference/datamodel.html#module.__cached__ "Link to this definition")
    
`__file__` and `__cached__` are both optional attributes that may or may not be set. Both attributes should be a [`str`](https://docs.python.org/3/library/stdtypes.html#str "str") when they are available.
`__file__` indicates the pathname of the file from which the module was loaded (if loaded from a file), or the pathname of the shared library file for extension modules loaded dynamically from a shared library. It might be missing for certain types of modules, such as C modules that are statically linked into the interpreter, and the [import system](https://docs.python.org/3/reference/import.html#importsystem) may opt to leave it unset if it has no semantic meaning (for example, a module loaded from a database).
If `__file__` is set then the `__cached__` attribute might also be set, which is the path to any compiled version of the code (for example, a byte-compiled file). The file does not need to exist to set this attribute; the path can simply point to where the compiled file _would_ exist (see [**PEP 3147**](https://peps.python.org/pep-3147/)).
Note that `__cached__` may be set even if `__file__` is not set. However, that scenario is quite atypical. Ultimately, the [loader](https://docs.python.org/3/glossary.html#term-loader) is what makes use of the module spec provided by the [finder](https://docs.python.org/3/glossary.html#term-finder) (from which `__file__` and `__cached__` are derived). So if a loader can load from a cached module but otherwise does not load from a file, that atypical scenario may be appropriate.
It is **strongly** recommended that you use [`module.__spec__.cached`](https://docs.python.org/3/library/importlib.html#importlib.machinery.ModuleSpec.cached "importlib.machinery.ModuleSpec.cached") instead of `module.__cached__`.
Deprecated since version 3.13, will be removed in version 3.15: Setting `__cached__` on a module while failing to set `__spec__.cached` is deprecated. In Python 3.15, `__cached__` will cease to be set or taken into consideration by the import system or standard library.
#### 3.2.9.2. Other writable attributes on module objects[¶](https://docs.python.org/3/reference/datamodel.html#other-writable-attributes-on-module-objects "Link to this heading")
As well as the import-related attributes listed above, module objects also have the following writable attributes: