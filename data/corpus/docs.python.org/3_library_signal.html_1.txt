Title: Signal Module - Async Event Handlers
URL: https://docs.python.org/3/library/signal.html
Summary: The `signal` module in Python allows setting up signal handlers for asynchronous events. It includes the `signal.signal()` function for defining custom handlers. By default, certain signals like `SIGPIPE` are ignored, and `SIGINT` is translated into a `KeyboardInterrupt`.
---

# `signal` — Set handlers for asynchronous events[¶](https://docs.python.org/3/library/signal.html#module-signal "Link to this heading")
**Source code:** [Lib/signal.py](https://github.com/python/cpython/tree/3.13/Lib/signal.py)
This module provides mechanisms to use signal handlers in Python.
## General rules[¶](https://docs.python.org/3/library/signal.html#general-rules "Link to this heading")
The [`signal.signal()`](https://docs.python.org/3/library/signal.html#signal.signal "signal.signal") function allows defining custom handlers to be executed when a signal is received. A small number of default handlers are installed: [`SIGPIPE`](https://docs.python.org/3/library/signal.html#signal.SIGPIPE "signal.SIGPIPE") is ignored (so write errors on pipes and sockets can be reported as ordinary Python exceptions) and [`SIGINT`](https://docs.python.org/3/library/signal.html#signal.SIGINT "signal.SIGINT") is translated into a [`KeyboardInterrupt`](https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt "KeyboardInterrupt") exception if the parent process has not changed it.
A handler for a particular signal, once set, remains installed until it is explicitly reset (Python emulates the BSD style interface regardless of the underlying implementation), with the exception of the handler for [`SIGCHLD`](https://docs.python.org/3/library/signal.html#signal.SIGCHLD "signal.SIGCHLD"), which follows the underlying implementation.
On WebAssembly platforms, signals are emulated and therefore behave differently. Several functions and signals are not available on these platforms.
### Execution of Python signal handlers[¶](https://docs.python.org/3/library/signal.html#execution-of-python-signal-handlers "Link to this heading")
A Python signal handler does not get executed inside the low-level (C) signal handler. Instead, the low-level signal handler sets a flag which tells the [virtual machine](https://docs.python.org/3/glossary.html#term-virtual-machine) to execute the corresponding Python signal handler at a later point(for example at the next [bytecode](https://docs.python.org/3/glossary.html#term-bytecode) instruction). This has consequences:
  * It makes little sense to catch synchronous errors like [`SIGFPE`](https://docs.python.org/3/library/signal.html#signal.SIGFPE "signal.SIGFPE") or [`SIGSEGV`](https://docs.python.org/3/library/signal.html#signal.SIGSEGV "signal.SIGSEGV") that are caused by an invalid operation in C code. Python will return from the signal handler to the C code, which is likely to raise the same signal again, causing Python to apparently hang. From Python 3.3 onwards, you can use the [`faulthandler`](https://docs.python.org/3/library/faulthandler.html#module-faulthandler "faulthandler: Dump the Python traceback.") module to report on synchronous errors.
  * A long-running calculation implemented purely in C (such as regular expression matching on a large body of text) may run uninterrupted for an arbitrary amount of time, regardless of any signals received. The Python signal handlers will be called when the calculation finishes.
  * If the handler raises an exception, it will be raised “out of thin air” in the main thread. See the [note below](https://docs.python.org/3/library/signal.html#handlers-and-exceptions) for a discussion.