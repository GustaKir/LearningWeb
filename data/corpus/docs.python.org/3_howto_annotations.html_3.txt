Title: Best Practices for Annotations in Python
URL: https://docs.python.org/3/howto/annotations.html
Summary: This section outlines best practices for managing the `__annotations__` member in Python. It advises against direct assignments to `__annotations__`, suggests using a dictionary if assignments are necessary, and stresses the importance of checking the type before accessing its contents. Additionally, it recommends avoiding modifications or deletions of `__annotations__` dicts.
---

If [`eval()`](https://docs.python.org/3/library/functions.html#eval "eval") attempts to evaluate such values, it will fail and raise an exception. So, when designing a library API that works with annotations, it’s recommended to only attempt to evaluate string values when explicitly requested to by the caller.
## Best Practices For `__annotations__` In Any Python Version[¶](https://docs.python.org/3/howto/annotations.html#best-practices-for-annotations-in-any-python-version "Link to this heading")
  * You should avoid assigning to the `__annotations__` member of objects directly. Let Python manage setting `__annotations__`.
  * If you do assign directly to the `__annotations__` member of an object, you should always set it to a `dict` object.
  * If you directly access the `__annotations__` member of an object, you should ensure that it’s a dictionary before attempting to examine its contents.
  * You should avoid modifying `__annotations__` dicts.
  * You should avoid deleting the `__annotations__` attribute of an object.


## `__annotations__` Quirks[¶](https://docs.python.org/3/howto/annotations.html#annotations-quirks "Link to this heading")
In all versions of Python 3, function objects lazy-create an annotations dict if no annotations are defined on that object. You can delete the `__annotations__` attribute using `del fn.__annotations__`, but if you then access `fn.__annotations__` the object will create a new empty dict that it will store and return as its annotations. Deleting the annotations on a function before it has lazily created its annotations dict will throw an `AttributeError`; using `del fn.__annotations__` twice in a row is guaranteed to always throw an `AttributeError`.
Everything in the above paragraph also applies to class and module objects in Python 3.10 and newer.
In all versions of Python 3, you can set `__annotations__` on a function object to `None`. However, subsequently accessing the annotations on that object using `fn.__annotations__` will lazy-create an empty dictionary as per the first paragraph of this section. This is _not_ true of modules and classes, in any Python version; those objects permit setting `__annotations__` to any Python value, and will retain whatever value is set.
If Python stringizes your annotations for you (using `from __future__ import annotations`), and you specify a string as an annotation, the string will itself be quoted. In effect the annotation is quoted _twice._ For example:
```
from__future__import annotations
deffoo(a: "str"): pass
print(foo.__annotations__)