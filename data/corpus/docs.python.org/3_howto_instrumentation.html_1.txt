Title: Using DTrace for Python Instrumentation
URL: https://docs.python.org/3/howto/instrumentation.html
Summary: This section provides commands for utilizing DTrace to monitor Python function entries and returns, as well as checking for SystemTap static markers in the Python binary. It includes examples of DTrace output and how to verify the presence of the '.note.stapsdt' section using 'readelf'.
---

```
$ python3.6-q&
$ sudodtrace-l-Ppython$!# or: dtrace -l -m python3.6
  ID  PROVIDER      MODULE             FUNCTION NAME
29564 python18035    python3.6     _PyEval_EvalFrameDefault function-entry
29565 python18035    python3.6       dtrace_function_entry function-entry
29566 python18035    python3.6     _PyEval_EvalFrameDefault function-return
29567 python18035    python3.6      dtrace_function_return function-return
29568 python18035    python3.6              collect gc-done
29569 python18035    python3.6              collect gc-start
29570 python18035    python3.6     _PyEval_EvalFrameDefault line
29571 python18035    python3.6         maybe_dtrace_line line

```

On Linux, you can verify if the SystemTap static markers are present in the built binary by seeing if it contains a “.note.stapsdt” section.
```
$ readelf-S./python|grep.note.stapsdt
[30] .note.stapsdt    NOTE     0000000000000000 00308d78

```

If you’ve built Python as a shared library (with the [`--enable-shared`](https://docs.python.org/3/using/configure.html#cmdoption-enable-shared) configure option), you need to look instead within the shared library. For example:
```
$ readelf-Slibpython3.3dm.so.1.0|grep.note.stapsdt
[29] .note.stapsdt    NOTE     0000000000000000 00365b68

```

Sufficiently modern readelf can print the metadata:
```
$ readelf-n./python
Displaying notes found at file offset 0x00000254 with length 0x00000020:
  Owner         Data size     Description
  GNU         0x00000010     NT_GNU_ABI_TAG (ABI version tag)
    OS: Linux, ABI: 2.6.32
Displaying notes found at file offset 0x00000274 with length 0x00000024:
  Owner         Data size     Description
  GNU         0x00000014     NT_GNU_BUILD_ID (unique build ID bitstring)
    Build ID: df924a2b08a7e89f6e11251d4602022977af2670
Displaying notes found at file offset 0x002d6c30 with length 0x00000144:
  Owner         Data size     Description
  stapsdt       0x00000031     NT_STAPSDT (SystemTap probe descriptors)
    Provider: python
    Name: gc__start
    Location: 0x00000000004371c3, Base: 0x0000000000630ce2, Semaphore: 0x00000000008d6bf6
    Arguments: -4@%ebx
  stapsdt       0x00000030     NT_STAPSDT (SystemTap probe descriptors)
    Provider: python
    Name: gc__done
    Location: 0x00000000004374e1, Base: 0x0000000000630ce2, Semaphore: 0x00000000008d6bf8
    Arguments: -8@%rax
  stapsdt       0x00000045     NT_STAPSDT (SystemTap probe descriptors)
    Provider: python
    Name: function__entry
    Location: 0x000000000053db6c, Base: 0x0000000000630ce2, Semaphore: 0x00000000008d6be8
    Arguments: 8@%rbp 8@%r12 -4@%eax
  stapsdt       0x00000046     NT_STAPSDT (SystemTap probe descriptors)
    Provider: python
    Name: function__return
    Location: 0x000000000053dba8, Base: 0x0000000000630ce2, Semaphore: 0x00000000008d6bea
    Arguments: 8@%rbp 8@%r12 -4@%eax

```

The above metadata contains information for SystemTap describing how it can patch strategically placed machine code instructions to enable the tracing hooks used by a SystemTap script.
## Static DTrace probes[¶](https://docs.python.org/3/howto/instrumentation.html#static-dtrace-probes "Link to this heading")
The following example DTrace script can be used to show the call/return hierarchy of a Python script, only tracing within the invocation of a function called “start”. In other words, import-time function invocations are not going to be listed:
```
self int indent;
python$target:::function-entry
/copyinstr(arg1) == "start"/
{
    self->trace = 1;
}
python$target:::function-entry
/self->trace/
{
    printf("%d\t%*s:", timestamp, 15, probename);
    printf("%*s", self->indent, "");
    printf("%s:%s:%d\n", basename(copyinstr(arg0)), copyinstr(arg1), arg2);
    self->indent++;
}
python$target:::function-return
/self->trace/
{
    self->indent--;
    printf("%d\t%*s:", timestamp, 15, probename);
    printf("%*s", self->indent, "");
    printf("%s:%s:%d\n", basename(copyinstr(arg0)), copyinstr(arg1), arg2);
}
python$target:::function-return
/copyinstr(arg1) == "start"/
{
    self->trace = 0;
}

```

It can be invoked like this:
```
$ sudodtrace-q-scall_stack.d-c"python3.6 script.py"

```

The output looks like this: