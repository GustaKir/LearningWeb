Title: Understanding ctypes Behavior in Python
URL: https://docs.python.org/3/library/ctypes.html
Summary: This section discusses the lesser-known aspects of Python's ctypes library, highlighting surprising behaviors when using structures. An example illustrates how modifying the contents of a ctypes structure may not produce the expected results, emphasizing the importance of understanding ctypes' functionality.
---

```

The fact that standard Python has a frozen module and a frozen package (indicated by the negative `size` member) is not well known, it is only used for testing. Try it out with `import __hello__` for example.
### Surprises[¶](https://docs.python.org/3/library/ctypes.html#surprises "Link to this heading")
There are some edges in [`ctypes`](https://docs.python.org/3/library/ctypes.html#module-ctypes "ctypes: A foreign function library for Python.") where you might expect something other than what actually happens.
Consider the following example:
>>>```
>>> fromctypesimport *
>>> classPOINT(Structure):
...   _fields_ = ("x", c_int), ("y", c_int)
...
>>> classRECT(Structure):
...   _fields_ = ("a", POINT), ("b", POINT)
...
>>> p1 = POINT(1, 2)
>>> p2 = POINT(3, 4)
>>> rc = RECT(p1, p2)
>>> print(rc.a.x, rc.a.y, rc.b.x, rc.b.y)
1 2 3 4
>>> # now swap the two points
>>> rc.a, rc.b = rc.b, rc.a
>>> print(rc.a.x, rc.a.y, rc.b.x, rc.b.y)
3 4 3 4
>>>

```

Hm. We certainly expected the last statement to print `3 4 1 2`. What happened? Here are the steps of the `rc.a, rc.b = rc.b, rc.a` line above:
>>>```
>>> temp0, temp1 = rc.b, rc.a
>>> rc.a = temp0
>>> rc.b = temp1
>>>

```

Note that `temp0` and `temp1` are objects still using the internal buffer of the `rc` object above. So executing `rc.a = temp0` copies the buffer contents of `temp0` into `rc` ‘s buffer. This, in turn, changes the contents of `temp1`. So, the last assignment `rc.b = temp1`, doesn’t have the expected effect.
Keep in mind that retrieving sub-objects from Structure, Unions, and Arrays doesn’t _copy_ the sub-object, instead it retrieves a wrapper object accessing the root-object’s underlying buffer.
Another example that may behave differently from what one would expect is this:
>>>```
>>> s = c_char_p()
>>> s.value = b"abc def ghi"
>>> s.value
b'abc def ghi'
>>> s.value is s.value
False
>>>

```

Note
Objects instantiated from [`c_char_p`](https://docs.python.org/3/library/ctypes.html#ctypes.c_char_p "ctypes.c_char_p") can only have their value set to bytes or integers.
Why is it printing `False`? ctypes instances are objects containing a memory block plus some [descriptor](https://docs.python.org/3/glossary.html#term-descriptor)s accessing the contents of the memory. Storing a Python object in the memory block does not store the object itself, instead the `contents` of the object is stored. Accessing the contents again constructs a new Python object each time!
### Variable-sized data types[¶](https://docs.python.org/3/library/ctypes.html#variable-sized-data-types "Link to this heading")
[`ctypes`](https://docs.python.org/3/library/ctypes.html#module-ctypes "ctypes: A foreign function library for Python.") provides some support for variable-sized arrays and structures.
The [`resize()`](https://docs.python.org/3/library/ctypes.html#ctypes.resize "ctypes.resize") function can be used to resize the memory buffer of an existing ctypes object. The function takes the object as first argument, and the requested size in bytes as the second argument. The memory block cannot be made smaller than the natural memory block specified by the objects type, a [`ValueError`](https://docs.python.org/3/library/exceptions.html#ValueError "ValueError") is raised if this is tried:
>>>```
>>> short_array = (c_short * 4)()
>>> print(sizeof(short_array))
8
>>> resize(short_array, 4)
Traceback (most recent call last):
...
ValueError: minimum size is 8
>>> resize(short_array, 32)
>>> sizeof(short_array)
32
>>> sizeof(type(short_array))
8
>>>

```

This is nice and fine, but how would one access the additional elements contained in this array? Since the type still only knows about 4 elements, we get errors accessing other elements:
>>>```
>>> short_array[:]
[0, 0, 0, 0]
>>> short_array[7]
Traceback (most recent call last):
...
IndexError: invalid index
>>>