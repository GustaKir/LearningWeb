Title: Compiling Regular Expressions
URL: https://docs.python.org/3/howto/regex.html
Summary: Regular expressions in Python are compiled into pattern objects using the `re.compile()` method, which allows for searching and string substitutions. The method can accept an optional _flags_ argument to enable special features, such as `re.IGNORECASE`, and regular expressions are represented as strings since they are not part of the core Python syntax.
---

ith them.
### Compiling Regular Expressions[¶](https://docs.python.org/3/howto/regex.html#compiling-regular-expressions "Link to this heading")
Regular expressions are compiled into pattern objects, which have methods for various operations such as searching for pattern matches or performing string substitutions.
>>>```
>>> importre
>>> p = re.compile('ab*')
>>> p
re.compile('ab*')

```

[`re.compile()`](https://docs.python.org/3/library/re.html#re.compile "re.compile") also accepts an optional _flags_ argument, used to enable various special features and syntax variations. We’ll go over the available settings later, but for now a single example will do:
>>>```
>>> p = re.compile('ab*', re.IGNORECASE)

```

The RE is passed to [`re.compile()`](https://docs.python.org/3/library/re.html#re.compile "re.compile") as a string. REs are handled as strings because regular expressions aren’t part of the core Python language, and no special syntax was created for expressing them. (There are applications that don’t need REs at all, so there’s no need to bloat the language specification by including them.) Instead, the [`re`](https://docs.python.org/3/library/re.html#module-re "re: Regular expression operations.") module is simply a C extension module included with Python, just like the [`socket`](https://docs.python.org/3/library/socket.html#module-socket "socket: Low-level networking interface.") or [`zlib`](https://docs.python.org/3/library/zlib.html#module-zlib "zlib: Low-level interface to compression and decompression routines compatible with gzip.") modules.
Putting REs in strings keeps the Python language simpler, but has one disadvantage which is the topic of the next section.
### The Backslash Plague[¶](https://docs.python.org/3/howto/regex.html#the-backslash-plague "Link to this heading")
As stated earlier, regular expressions use the backslash character (`'\'`) to indicate special forms or to allow special characters to be used without invoking their special meaning. This conflicts with Python’s usage of the same character for the same purpose in string literals.
Let’s say you want to write a RE that matches the string `\section`, which might be found in a LaTeX file. To figure out what to write in the program code, start with the desired string to be matched. Next, you must escape any backslashes and other metacharacters by preceding them with a backslash, resulting in the string `\\section`. The resulting string that must be passed to [`re.compile()`](https://docs.python.org/3/library/re.html#re.compile "re.compile") must be `\\section`. However, to express this as a Python string literal, both backslashes must be escaped _again_.
Characters | Stage  
---|---  
`\section` | Text string to be matched  
`\\section` | Escaped backslash for [`re.compile()`](https://docs.python.org/3/library/re.html#re.compile "re.compile")  
`"\\\\section"` | Escaped backslashes for a string literal  
In short, to match a literal backslash, one has to write `'\\\\'` as the RE string, because the regular expression must be `\\`, and each backslash must be expressed as `\\` inside a regular Python string literal. In REs that feature backslashes repeatedly, this leads to lots of repeated backslashes and makes the resulting strings difficult to understand.
The solution is to use Python’s raw string notation for regular expressions; backslashes are not handled in any special way in a string literal prefixed with `'r'`, so `r"\n"` is a two-character string containing `'\'` and `'n'`, while `"\n"` is a one-character string containing a newline. Regular expressions will often be written in Python code using this raw string notation.
In addition, special escape sequences that are valid in regular expressions, but not valid as Python string literals, now result in a [`DeprecationWarning`](https://docs.python.org/3/library/exceptions.html#DeprecationWarning "DeprecationWarning") and will eventually become a [`SyntaxError`](https://docs.python.org/3/library/exceptions.html#SyntaxError "SyntaxError"), which means the sequences will be invalid if raw string notation or escaping the backslashes isn’t used.
Regular String | Raw string  
---|---  
`"ab*"` | `r"ab*"`  
`"\\\\section"` | `r"\\section"`  
`"\\w+\\s+\\1"` | `r"\w+\s+\1"`  
### Performing Matches[¶](https://docs.python.org/3/howto/regex.html#performing-matches "Link to this heading")
Once you have an object representing a compiled regular expression, what do you do with it? Pattern objects have several methods and attributes. Only the most significant ones will be covered here; consult the [`re`](https://docs.python.org/3/library/re.html#module-re "re: Regular expression operations.") docs for a complete listing.
Method/Attribute | Purpose  
---|---  
`match()` | Determine if the RE matches at the beginning of the string.  
`search()` | Scan through a string, looking for any location where this RE matches.  
`findall()` | Find all substrings where the RE matches, and returns them