Title: Header Source Parsing in Email Policy
URL: https://docs.python.org/3/library/email.policy.html
Summary: This document section describes the `header_source_parse` method in the email package, detailing how it processes a list of strings representing email headers. It outlines the expectations for the returned tuple of `(name, value)`, the preservation of whitespace, and compatibility considerations with existing email policies.
---

header_source_parse(_sourcelines_)[¶](https://docs.python.org/3/library/email.policy.html#email.policy.Policy.header_source_parse "Link to this definition")
    
The email package calls this method with a list of strings, each string ending with the line separation characters found in the source being parsed. The first line includes the field header name and separator. All whitespace in the source is preserved. The method should return the `(name, value)` tuple that is to be stored in the `Message` to represent the parsed header.
If an implementation wishes to retain compatibility with the existing email package policies, _name_ should be the case preserved name (all characters up to the ‘`:`’ separator), while _value_ should be the unfolded value (all line separator characters removed, but whitespace kept intact), stripped of leading whitespace.
_sourcelines_ may contain surrogateescaped binary data.
There is no default implementation 

header_store_parse(_name_ , _value_)[¶](https://docs.python.org/3/library/email.policy.html#email.policy.Policy.header_store_parse "Link to this definition")
    
The email package calls this method with the name and value provided by the application program when the application program is modifying a `Message` programmatically (as opposed to a `Message` created by a parser). The method should return the `(name, value)` tuple that is to be stored in the `Message` to represent the header.
If an implementation wishes to retain compatibility with the existing email package policies, the _name_ and _value_ should be strings or string subclasses that do not change the content of the passed in arguments.
There is no default implementation 

header_fetch_parse(_name_ , _value_)[¶](https://docs.python.org/3/library/email.policy.html#email.policy.Policy.header_fetch_parse "Link to this definition")
    
The email package calls this method with the _name_ and _value_ currently stored in the `Message` when that header is requested by the application program, and whatever the method returns is what is passed back to the application as the value of the header being retrieved. Note that there may be more than one header with the same name stored in the `Message`; the method is passed the specific name and value of the header destined to be returned to the application.
_value_ may contain surrogateescaped binary data. There should be no surrogateescaped binary data in the value returned by the method.
There is no default implementation 

fold(_name_ , _value_)[¶](https://docs.python.org/3/library/email.policy.html#email.policy.Policy.fold "Link to this definition")
    
The email package calls this method with the _name_ and _value_ currently stored in the `Message` for a given header. The method should return a string that represents that header “folded” correctly (according to the policy settings) by composing the _name_ with the _value_ and inserting [`linesep`](https://docs.python.org/3/library/email.policy.html#email.policy.Policy.linesep "email.policy.Policy.linesep") characters at the appropriate places. See [**RFC 5322**](https://datatracker.ietf.org/doc/html/rfc5322.html) for a discussion of the rules for folding email headers.
_value_ may contain surrogateescaped binary data. There should be no surrogateescaped binary data in the string returned by the method. 

fold_binary(_name_ , _value_)[¶](https://docs.python.org/3/library/email.policy.html#email.policy.Policy.fold_binary "Link to this definition")
    
The same as [`fold()`](https://docs.python.org/3/library/email.policy.html#email.policy.Policy.fold "email.policy.Policy.fold"), except that the returned value should be a bytes object rather than a string.
_value_ may contain surrogateescaped binary data. These could be converted back into binary data in the returned bytes object.