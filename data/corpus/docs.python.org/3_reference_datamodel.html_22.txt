Title: Slice Object Indices and Static Method Objects
URL: https://docs.python.org/3/reference/datamodel.html
Summary: The 'slice.indices' method computes the start, stop, and step indices for a slice applied to a sequence of a given length, managing out-of-bounds indices like regular slicing. Additionally, static method objects prevent the automatic transformation of function objects into method objects, serving as wrappers around user-defined methods.
---

slice.indices(_self_ , _length_)[¶](https://docs.python.org/3/reference/datamodel.html#slice.indices "Link to this definition")
    
This method takes a single integer argument _length_ and computes information about the slice that the slice object would describe if applied to a sequence of _length_ items. It returns a tuple of three integers; respectively these are the _start_ and _stop_ indices and the _step_ or stride length of the slice. Missing or out-of-bounds indices are handled in a manner consistent with regular slices.
#### 3.2.13.5. Static method objects[¶](https://docs.python.org/3/reference/datamodel.html#static-method-objects "Link to this heading")
Static method objects provide a way of defeating the transformation of function objects to method objects described above. A static method object is a wrapper around any other object, usually a user-defined method object. When a static method object is retrieved from a class or a class instance, the object actually returned is the wrapped object, which is not subject to any further transformation. Static method objects are also callable. Static method objects are created by the built-in [`staticmethod()`](https://docs.python.org/3/library/functions.html#staticmethod "staticmethod") constructor.
#### 3.2.13.6. Class method objects[¶](https://docs.python.org/3/reference/datamodel.html#class-method-objects "Link to this heading")
A class method object, like a static method object, is a wrapper around another object that alters the way in which that object is retrieved from classes and class instances. The behaviour of class method objects upon such retrieval is described above, under [“instance methods”](https://docs.python.org/3/reference/datamodel.html#instance-methods). Class method objects are created by the built-in [`classmethod()`](https://docs.python.org/3/library/functions.html#classmethod "classmethod") constructor.
## 3.3. Special method names[¶](https://docs.python.org/3/reference/datamodel.html#special-method-names "Link to this heading")
A class can implement certain operations that are invoked by special syntax (such as arithmetic operations or subscripting and slicing) by defining methods with special names. This is Python’s approach to _operator overloading_ , allowing classes to define their own behavior with respect to language operators. For instance, if a class defines a method named [`__getitem__()`](https://docs.python.org/3/reference/datamodel.html#object.__getitem__ "object.__getitem__"), and `x` is an instance of this class, then `x[i]` is roughly equivalent to `type(x).__getitem__(x, i)`. Except where mentioned, attempts to execute an operation raise an exception when no appropriate method is defined (typically [`AttributeError`](https://docs.python.org/3/library/exceptions.html#AttributeError "AttributeError") or [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError "TypeError")).
Setting a special method to `None` indicates that the corresponding operation is not available. For example, if a class sets [`__iter__()`](https://docs.python.org/3/reference/datamodel.html#object.__iter__ "object.__iter__") to `None`, the class is not iterable, so calling [`iter()`](https://docs.python.org/3/library/functions.html#iter "iter") on its instances will raise a [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError "TypeError") (without falling back to [`__getitem__()`](https://docs.python.org/3/reference/datamodel.html#object.__getitem__ "object.__getitem__")). [[2]](https://docs.python.org/3/reference/datamodel.html#id20)
When implementing a class that emulates any built-in type, it is important that the emulation only be implemented to the degree that it makes sense for the object being modelled. For example, some sequences may work well with retrieval of individual elements, but extracting a slice may not make sense. (One example of this is the `NodeList` interface in the W3C’s Document Object Model.)
### 3.3.1. Basic customization[¶](https://docs.python.org/3/reference/datamodel.html#basic-customization "Link to this heading")