Title: Introduction to Multi-Paradigm Programming in Python
URL: https://docs.python.org/3/howto/functional.html
Summary: This section discusses the flexibility of multi-paradigm languages like Python, which allow for procedural, object-oriented, and functional programming styles. It emphasizes the functional programming approach, where input is processed through functions that avoid side effects, promoting purely functional programming.
---

The designers of some computer languages choose to emphasize one particular approach to programming. This often makes it difficult to write programs that use a different approach. Other languages are multi-paradigm languages that support several different approaches. Lisp, C++, and Python are multi-paradigm; you can write programs or libraries that are largely procedural, object-oriented, or functional in all of these languages. In a large program, different sections might be written using different approaches; the GUI might be object-oriented while the processing logic is procedural or functional, for example.
In a functional program, input flows through a set of functions. Each function operates on its input and produces some output. Functional style discourages functions with side effects that modify internal state or make other changes that aren’t visible in the function’s return value. Functions that have no side effects at all are called **purely functional**. Avoiding side effects means not using data structures that get updated as a program runs; every function’s output must only depend on its input.
Some languages are very strict about purity and don’t even have assignment statements such as `a=3` or `c = a + b`, but it’s difficult to avoid all side effects, such as printing to the screen or writing to a disk file. Another example is a call to the [`print()`](https://docs.python.org/3/library/functions.html#print "print") or [`time.sleep()`](https://docs.python.org/3/library/time.html#time.sleep "time.sleep") function, neither of which returns a useful value. Both are called only for their side effects of sending some text to the screen or pausing execution for a second.
Python programs written in functional style usually won’t go to the extreme of avoiding all I/O or all assignments; instead, they’ll provide a functional-appearing interface but will use non-functional features internally. For example, the implementation of a function will still use assignments to local variables, but won’t modify global variables or have other side effects.
Functional programming can be considered the opposite of object-oriented programming. Objects are little capsules containing some internal state along with a collection of method calls that let you modify this state, and programs consist of making the right set of state changes. Functional programming wants to avoid state changes as much as possible and works with data flowing between functions. In Python you might combine the two approaches by writing functions that take and return instances representing objects in your application (e-mail messages, transactions, etc.).
Functional design may seem like an odd constraint to work under. Why should you avoid objects and side effects? There are theoretical and practical advantages to the functional style:
  * Formal provability.
  * Modularity.
  * Composability.
  * Ease of debugging and testing.