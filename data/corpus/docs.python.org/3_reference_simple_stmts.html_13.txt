Title: Nonlocal Statement in Python
URL: https://docs.python.org/3/reference/simple_stmts.html
Summary: The `nonlocal` statement allows nested functions to refer to and rebind identifiers defined in the nonlocal scopes of enclosing functions. If a name is found in multiple such scopes, the closest binding is used. A `SyntaxError` occurs if the name is not bound in any nonlocal scope.
---

```
**nonlocal_stmt** ::= "nonlocal" [identifier](https://docs.python.org/3/reference/lexical_analysis.html#grammar-token-python-grammar-identifier) ("," [identifier](https://docs.python.org/3/reference/lexical_analysis.html#grammar-token-python-grammar-identifier))*

```

When the definition of a function or class is nested (enclosed) within the definitions of other functions, its nonlocal scopes are the local scopes of the enclosing functions. The [`nonlocal`](https://docs.python.org/3/reference/simple_stmts.html#nonlocal) statement causes the listed identifiers to refer to names previously bound in nonlocal scopes. It allows encapsulated code to rebind such nonlocal identifiers. If a name is bound in more than one nonlocal scope, the nearest binding is used. If a name is not bound in any nonlocal scope, or if there is no nonlocal scope, a [`SyntaxError`](https://docs.python.org/3/library/exceptions.html#SyntaxError "SyntaxError") is raised.
The [`nonlocal`](https://docs.python.org/3/reference/simple_stmts.html#nonlocal) statement applies to the entire scope of a function or class body. A [`SyntaxError`](https://docs.python.org/3/library/exceptions.html#SyntaxError "SyntaxError") is raised if a variable is used or assigned to prior to its nonlocal declaration in the scope.
See also 

[**PEP 3104**](https://peps.python.org/pep-3104/) - Access to Names in Outer Scopes
    
The specification for the [`nonlocal`](https://docs.python.org/3/reference/simple_stmts.html#nonlocal) statement.
**Programmer’s note:** [`nonlocal`](https://docs.python.org/3/reference/simple_stmts.html#nonlocal) is a directive to the parser and applies only to code parsed along with it. See the note for the [`global`](https://docs.python.org/3/reference/simple_stmts.html#global) statement.
## 7.14. The `type` statement[¶](https://docs.python.org/3/reference/simple_stmts.html#the-type-statement "Link to this heading")
```
**type_stmt** ::= 'type' [identifier](https://docs.python.org/3/reference/lexical_analysis.html#grammar-token-python-grammar-identifier) [[type_params](https://docs.python.org/3/reference/compound_stmts.html#grammar-token-python-grammar-type_params)] "=" [expression](https://docs.python.org/3/reference/expressions.html#grammar-token-python-grammar-expression)

```

The `type` statement declares a type alias, which is an instance of [`typing.TypeAliasType`](https://docs.python.org/3/library/typing.html#typing.TypeAliasType "typing.TypeAliasType").
For example, the following statement creates a type alias:
```
type Point = tuple[float, float]

```

This code is roughly equivalent to:
```
annotation-defVALUE_OF_Point():
  return tuple[float, float]
Point = typing.TypeAliasType("Point", VALUE_OF_Point())