Title: Dataclass Methods and Creation
URL: https://docs.python.org/3/library/dataclasses.html
Summary: The `astuple()` method raises a TypeError if the object is not a dataclass instance. The `dataclasses.make_dataclass` function is used to create a new dataclass with a specified name, fields, base classes, and optional attributes like initialization and representation methods.
---

```

`astuple()` raises [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError "TypeError") if _obj_ is not a dataclass instance. 

dataclasses.make_dataclass(_cls_name_ , _fields_ , _*_ , _bases =()_, _namespace =None_, _init =True_, _repr =True_, _eq =True_, _order =False_, _unsafe_hash =False_, _frozen =False_, _match_args =True_, _kw_only =False_, _slots =False_, _weakref_slot =False_, _module =None_)[¶](https://docs.python.org/3/library/dataclasses.html#dataclasses.make_dataclass "Link to this definition")
    
Creates a new dataclass with name _cls_name_ , fields as defined in _fields_ , base classes as given in _bases_ , and initialized with a namespace as given in _namespace_. _fields_ is an iterable whose elements are each either `name`, `(name, type)`, or `(name, type, Field)`. If just `name` is supplied, [`typing.Any`](https://docs.python.org/3/library/typing.html#typing.Any "typing.Any") is used for `type`. The values of _init_ , _repr_ , _eq_ , _order_ , _unsafe_hash_ , _frozen_ , _match_args_ , _kw_only_ , _slots_ , and _weakref_slot_ have the same meaning as they do in [`@dataclass`](https://docs.python.org/3/library/dataclasses.html#dataclasses.dataclass "dataclasses.dataclass").
If _module_ is defined, the `__module__` attribute of the dataclass is set to that value. By default, it is set to the module name of the caller.
This function is not strictly required, because any Python mechanism for creating a new class with `__annotations__` can then apply the [`@dataclass`](https://docs.python.org/3/library/dataclasses.html#dataclasses.dataclass "dataclasses.dataclass") function to convert that class to a dataclass. This function is provided as a convenience. For example:
```
C = make_dataclass('C',
          [('x', int),
           'y',
          ('z', int, field(default=5))],
          namespace={'add_one': lambda self: self.x + 1})

```

Is equivalent to:
```
@dataclass
classC:
  x: int
  y: 'typing.Any'
  z: int = 5
  defadd_one(self):
    return self.x + 1

```


dataclasses.replace(_obj_ , _/_ , _** changes_)[¶](https://docs.python.org/3/library/dataclasses.html#dataclasses.replace "Link to this definition")
    
Creates a new object of the same type as _obj_ , replacing fields with values from _changes_. If _obj_ is not a Data Class, raises [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError "TypeError"). If keys in _changes_ are not field names of the given dataclass, raises [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError "TypeError").
The newly returned object is created by calling the [`__init__()`](https://docs.python.org/3/reference/datamodel.html#object.__init__ "object.__init__") method of the dataclass. This ensures that [`__post_init__()`](https://docs.python.org/3/library/dataclasses.html#dataclasses.__post_init__ "dataclasses.__post_init__"), if present, is also called.
Init-only variables without default values, if any exist, must be specified on the call to `replace()` so that they can be passed to `__init__()` and [`__post_init__()`](https://docs.python.org/3/library/dataclasses.html#dataclasses.__post_init__ "dataclasses.__post_init__").
It is an error for _changes_ to contain any fields that are defined as having `init=False`. A [`ValueError`](https://docs.python.org/3/library/exceptions.html#ValueError "ValueError") will be raised in this case.
Be forewarned about how `init=False` fields work during a call to `replace()`. They are not copied from the source object, but rather are initialized in [`__post_init__()`](https://docs.python.org/3/library/dataclasses.html#dataclasses.__post_init__ "dataclasses.__post_init__"), if they’re initialized at all. It is expected that `init=False` fields will be rarely and judiciously used. If they are used, it might be wise to have alternate class constructors, or perhaps a custom `replace()` (or similarly named) method which handles instance copying.
Dataclass instances are also supported by generic function [`copy.replace()`](https://docs.python.org/3/library/copy.html#copy.replace "copy.replace"). 

dataclasses.is_dataclass(_obj_)[¶](https://docs.python.org/3/library/dataclasses.html#dataclasses.is_dataclass "Link to this definition")
    
Return `True` if its parameter is a dataclass (including subclasses of a dataclass) or an instance of one, otherwise return `False`.
If you need to know if a class is an instance of a dataclass (and not a dataclass itself), then add a further check for `not isinstance(obj, type)`:
```
defis_dataclass_instance(obj):
  return is_dataclass(obj) and not isinstance(obj, type)