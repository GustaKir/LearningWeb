Title: Python Floating-Point Precision and String Immutability
URL: https://docs.python.org/3/faq/design.html
Summary: Python floats provide a typical precision of 53 bits, translating to 15–16 decimal digits of accuracy. Additionally, strings in Python are immutable, which enhances performance by allowing fixed storage allocation and aligning their treatment as elemental values, similar to numbers.
---

```

The typical precision of 53 bits provides Python floats with 15–16 decimal digits of accuracy.
For a fuller explanation, please see the [floating-point arithmetic](https://docs.python.org/3/tutorial/floatingpoint.html#tut-fp-issues) chapter in the Python tutorial.
## [Why are Python strings immutable?](https://docs.python.org/3/faq/design.html#id6)[¶](https://docs.python.org/3/faq/design.html#why-are-python-strings-immutable "Link to this heading")
There are several advantages.
One is performance: knowing that a string is immutable means we can allocate space for it at creation time, and the storage requirements are fixed and unchanging. This is also one of the reasons for the distinction between tuples and lists.
Another advantage is that strings in Python are considered as “elemental” as numbers. No amount of activity will change the value 8 to anything else, and in Python, no amount of activity will change the string “eight” to anything else.
## [Why must ‘self’ be used explicitly in method definitions and calls?](https://docs.python.org/3/faq/design.html#id7)[¶](https://docs.python.org/3/faq/design.html#why-must-self-be-used-explicitly-in-method-definitions-and-calls "Link to this heading")
The idea was borrowed from Modula-3. It turns out to be very useful, for a variety of reasons.
First, it’s more obvious that you are using a method or instance attribute instead of a local variable. Reading `self.x` or `self.meth()` makes it absolutely clear that an instance variable or method is used even if you don’t know the class definition by heart. In C++, you can sort of tell by the lack of a local variable declaration (assuming globals are rare or easily recognizable) – but in Python, there are no local variable declarations, so you’d have to look up the class definition to be sure. Some C++ and Java coding standards call for instance attributes to have an `m_` prefix, so this explicitness is still useful in those languages, too.
Second, it means that no special syntax is necessary if you want to explicitly reference or call the method from a particular class. In C++, if you want to use a method from a base class which is overridden in a derived class, you have to use the `::` operator – in Python you can write `baseclass.methodname(self, <argument list>)`. This is particularly useful for [`__init__()`](https://docs.python.org/3/reference/datamodel.html#object.__init__ "object.__init__") methods, and in general in cases where a derived class method wants to extend the base class method of the same name and thus has to call the base class method somehow.
Finally, for instance variables it solves a syntactic problem with assignment: since local variables in Python are (by definition!) those variables to which a value is assigned in a function body (and that aren’t explicitly declared global), there has to be some way to tell the interpreter that an assignment was meant to assign to an instance variable instead of to a local variable, and it should preferably be syntactic (for efficiency reasons). C++ does this through declarations, but Python doesn’t have declarations and it would be a pity having to introduce them just for this purpose. Using the explicit `self.var` solves this nicely. Similarly, for using instance variables, having to write `self.var` means that references to unqualified names inside a method don’t have to search the instance’s directories. To put it another way, local variables and instance variables live in two different namespaces, and you need to tell Python which namespace to use.
## [Why can’t I use an assignment in an expression?](https://docs.python.org/3/faq/design.html#id8)[¶](https://docs.python.org/3/faq/design.html#why-can-t-i-use-an-assignment-in-an-expression "Link to this heading")
Starting in Python 3.8, you can!
Assignment expressions using the walrus operator `:=` assign a variable in an expression:
```
while chunk := fp.read(200):
  print(chunk)