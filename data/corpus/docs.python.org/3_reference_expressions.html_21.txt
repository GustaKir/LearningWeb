Title: Comparisons in Python
URL: https://docs.python.org/3/reference/expressions.html
Summary: This section describes how comparisons in Python yield boolean values (True or False) and discusses custom rich comparison methods that may return non-boolean values, which are then converted to boolean using the bool() function. It explains the chaining of comparisons and the evaluation of expressions, highlighting that each expression is evaluated at most once. It also mentions that chained comparisons do not imply direct comparisons between non-adjacent expressions.
---

```

Comparisons yield boolean values: `True` or `False`. Custom _rich comparison methods_ may return non-boolean values. In this case Python will call [`bool()`](https://docs.python.org/3/library/functions.html#bool "bool") on such value in boolean contexts.
Comparisons can be chained arbitrarily, e.g., `x < y <= z` is equivalent to `x < y and y <= z`, except that `y` is evaluated only once (but in both cases `z` is not evaluated at all when `x < y` is found to be false).
Formally, if _a_ , _b_ , _c_ , …, _y_ , _z_ are expressions and _op1_ , _op2_ , …, _opN_ are comparison operators, then `a op1 b op2 c ... y opN z` is equivalent to `a op1 b and b op2 c and ... y opN z`, except that each expression is evaluated at most once.
Note that `a op1 b op2 c` doesn’t imply any kind of comparison between _a_ and _c_ , so that, e.g., `x < y > z` is perfectly legal (though perhaps not pretty).
### 6.10.1. Value comparisons[¶](https://docs.python.org/3/reference/expressions.html#value-comparisons "Link to this heading")
The operators `<`, `>`, `==`, `>=`, `<=`, and `!=` compare the values of two objects. The objects do not need to have the same type.
Chapter [Objects, values and types](https://docs.python.org/3/reference/datamodel.html#objects) states that objects have a value (in addition to type and identity). The value of an object is a rather abstract notion in Python: For example, there is no canonical access method for an object’s value. Also, there is no requirement that the value of an object should be constructed in a particular way, e.g. comprised of all its data attributes. Comparison operators implement a particular notion of what the value of an object is. One can think of them as defining the value of an object indirectly, by means of their comparison implementation.
Because all types are (direct or indirect) subtypes of [`object`](https://docs.python.org/3/library/functions.html#object "object"), they inherit the default comparison behavior from [`object`](https://docs.python.org/3/library/functions.html#object "object"). Types can customize their comparison behavior by implementing _rich comparison methods_ like [`__lt__()`](https://docs.python.org/3/reference/datamodel.html#object.__lt__ "object.__lt__"), described in [Basic customization](https://docs.python.org/3/reference/datamodel.html#customization).
The default behavior for equality comparison (`==` and `!=`) is based on the identity of the objects. Hence, equality comparison of instances with the same identity results in equality, and equality comparison of instances with different identities results in inequality. A motivation for this default behavior is the desire that all objects should be reflexive (i.e. `x is y` implies `x == y`).
A default order comparison (`<`, `>`, `<=`, and `>=`) is not provided; an attempt raises [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError "TypeError"). A motivation for this default behavior is the lack of a similar invariant as for equality.
The behavior of the default equality comparison, that instances with different identities are always unequal, may be in contrast to what types will need that have a sensible definition of object value and value-based equality. Such types will need to customize their comparison behavior, and in fact, a number of built-in types have done that.
The following list describes the comparison behavior of the most important built-in types.
  * Numbers of built-in numeric types ([Numeric Types — int, float, complex](https://docs.python.org/3/library/stdtypes.html#typesnumeric)) and of the standard library types [`fractions.Fraction`](https://docs.python.org/3/library/fractions.html#fractions.Fraction "fractions.Fraction") and [`decimal.Decimal`](https://docs.python.org/3/library/decimal.html#decimal.Decimal "decimal.Decimal") can be compared within and across their types, with the restriction that complex numbers do not support order comparison. Within the limits of the types involved, they compare mathematically (algorithmically) correct without loss of precision.
The not-a-number values `float('NaN')` and `decimal.Decimal('NaN')` are special. Any ordered comparison of a number to a not-a-number value is false. A counter-intuitive implication is that not-a-number values are not equal to themselves. For example, if `x = float('NaN')`, `3 < x`, `x < 3` and `x == x` are all false, while `x != x` is true. This behavior is compliant with IEEE 754.
  * `None` and [`NotImplemented`](https://docs.python.org/3/library/constants.html#NotImplemented "NotImplemented") are singletons. [**PEP 8**](https://peps.python.org/pep-0008/) advises that comparisons for singletons should always be done with `is` or `is not`, never the equality operators.
  * Binary sequences (instances of [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "bytes") or [`bytearray`](https://docs.python.org/3/library/stdtypes.html#bytearray "bytearray")) can be compared within and across