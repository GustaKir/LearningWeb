Title: AST Module: Unparse and Literal Evaluation
URL: https://docs.python.org/3/library/ast.html
Summary: The `ast.unparse()` function generates a code string from an `ast.AST` object, which can recreate the equivalent `ast.AST` when parsed with `ast.parse()`. However, the resulting code may differ from the original source due to compiler optimizations, and complex expressions may cause a `RecursionError`. This functionality was introduced in Python 3.9.
---

ast.unparse(_ast_obj_)[¶](https://docs.python.org/3/library/ast.html#ast.unparse "Link to this definition")
    
Unparse an [`ast.AST`](https://docs.python.org/3/library/ast.html#ast.AST "ast.AST") object and generate a string with code that would produce an equivalent [`ast.AST`](https://docs.python.org/3/library/ast.html#ast.AST "ast.AST") object if parsed back with [`ast.parse()`](https://docs.python.org/3/library/ast.html#ast.parse "ast.parse").
Warning
The produced code string will not necessarily be equal to the original code that generated the [`ast.AST`](https://docs.python.org/3/library/ast.html#ast.AST "ast.AST") object (without any compiler optimizations, such as constant tuples/frozensets).
Warning
Trying to unparse a highly complex expression would result with [`RecursionError`](https://docs.python.org/3/library/exceptions.html#RecursionError "RecursionError").
Added in version 3.9. 

ast.literal_eval(_node_or_string_)[¶](https://docs.python.org/3/library/ast.html#ast.literal_eval "Link to this definition")
    
Evaluate an expression node or a string containing only a Python literal or container display. The string or node provided may only consist of the following Python literal structures: strings, bytes, numbers, tuples, lists, dicts, sets, booleans, `None` and `Ellipsis`.
This can be used for evaluating strings containing Python values without the need to parse the values oneself. It is not capable of evaluating arbitrarily complex expressions, for example involving operators or indexing.
This function had been documented as “safe” in the past without defining what that meant. That was misleading. This is specifically designed not to execute Python code, unlike the more general [`eval()`](https://docs.python.org/3/library/functions.html#eval "eval"). There is no namespace, no name lookups, or ability to call out. But it is not free from attack: A relatively small input can lead to memory exhaustion or to C stack exhaustion, crashing the process. There is also the possibility for excessive CPU consumption denial of service on some inputs. Calling it on untrusted data is thus not recommended.
Warning
It is possible to crash the Python interpreter due to stack depth limitations in Python’s AST compiler.
It can raise [`ValueError`](https://docs.python.org/3/library/exceptions.html#ValueError "ValueError"), [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError "TypeError"), [`SyntaxError`](https://docs.python.org/3/library/exceptions.html#SyntaxError "SyntaxError"), [`MemoryError`](https://docs.python.org/3/library/exceptions.html#MemoryError "MemoryError") and [`RecursionError`](https://docs.python.org/3/library/exceptions.html#RecursionError "RecursionError") depending on the malformed input.
Changed in version 3.2: Now allows bytes and set literals.
Changed in version 3.9: Now supports creating empty sets with `'set()'`.
Changed in version 3.10: For string inputs, leading spaces and tabs are now stripped. 

ast.get_docstring(_node_ , _clean =True_)[¶](https://docs.python.org/3/library/ast.html#ast.get_docstring "Link to this definition")
    
Return the docstring of the given _node_ (which must be a [`FunctionDef`](https://docs.python.org/3/library/ast.html#ast.FunctionDef "ast.FunctionDef"), [`AsyncFunctionDef`](https://docs.python.org/3/library/ast.html#ast.AsyncFunctionDef "ast.AsyncFunctionDef"), [`ClassDef`](https://docs.python.org/3/library/ast.html#ast.ClassDef "ast.ClassDef"), or [`Module`](https://docs.python.org/3/library/ast.html#ast.Module "ast.Module") node), or `None` if it has no docstring. If _clean_ is true, clean up the docstring’s indentation with [`inspect.cleandoc()`](https://docs.python.org/3/library/inspect.html#inspect.cleandoc "inspect.cleandoc").
Changed in version 3.5: [`AsyncFunctionDef`](https://docs.python.org/3/library/ast.html#ast.AsyncFunctionDef "ast.AsyncFunctionDef") is now supported. 

ast.get_source_segment(_source_ , _node_ , _*_ , _padded =False_)[¶](https://docs.python.org/3/library/ast.html#ast.get_source_segment "Link to this definition")
    
Get source code segment of the _source_ that generated _node_. If some location information ([`lineno`](https://docs.python.org/3/library/ast.html#ast.AST.lineno "ast.AST.lineno"), [`end_lineno`](https://docs.python.org/3/library/ast.html#ast.AST.end_lineno "ast.AST.end_lineno"), [`col_offset`](https://docs.python.org/3/library/ast.html#ast.AST.col_offset "ast.AST.col_offset"), or [`end_col_offset`](https://docs.python.org/3/library/ast.html#ast.AST.end_col_offset "ast.AST.end_col_offset")) is missing, return `None`.
If _padded_ is `True`, the first line of a multi-line statement will be padded with spaces to match its original position.
Added in version 3.8.