Title: Sending Email with Attachments using Python's Email Package
URL: https://docs.python.org/3/library/email.examples.html
Summary: This example demonstrates how to create and send an email message with attachments using Python's 'smtplib' and 'email.message.EmailMessage'. It sets the subject, sender, and recipients, attaches image files from a directory, and sends the email via an SMTP server.
---

```
# Import smtplib for the actual sending function.
importsmtplib
# Here are the email package modules we'll need.
fromemail.messageimport EmailMessage
# Create the container email message.
msg = EmailMessage()
msg['Subject'] = 'Our family reunion'
# me == the sender's email address
# family = the list of all recipients' email addresses
msg['From'] = me
msg['To'] = ', '.join(family)
msg.preamble = 'You will not see this in a MIME-aware mail reader.\n'
# Open the files in binary mode. You can also omit the subtype
# if you want MIMEImage to guess it.
for file in pngfiles:
  with open(file, 'rb') as fp:
    img_data = fp.read()
  msg.add_attachment(img_data, maintype='image',
                 subtype='png')
# Send the email via our own SMTP server.
with smtplib.SMTP('localhost') as s:
  s.send_message(msg)

```

Here’s an example of how to send the entire contents of a directory as an email message: [[1]](https://docs.python.org/3/library/email.examples.html#id3)
```
#!/usr/bin/env python3
"""Send the contents of a directory as a MIME message."""
importos
importsmtplib
# For guessing MIME type based on file name extension
importmimetypes
fromargparseimport ArgumentParser
fromemail.messageimport EmailMessage
fromemail.policyimport SMTP

defmain():
  parser = ArgumentParser(description="""\
Send the contents of a directory as a MIME message.
Unless the -o option is given, the email is sent by forwarding to your local
SMTP server, which then does the normal delivery process. Your local machine
must be running an SMTP server.
""")
  parser.add_argument('-d', '--directory',
            help="""Mail the contents of the specified directory,
            otherwise use the current directory. Only the regular
            files in the directory are sent, and we don't recurse to
            subdirectories.""")
  parser.add_argument('-o', '--output',
            metavar='FILE',
            help="""Print the composed message to FILE instead of
            sending the message to the SMTP server.""")
  parser.add_argument('-s', '--sender', required=True,
            help='The value of the From: header (required)')
  parser.add_argument('-r', '--recipient', required=True,
            action='append', metavar='RECIPIENT',
            default=[], dest='recipients',
            help='A To: header value (at least one required)')
  args = parser.parse_args()
  directory = args.directory
  if not directory:
    directory = '.'
  # Create the message
  msg = EmailMessage()
  msg['Subject'] = f'Contents of directory {os.path.abspath(directory)}'
  msg['To'] = ', '.join(args.recipients)
  msg['From'] = args.sender
  msg.preamble = 'You will not see this in a MIME-aware mail reader.\n'
  for filename in os.listdir(directory):
    path = os.path.join(directory, filename)
    if not os.path.isfile(path):
      continue
    # Guess the content type based on the file's extension. Encoding
    # will be ignored, although we should check for simple things like
    # gzip'd or compressed files.
    ctype, encoding = mimetypes.guess_file_type(path)
    if ctype is None or encoding is not None:
      # No guess could be made, or the file is encoded (compressed), so
      # use a generic bag-of-bits type.
      ctype = 'application/octet-stream'
    maintype, subtype = ctype.split('/', 1)
    with open(path, 'rb') as fp:
      msg.add_attachment(fp.read(),
                maintype=maintype,
                subtype=subtype,
                filename=filename)
  # Now send or store the message
  if args.output:
    with open(args.output, 'wb') as fp:
      fp.write(msg.as_bytes(policy=SMTP))
  else:
    with smtplib.SMTP('localhost') as s:
      s.send_message(msg)

if __name__ == '__main__':
  main()

```

Here’s an example of how to unpack a MIME message like the one above, into a directory of files: