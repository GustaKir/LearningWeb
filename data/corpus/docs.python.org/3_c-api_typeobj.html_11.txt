Title: Understanding PyTypeObject Size Fields
URL: https://docs.python.org/3/c-api/typeobj.html
Summary: This document segment discusses the `tp_basicsize` and `tp_itemsize` fields of the `PyTypeObject` in Python's C API, which are used to compute the size of type instances in bytes. It differentiates between types with fixed-length instances (zero `tp_itemsize`) and those with variable-length instances (non-zero `tp_itemsize`).
---

[Py_ssize_t](https://docs.python.org/3/c-api/intro.html#c.Py_ssize_t "Py_ssize_t")[PyTypeObject](https://docs.python.org/3/c-api/type.html#c.PyTypeObject "PyTypeObject").tp_basicsize[¶](https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_basicsize "Link to this definition")


[Py_ssize_t](https://docs.python.org/3/c-api/intro.html#c.Py_ssize_t "Py_ssize_t")[PyTypeObject](https://docs.python.org/3/c-api/type.html#c.PyTypeObject "PyTypeObject").tp_itemsize[¶](https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_itemsize "Link to this definition")
    
These fields allow calculating the size in bytes of instances of the type.
There are two kinds of types: types with fixed-length instances have a zero `tp_itemsize` field, types with variable-length instances have a non-zero `tp_itemsize` field. For a type with fixed-length instances, all instances have the same size, given in `tp_basicsize`. (Exceptions to this rule can be made using [`PyUnstable_Object_GC_NewWithExtraData()`](https://docs.python.org/3/c-api/gcsupport.html#c.PyUnstable_Object_GC_NewWithExtraData "PyUnstable_Object_GC_NewWithExtraData").)
For a type with variable-length instances, the instances must have an [`ob_size`](https://docs.python.org/3/c-api/typeobj.html#c.PyVarObject.ob_size "PyVarObject.ob_size") field, and the instance size is `tp_basicsize` plus N times `tp_itemsize`, where N is the “length” of the object.
Functions like [`PyObject_NewVar()`](https://docs.python.org/3/c-api/allocation.html#c.PyObject_NewVar "PyObject_NewVar") will take the value of N as an argument, and store in the instance’s [`ob_size`](https://docs.python.org/3/c-api/typeobj.html#c.PyVarObject.ob_size "PyVarObject.ob_size") field. Note that the [`ob_size`](https://docs.python.org/3/c-api/typeobj.html#c.PyVarObject.ob_size "PyVarObject.ob_size") field may later be used for other purposes. For example, [`int`](https://docs.python.org/3/library/functions.html#int "int") instances use the bits of [`ob_size`](https://docs.python.org/3/c-api/typeobj.html#c.PyVarObject.ob_size "PyVarObject.ob_size") in an implementation-defined way; the underlying storage and its size should be accessed using `PyLong_Export()`.
Note
The [`ob_size`](https://docs.python.org/3/c-api/typeobj.html#c.PyVarObject.ob_size "PyVarObject.ob_size") field should be accessed using the [`Py_SIZE()`](https://docs.python.org/3/c-api/structures.html#c.Py_SIZE "Py_SIZE") and [`Py_SET_SIZE()`](https://docs.python.org/3/c-api/structures.html#c.Py_SET_SIZE "Py_SET_SIZE") macros.
Also, the presence of an [`ob_size`](https://docs.python.org/3/c-api/typeobj.html#c.PyVarObject.ob_size "PyVarObject.ob_size") field in the instance layout doesn’t mean that the instance structure is variable-length. For example, the [`list`](https://docs.python.org/3/library/stdtypes.html#list "list") type has fixed-length instances, yet those instances have a [`ob_size`](https://docs.python.org/3/c-api/typeobj.html#c.PyVarObject.ob_size "PyVarObject.ob_size") field. (As with [`int`](https://docs.python.org/3/library/functions.html#int "int"), avoid reading lists’ `ob_size` directly. Call [`PyList_Size()`](https://docs.python.org/3/c-api/list.html#c.PyList_Size "PyList_Size") instead.)
The `tp_basicsize` includes size needed for data of the type’s [`tp_base`](https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_base "PyTypeObject.tp_base"), plus any extra data needed by each instance.
The correct way to set `tp_basicsize` is to use the `sizeof` operator on the struct used to declare the instance layout. This struct must include the struct used to declare the base type. In other words, `tp_basicsize` must be greater than or equal to the base’s `tp_basicsize`.
Since every type is a subtype of [`object`](https://docs.python.org/3/library/functions.html#object "object"), this struct must include [`PyObject`](https://docs.python.org/3/c-api/structures.html#c.PyObject "PyObject") or [`PyVarObject`](https://docs.python.org/3/c-api/structures.html#c.PyVarObject "PyVarObject") (depending on whether [`ob_size`](https://docs.python.org/3/c-api/typeobj.html#c.PyVarObject.ob_size "PyVarObject.ob_size") should be included). These are usually defined by the macro [`PyObject_HEAD`](https://docs.python.org/3/c-api/structures.html#c.PyObject_HEAD "PyObject_HEAD") or [`PyObject_VAR_HEAD`](https://docs.python.org/3/c-api/structures.html#c.PyObject_VAR_HEAD "PyObject_VAR_HEAD"), respectively.
The basic size does not include the GC header size, as that header is not part of [`PyObject_HEAD`](https://docs.python.org/3/c-api/structures.html#c.PyObject_HEAD "PyObject_HEAD").
For cases where struct used to declare the base type is unknown, see [`PyType_Spec.basicsize`](https://docs.python.org/3/c-api/type.html#c.PyType_Spec.basicsize "PyType_Spec.basicsize") and [`PyType_FromMetaclass()`](https://docs.python.org/3/c-api/type.html#c.PyType_FromMetaclass "PyType_FromMetaclass").
Notes about alignment:
  * `tp_basicsize` must be