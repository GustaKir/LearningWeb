Title: Text and Data in Python 3.0
URL: https://docs.python.org/3/whatsnew/3.0.html
Summary: Python 3.0 introduces a new classification of text and binary data, shifting from Unicode and 8-bit strings. In this version, all text is treated as Unicode, while encoded Unicode is handled as binary data, represented by the `str` and `bytes` types, respectively. Mixing text and data raises a `TypeError`, contrasting with Python 2.x where such operations were more permissive.
---

### Text Vs. Data Instead Of Unicode Vs. 8-bit[¶](https://docs.python.org/3/whatsnew/3.0.html#text-vs-data-instead-of-unicode-vs-8-bit "Link to this heading")
Everything you thought you knew about binary data and Unicode has changed.
  * Python 3.0 uses the concepts of _text_ and (binary) _data_ instead of Unicode strings and 8-bit strings. All text is Unicode; however _encoded_ Unicode is represented as binary data. The type used to hold text is [`str`](https://docs.python.org/3/library/stdtypes.html#str "str"), the type used to hold data is [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "bytes"). The biggest difference with the 2.x situation is that any attempt to mix text and data in Python 3.0 raises [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError "TypeError"), whereas if you were to mix Unicode and 8-bit strings in Python 2.x, it would work if the 8-bit string happened to contain only 7-bit (ASCII) bytes, but you would get [`UnicodeDecodeError`](https://docs.python.org/3/library/exceptions.html#UnicodeDecodeError "UnicodeDecodeError") if it contained non-ASCII values. This value-specific behavior has caused numerous sad faces over the years.
  * As a consequence of this change in philosophy, pretty much all code that uses Unicode, encodings or binary data most likely has to change. The change is for the better, as in the 2.x world there were numerous bugs having to do with mixing encoded and unencoded text. To be prepared in Python 2.x, start using `unicode` for all unencoded text, and [`str`](https://docs.python.org/3/library/stdtypes.html#str "str") for binary or encoded data only. Then the `2to3` tool will do most of the work for you.
  * You can no longer use `u"..."` literals for Unicode text. However, you must use `b"..."` literals for binary data.
  * As the [`str`](https://docs.python.org/3/library/stdtypes.html#str "str") and [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "bytes") types cannot be mixed, you must always explicitly convert between them. Use [`str.encode()`](https://docs.python.org/3/library/stdtypes.html#str.encode "str.encode") to go from [`str`](https://docs.python.org/3/library/stdtypes.html#str "str") to [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "bytes"), and [`bytes.decode()`](https://docs.python.org/3/library/stdtypes.html#bytes.decode "bytes.decode") to go from [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "bytes") to [`str`](https://docs.python.org/3/library/stdtypes.html#str "str"). You can also use `bytes(s, encoding=...)` and `str(b, encoding=...)`, respectively.
  * Like [`str`](https://docs.python.org/3/library/stdtypes.html#str "str"), the [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "bytes") type is immutable. There is a separate _mutable_ type to hold buffered binary data, [`bytearray`](https://docs.python.org/3/library/stdtypes.html#bytearray "bytearray"). Nearly all APIs that accept [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "bytes") also accept [`bytearray`](https://docs.python.org/3/library/stdtypes.html#bytearray "bytearray"). The mutable API is based on [`collections.MutableSequence`](https://docs.python.org/3/library/collections.abc.html#collections.abc.MutableSequence "collections.abc.MutableSequence").
  * All backslashes in raw string literals are interpreted literally. This means that `'\U'` and `'\u'` escapes in raw strings are not treated specially. For example, `r'\u20ac'` is a string of 6 characters in Python 3.0, whereas in 2.6, `ur'\u20ac'` was the single “euro” character. (Of course, this change only affects raw string literals; the euro character is `'\u20ac'` in Python 3.0.)
  * The built-in `basestring` abstract type was removed. Use [`str`](https://docs.python.org/3/library/stdtypes.html#str "str") instead. The [`str`](https://docs.python.org/3/library/stdtypes.html#str "str") and [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "bytes") types don’t have functionality enough in common to warrant a shared base class. The `2to3` tool (see below) replaces every occurrence of `basestring` with [`str`](https://docs.python.org/3/library/stdtypes.html#str "str").
  * Files opened as text files (still the default mode for [`open()`](https://docs.python.org/3/library/functions.html#open "open")) always use an encoding to map between strings (in memory) and bytes (on disk). Binary files (opened with a `b` in the mode argument) always use bytes in memory. This means that if a file is opened using an incorrect mode or encoding, I/O will likely fail loudly, instead of silently producing incorrect data. It also means that even Unix users will have to specify the correct mode (text or binary) when opening a file. There is a platform-dependent default encoding, which on Unixy platforms can be set with the `LANG` environment variable (and sometimes also with some other platform-specific locale-related en