Title: Regular Expressions HOWTO
URL: https://docs.python.org/3/howto/regex.html
Summary: This section discusses the usage of `finditer()`, `match()`, and `search()` functions in Python's `re` module for working with regular expressions. It highlights that `match()` and `search()` return `None` when no match is found, and otherwise return a match object containing details about the match.
---

as a list.  
`finditer()` | Find all substrings where the RE matches, and returns them as an [iterator](https://docs.python.org/3/glossary.html#term-iterator).  
[`match()`](https://docs.python.org/3/library/re.html#re.Pattern.match "re.Pattern.match") and [`search()`](https://docs.python.org/3/library/re.html#re.Pattern.search "re.Pattern.search") return `None` if no match can be found. If they’re successful, a [match object](https://docs.python.org/3/library/re.html#match-objects) instance is returned, containing information about the match: where it starts and ends, the substring it matched, and more.
You can learn about this by interactively experimenting with the [`re`](https://docs.python.org/3/library/re.html#module-re "re: Regular expression operations.") module.
This HOWTO uses the standard Python interpreter for its examples. First, run the Python interpreter, import the [`re`](https://docs.python.org/3/library/re.html#module-re "re: Regular expression operations.") module, and compile a RE:
>>>```
>>> importre
>>> p = re.compile('[a-z]+')
>>> p
re.compile('[a-z]+')

```

Now, you can try matching various strings against the RE `[a-z]+`. An empty string shouldn’t match at all, since `+` means ‘one or more repetitions’. [`match()`](https://docs.python.org/3/library/re.html#re.Pattern.match "re.Pattern.match") should return `None` in this case, which will cause the interpreter to print no output. You can explicitly print the result of `match()` to make this clear.
>>>```
>>> p.match("")
>>> print(p.match(""))
None

```

Now, let’s try it on a string that it should match, such as `tempo`. In this case, [`match()`](https://docs.python.org/3/library/re.html#re.Pattern.match "re.Pattern.match") will return a [match object](https://docs.python.org/3/library/re.html#match-objects), so you should store the result in a variable for later use.
>>>```
>>> m = p.match('tempo')
>>> m
<re.Match object; span=(0, 5), match='tempo'>

```

Now you can query the [match object](https://docs.python.org/3/library/re.html#match-objects) for information about the matching string. Match object instances also have several methods and attributes; the most important ones are:
Method/Attribute | Purpose  
---|---  
`group()` | Return the string matched by the RE  
`start()` | Return the starting position of the match  
`end()` | Return the ending position of the match  
`span()` | Return a tuple containing the (start, end) positions of the match  
Trying these methods will soon clarify their meaning:
>>>```
>>> m.group()
'tempo'
>>> m.start(), m.end()
(0, 5)
>>> m.span()
(0, 5)

```

[`group()`](https://docs.python.org/3/library/re.html#re.Match.group "re.Match.group") returns the substring that was matched by the RE. [`start()`](https://docs.python.org/3/library/re.html#re.Match.start "re.Match.start") and [`end()`](https://docs.python.org/3/library/re.html#re.Match.end "re.Match.end") return the starting and ending index of the match. [`span()`](https://docs.python.org/3/library/re.html#re.Match.span "re.Match.span") returns both start and end indexes in a single tuple. Since the [`match()`](https://docs.python.org/3/library/re.html#re.Pattern.match "re.Pattern.match") method only checks if the RE matches at the start of a string, `start()` will always be zero. However, the [`search()`](https://docs.python.org/3/library/re.html#re.Pattern.search "re.Pattern.search") method of patterns scans through the string, so the match may not start at zero in that case.
>>>```
>>> print(p.match('::: message'))
None
>>> m = p.search('::: message'); print(m)
<re.Match object; span=(4, 11), match='message'>
>>> m.group()
'message'
>>> m.span()
(4, 11)

```

In actual programs, the most common style is to store the [match object](https://docs.python.org/3/library/re.html#match-objects) in a variable, and then check if it was `None`. This usually looks like:
```
p = re.compile( ... )
m = p.match( 'string goes here' )
if m:
  print('Match found: ', m.group())
else:
  print('No match')

```

Two pattern methods return all of the matches for a pattern. [`findall()`](https://docs.python.org/3/library/re.html#re.Pattern.findall "re.Pattern.findall") returns a list of matching strings:
>>>```
>>> p = re.compile(r'\d+')
>>> p.findall('12 drummers drumming, 11 pipers piping, 10 lords a-leaping')
['12', '11', '10']