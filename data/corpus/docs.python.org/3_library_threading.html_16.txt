Title: Threading Timer and Synchronization Primitives
URL: https://docs.python.org/3/library/threading.html
Summary: The `threading.Timer` class allows scheduling a function to be executed after a specified interval, with optional arguments. The `cancel()` method can stop the timer if it is still waiting. Additionally, barrier objects were introduced in version 3.2 to enable synchronization among a specified number of threads.
---

```


_class_ threading.Timer(_interval_ , _function_ , _args =None_, _kwargs =None_)[¶](https://docs.python.org/3/library/threading.html#threading.Timer "Link to this definition")
    
Create a timer that will run _function_ with arguments _args_ and keyword arguments _kwargs_ , after _interval_ seconds have passed. If _args_ is `None` (the default) then an empty list will be used. If _kwargs_ is `None` (the default) then an empty dict will be used.
Changed in version 3.3: changed from a factory function to a class. 

cancel()[¶](https://docs.python.org/3/library/threading.html#threading.Timer.cancel "Link to this definition")
    
Stop the timer, and cancel the execution of the timer’s action. This will only work if the timer is still in its waiting stage.
## Barrier Objects[¶](https://docs.python.org/3/library/threading.html#barrier-objects "Link to this heading")
Added in version 3.2.
This class provides a simple synchronization primitive for use by a fixed number of threads that need to wait for each other. Each of the threads tries to pass the barrier by calling the [`wait()`](https://docs.python.org/3/library/threading.html#threading.Barrier.wait "threading.Barrier.wait") method and will block until all of the threads have made their [`wait()`](https://docs.python.org/3/library/threading.html#threading.Barrier.wait "threading.Barrier.wait") calls. At this point, the threads are released simultaneously.
The barrier can be reused any number of times for the same number of threads.
As an example, here is a simple way to synchronize a client and server thread:
```
b = Barrier(2, timeout=5)
defserver():
  start_server()
  b.wait()
  while True:
    connection = accept_connection()
    process_server_connection(connection)
defclient():
  b.wait()
  while True:
    connection = make_connection()
    process_client_connection(connection)

```


_class_ threading.Barrier(_parties_ , _action =None_, _timeout =None_)[¶](https://docs.python.org/3/library/threading.html#threading.Barrier "Link to this definition")
    
Create a barrier object for _parties_ number of threads. An _action_ , when provided, is a callable to be called by one of the threads when they are released. _timeout_ is the default timeout value if none is specified for the [`wait()`](https://docs.python.org/3/library/threading.html#threading.Barrier.wait "threading.Barrier.wait") method. 

wait(_timeout =None_)[¶](https://docs.python.org/3/library/threading.html#threading.Barrier.wait "Link to this definition")
    
Pass the barrier. When all the threads party to the barrier have called this function, they are all released simultaneously. If a _timeout_ is provided, it is used in preference to any that was supplied to the class constructor.
The return value is an integer in the range 0 to _parties_ – 1, different for each thread. This can be used to select a thread to do some special housekeeping, e.g.:
```
i = barrier.wait()
if i == 0:
  # Only one thread needs to print this
  print("passed the barrier")