Title: Reading Binary Data in Python
URL: https://docs.python.org/3/faq/library.html
Summary: This section explains how to read binary data using format strings, such as '>' for big-endian and types 'h' and 'l' for short and long integers. It mentions the necessity of opening files in binary mode to read binary data properly and suggests using the 'array' module for homogeneous lists of numeric types.
---

```

The ‘>’ in the format string forces big-endian data; the letter ‘h’ reads one “short integer” (2 bytes), and ‘l’ reads one “long integer” (4 bytes) from the string.
For data that is more regular (e.g. a homogeneous list of ints or floats), you can also use the [`array`](https://docs.python.org/3/library/array.html#module-array "array: Space efficient arrays of uniformly typed numeric values.") module.
Note
To read and write binary data, it is mandatory to open the file in binary mode (here, passing `"rb"` to [`open()`](https://docs.python.org/3/library/functions.html#open "open")). If you use `"r"` instead (the default), the file will be open in text mode and `f.read()` will return [`str`](https://docs.python.org/3/library/stdtypes.html#str "str") objects rather than [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "bytes") objects.
### [I can’t seem to use os.read() on a pipe created with os.popen(); why?](https://docs.python.org/3/faq/library.html#id23)[¶](https://docs.python.org/3/faq/library.html#i-can-t-seem-to-use-os-read-on-a-pipe-created-with-os-popen-why "Link to this heading")
[`os.read()`](https://docs.python.org/3/library/os.html#os.read "os.read") is a low-level function which takes a file descriptor, a small integer representing the opened file. [`os.popen()`](https://docs.python.org/3/library/os.html#os.popen "os.popen") creates a high-level file object, the same type returned by the built-in [`open()`](https://docs.python.org/3/library/functions.html#open "open") function. Thus, to read _n_ bytes from a pipe _p_ created with [`os.popen()`](https://docs.python.org/3/library/os.html#os.popen "os.popen"), you need to use `p.read(n)`.
### [How do I access the serial (RS232) port?](https://docs.python.org/3/faq/library.html#id24)[¶](https://docs.python.org/3/faq/library.html#how-do-i-access-the-serial-rs232-port "Link to this heading")
For Win32, OSX, Linux, BSD, Jython, IronPython:
> [pyserial](https://pypi.org/project/pyserial/)
For Unix, see a Usenet post by Mitch Chapman:
> <https://groups.google.com/groups?selm=34A04430.CF9@ohioee.com>
### [Why doesn’t closing sys.stdout (stdin, stderr) really close it?](https://docs.python.org/3/faq/library.html#id25)[¶](https://docs.python.org/3/faq/library.html#why-doesn-t-closing-sys-stdout-stdin-stderr-really-close-it "Link to this heading")
Python [file objects](https://docs.python.org/3/glossary.html#term-file-object) are a high-level layer of abstraction on low-level C file descriptors.
For most file objects you create in Python via the built-in [`open()`](https://docs.python.org/3/library/functions.html#open "open") function, `f.close()` marks the Python file object as being closed from Python’s point of view, and also arranges to close the underlying C file descriptor. This also happens automatically in `f`’s destructor, when `f` becomes garbage.
But stdin, stdout and stderr are treated specially by Python, because of the special status also given to them by C. Running `sys.stdout.close()` marks the Python-level file object as being closed, but does _not_ close the associated C file descriptor.
To close the underlying C file descriptor for one of these three, you should first be sure that’s what you really want to do (e.g., you may confuse extension modules trying to do I/O). If it is, use [`os.close()`](https://docs.python.org/3/library/os.html#os.close "os.close"):
```
os.close(stdin.fileno())
os.close(stdout.fileno())
os.close(stderr.fileno())