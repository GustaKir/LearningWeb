Title: Introduction to Awaitables in asyncio
URL: https://docs.python.org/3/library/asyncio-task.html
Summary: This section introduces the concept of awaitable objects in Python's asyncio library, which can be used with the 'await' expression. It outlines the three main types of awaitables: coroutines, Tasks, and Futures, highlighting that Python coroutines are awaitable and need to be awaited to execute.
---

```

The timing and output should be the same as for the previous version.
Added in version 3.11: [`asyncio.TaskGroup`](https://docs.python.org/3/library/asyncio-task.html#asyncio.TaskGroup "asyncio.TaskGroup").


## [Awaitables](https://docs.python.org/3/library/asyncio-task.html#id3)[¶](https://docs.python.org/3/library/asyncio-task.html#awaitables "Link to this heading")
We say that an object is an **awaitable** object if it can be used in an [`await`](https://docs.python.org/3/reference/expressions.html#await) expression. Many asyncio APIs are designed to accept awaitables.
There are three main types of _awaitable_ objects: **coroutines** , **Tasks** , and **Futures**.
Coroutines
Python coroutines are _awaitables_ and therefore can be awaited from other coroutines:
```
importasyncio
async defnested():
  return 42
async defmain():
  # Nothing happens if we just call "nested()".
  # A coroutine object is created but not awaited,
  # so it *won't run at all*.
  nested() # will raise a "RuntimeWarning".
  # Let's do it differently now and await it:
  print(await nested()) # will print "42".
asyncio.run(main())

```

Important
In this documentation the term “coroutine” can be used for two closely related concepts:
  * a _coroutine function_ : an [`async def`](https://docs.python.org/3/reference/compound_stmts.html#async-def) function;
  * a _coroutine object_ : an object returned by calling a _coroutine function_.


Tasks
_Tasks_ are used to schedule coroutines _concurrently_.
When a coroutine is wrapped into a _Task_ with functions like [`asyncio.create_task()`](https://docs.python.org/3/library/asyncio-task.html#asyncio.create_task "asyncio.create_task") the coroutine is automatically scheduled to run soon:
```
importasyncio
async defnested():
  return 42
async defmain():
  # Schedule nested() to run soon concurrently
  # with "main()".
  task = asyncio.create_task(nested())
  # "task" can now be used to cancel "nested()", or
  # can simply be awaited to wait until it is complete:
  await task
asyncio.run(main())

```

Futures
A [`Future`](https://docs.python.org/3/library/asyncio-future.html#asyncio.Future "asyncio.Future") is a special **low-level** awaitable object that represents an **eventual result** of an asynchronous operation.
When a Future object is _awaited_ it means that the coroutine will wait until the Future is resolved in some other place.
Future objects in asyncio are needed to allow callback-based code to be used with async/await.
Normally **there is no need** to create Future objects at the application level code.
Future objects, sometimes exposed by libraries and some asyncio APIs, can be awaited:
```
async defmain():
  await function_that_returns_a_future_object()
  # this is also valid:
  await asyncio.gather(
    function_that_returns_a_future_object(),
    some_python_coroutine()
  )