Title: Context Management in Python's contextvars Module
URL: https://docs.python.org/3/library/contextvars.html
Summary: This section discusses the `contextvars.Context` class, which acts as a mapping of `ContextVars` to their values and creates an empty context. It also explains that each thread maintains its own stack of `Context` objects, with the top object representing the current context. The function operates with O(1) complexity, ensuring consistent performance regardless of the number of context variables.
---

```

The function has an _O_(1) complexity, i.e. works equally fast for contexts with a few context variables and for contexts that have a lot of them. 

_class_ contextvars.Context[¶](https://docs.python.org/3/library/contextvars.html#contextvars.Context "Link to this definition")
    
A mapping of [`ContextVars`](https://docs.python.org/3/library/contextvars.html#contextvars.ContextVar "contextvars.ContextVar") to their values.
`Context()` creates an empty context with no values in it. To get a copy of the current context use the [`copy_context()`](https://docs.python.org/3/library/contextvars.html#contextvars.copy_context "contextvars.copy_context") function.
Each thread has its own effective stack of `Context` objects. The [current context](https://docs.python.org/3/glossary.html#term-current-context) is the `Context` object at the top of the current thread’s stack. All `Context` objects in the stacks are considered to be _entered_.
_Entering_ a context, which can be done by calling its [`run()`](https://docs.python.org/3/library/contextvars.html#contextvars.Context.run "contextvars.Context.run") method, makes the context the current context by pushing it onto the top of the current thread’s context stack.
_Exiting_ from the current context, which can be done by returning from the callback passed to the [`run()`](https://docs.python.org/3/library/contextvars.html#contextvars.Context.run "contextvars.Context.run") method, restores the current context to what it was before the context was entered by popping the context off the top of the context stack.
Since each thread has its own context stack, [`ContextVar`](https://docs.python.org/3/library/contextvars.html#contextvars.ContextVar "contextvars.ContextVar") objects behave in a similar fashion to [`threading.local()`](https://docs.python.org/3/library/threading.html#threading.local "threading.local") when values are assigned in different threads.
Attempting to enter an already entered context, including contexts entered in other threads, raises a [`RuntimeError`](https://docs.python.org/3/library/exceptions.html#RuntimeError "RuntimeError").
After exiting a context, it can later be re-entered (from any thread).
Any changes to [`ContextVar`](https://docs.python.org/3/library/contextvars.html#contextvars.ContextVar "contextvars.ContextVar") values via the [`ContextVar.set()`](https://docs.python.org/3/library/contextvars.html#contextvars.ContextVar.set "contextvars.ContextVar.set") method are recorded in the current context. The [`ContextVar.get()`](https://docs.python.org/3/library/contextvars.html#contextvars.ContextVar.get "contextvars.ContextVar.get") method returns the value associated with the current context. Exiting a context effectively reverts any changes made to context variables while the context was entered (if needed, the values can be restored by re-entering the context).
Context implements the [`collections.abc.Mapping`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Mapping "collections.abc.Mapping") interface. 

run(_callable_ , _* args_, _** kwargs_)[¶](https://docs.python.org/3/library/contextvars.html#contextvars.Context.run "Link to this definition")
    
Enters the Context, executes `callable(*args, **kwargs)`, then exits the Context. Returns _callable_ ’s return value, or propagates an exception if one occurred.
Example:
```
importcontextvars
var = contextvars.ContextVar('var')
var.set('spam')
print(var.get()) # 'spam'
ctx = contextvars.copy_context()
defmain():
  # 'var' was set to 'spam' before
  # calling 'copy_context()' and 'ctx.run(main)', so:
  print(var.get()) # 'spam'
  print(ctx[var]) # 'spam'
  var.set('ham')
  # Now, after setting 'var' to 'ham':
  print(var.get()) # 'ham'
  print(ctx[var]) # 'ham'
# Any changes that the 'main' function makes to 'var'
# will be contained in 'ctx'.
ctx.run(main)
# The 'main()' function was run in the 'ctx' context,
# so changes to 'var' are contained in it:
print(ctx[var]) # 'ham'
# However, outside of 'ctx', 'var' is still set to 'spam':
print(var.get()) # 'spam'