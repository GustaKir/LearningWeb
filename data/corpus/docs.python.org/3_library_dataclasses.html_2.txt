Title: Parameters of the @dataclass Decorator
URL: https://docs.python.org/3/library/dataclasses.html
Summary: This section describes the parameters for the `@dataclass` decorator, including `_init_`, `_repr_`, and `_eq_`, detailing their default values and behavior regarding method generation.
---

```

The parameters to `@dataclass` are:
  * _init_ : If true (the default), a [`__init__()`](https://docs.python.org/3/reference/datamodel.html#object.__init__ "object.__init__") method will be generated.
If the class already defines `__init__()`, this parameter is ignored.
  * _repr_ : If true (the default), a [`__repr__()`](https://docs.python.org/3/reference/datamodel.html#object.__repr__ "object.__repr__") method will be generated. The generated repr string will have the class name and the name and repr of each field, in the order they are defined in the class. Fields that are marked as being excluded from the repr are not included. For example: `InventoryItem(name='widget', unit_price=3.0, quantity_on_hand=10)`.
If the class already defines `__repr__()`, this parameter is ignored.
  * _eq_ : If true (the default), an [`__eq__()`](https://docs.python.org/3/reference/datamodel.html#object.__eq__ "object.__eq__") method will be generated. This method compares the class as if it were a tuple of its fields, in order. Both instances in the comparison must be of the identical type.
If the class already defines `__eq__()`, this parameter is ignored.
  * _order_ : If true (the default is `False`), [`__lt__()`](https://docs.python.org/3/reference/datamodel.html#object.__lt__ "object.__lt__"), [`__le__()`](https://docs.python.org/3/reference/datamodel.html#object.__le__ "object.__le__"), [`__gt__()`](https://docs.python.org/3/reference/datamodel.html#object.__gt__ "object.__gt__"), and [`__ge__()`](https://docs.python.org/3/reference/datamodel.html#object.__ge__ "object.__ge__") methods will be generated. These compare the class as if it were a tuple of its fields, in order. Both instances in the comparison must be of the identical type. If _order_ is true and _eq_ is false, a [`ValueError`](https://docs.python.org/3/library/exceptions.html#ValueError "ValueError") is raised.
If the class already defines any of `__lt__()`, `__le__()`, `__gt__()`, or `__ge__()`, then [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError "TypeError") is raised.
  * _unsafe_hash_ : If `False` (the default), a [`__hash__()`](https://docs.python.org/3/reference/datamodel.html#object.__hash__ "object.__hash__") method is generated according to how _eq_ and _frozen_ are set.
`__hash__()` is used by built-in [`hash()`](https://docs.python.org/3/library/functions.html#hash "hash"), and when objects are added to hashed collections such as dictionaries and sets. Having a `__hash__()` implies that instances of the class are immutable. Mutability is a complicated property that depends on the programmerâ€™s intent, the existence and behavior of `__eq__()`, and the values of the _eq_ and _frozen_ flags in the `@dataclass` decorator.
By default, `@dataclass` will not implicitly add a [`__hash__()`](https://docs.python.org/3/reference/datamodel.html#object.__hash__ "object.__hash__") method unless it is safe to do so. Neither will it add or change an existing explicitly defined `__hash__()` method. Setting the class attribute `__hash__ = None` has a specific meaning to Python, as described in the `__hash__()` documentation.
If `__hash__()` is not explicitly defined, or if it is set to `None`, then `@dataclass` _may_ add an implicit `__hash__()` method. Although not recommended, you can force `@dataclass` to create a `__hash__()` method with `unsafe_hash=True`. This might be the case if your class is logically immutable but can still be mutated. This is a specialized use case and should be considered carefully.
Here are the rules governing implicit creation of a `__hash__()` method. Note that you cannot both have an explicit `__hash__()` method in your dataclass and set `unsafe_hash=True`; this will result in a [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError "TypeError").
If _eq_ and _frozen_ are both true, by default `@dataclass` will generate a `__hash__()` method for you. If _eq_ is true and _frozen_ is false, `__hash__()` will be set to `None`, marking it unhashable (which it is, since it is mutable). If _eq_ is false, `__hash__()` will be left untouched meaning the `__hash__()` method of the superclass will be used (if the superclass is [`object`](https://docs.python.org/3/library/functions.html#object "object"), this means it will fall back to id-based hashing).
  * _frozen_ : If true (the default is `False`), assigning to fields will generate an exception. This emulates read-only frozen instances. If [`__setattr__()`](https://docs.python.org/3/reference/datamodel.html#object.__setattr__ "object.__setattr__") or [`__delattr__()`](https://docs.python.org/3/reference/datamodel.html#object.__delattr__ "object.__delattr__") is defined in the class, then [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError "TypeError") is raised. See the discussion below.
  * _match_args_ : If true (the default is `True`), the [`__match_args__`](https://docs.python.org/3/reference/datamodel.html#ob