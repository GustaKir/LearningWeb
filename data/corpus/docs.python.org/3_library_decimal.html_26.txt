Title: Precision and Rounding in Decimal Calculations
URL: https://docs.python.org/3/library/decimal.html
Summary: The decimal module allows for testing calculations with different precisions and rounding modes to avoid spurious results. Inputs maintain their exact value without rounding, which can lead to unexpected results if not properly managed.
---

```

Q. Within a complex calculation, how can I make sure that I haven’t gotten a spurious result because of insufficient precision or rounding anomalies.
A. The decimal module makes it easy to test results. A best practice is to re-run calculations using greater precision and with various rounding modes. Widely differing results indicate insufficient precision, rounding mode issues, ill-conditioned inputs, or a numerically unstable algorithm.
Q. I noticed that context precision is applied to the results of operations but not to the inputs. Is there anything to watch out for when mixing values of different precisions?
A. Yes. The principle is that all values are considered to be exact and so is the arithmetic on those values. Only the results are rounded. The advantage for inputs is that “what you type is what you get”. A disadvantage is that the results can look odd if you forget that the inputs haven’t been rounded:
>>>```
>>> getcontext().prec = 3
>>> Decimal('3.104') + Decimal('2.104')
Decimal('5.21')
>>> Decimal('3.104') + Decimal('0.000') + Decimal('2.104')
Decimal('5.20')

```

The solution is either to increase precision or to force rounding of inputs using the unary plus operation:
>>>```
>>> getcontext().prec = 3
>>> +Decimal('1.23456789')   # unary plus triggers rounding
Decimal('1.23')

```

Alternatively, inputs can be rounded upon creation using the [`Context.create_decimal()`](https://docs.python.org/3/library/decimal.html#decimal.Context.create_decimal "decimal.Context.create_decimal") method:
>>>```
>>> Context(prec=5, rounding=ROUND_DOWN).create_decimal('1.2345678')
Decimal('1.2345')

```

Q. Is the CPython implementation fast for large numbers?
A. Yes. In the CPython and PyPy3 implementations, the C/CFFI versions of the decimal module integrate the high speed [libmpdec](https://www.bytereef.org/mpdecimal/doc/libmpdec/index.html) library for arbitrary precision correctly rounded decimal floating-point arithmetic [[1]](https://docs.python.org/3/library/decimal.html#id4). `libmpdec` uses [Karatsuba multiplication](https://en.wikipedia.org/wiki/Karatsuba_algorithm) for medium-sized numbers and the [Number Theoretic Transform](https://en.wikipedia.org/wiki/Discrete_Fourier_transform_\(general\)#Number-theoretic_transform) for very large numbers.
The context must be adapted for exact arbitrary precision arithmetic. `Emin` and `Emax` should always be set to the maximum values, `clamp` should always be 0 (the default). Setting `prec` requires some care.
The easiest approach for trying out bignum arithmetic is to use the maximum value for `prec` as well [[2]](https://docs.python.org/3/library/decimal.html#id5):
>>>```
>>> setcontext(Context(prec=MAX_PREC, Emax=MAX_EMAX, Emin=MIN_EMIN))
>>> x = Decimal(2) ** 256
>>> x / 128
Decimal('904625697166532776746648320380374280103671755200316906558262375061821325312')

```

For inexact results, [`MAX_PREC`](https://docs.python.org/3/library/decimal.html#decimal.MAX_PREC "decimal.MAX_PREC") is far too large on 64-bit platforms and the available memory will be insufficient:
>>>```
>>> Decimal(1) / 3
Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
MemoryError

```

On systems with overallocation (e.g. Linux), a more sophisticated approach is to adjust `prec` to the amount of available RAM. Suppose that you have 8GB of RAM and expect 10 simultaneous operands using a maximum of 500MB each:
>>>```
>>> importsys
>>>
>>> # Maximum number of digits for a single operand using 500MB in 8-byte words
>>> # with 19 digits per word (4-byte and 9 digits for the 32-bit build):
>>> maxdigits = 19 * ((500 * 1024**2) // 8)
>>>
>>> # Check that this works:
>>> c = Context(prec=maxdigits, Emax=MAX_EMAX, Emin=MIN_EMIN)
>>> c.traps[Inexact] = True
>>> setcontext(c)
>>>
>>> # Fill the available precision with nines:
>>> x = Decimal(0).logical_invert() * 9
>>> sys.getsizeof(x)
524288112
>>> x + 2
Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
 decimal.Inexact: [<class 'decimal.Inexact'>]