Title: Codec Registration and File Handling in Python
URL: https://docs.python.org/3/library/codecs.html
Summary: The `codecs` module allows for unregistering codec search functions and clearing the registry's cache, introduced in version 3.10. While `open()` and the `io` module are preferred for handling encoded text files, `codecs` provides additional functions for working with binary files and specific codecs, including the `codecs.open()` function for opening encoded files.
---

codecs.unregister(_search_function_)[¶](https://docs.python.org/3/library/codecs.html#codecs.unregister "Link to this definition")
    
Unregister a codec search function and clear the registry’s cache. If the search function is not registered, do nothing.
Added in version 3.10.
While the builtin [`open()`](https://docs.python.org/3/library/functions.html#open "open") and the associated [`io`](https://docs.python.org/3/library/io.html#module-io "io: Core tools for working with streams.") module are the recommended approach for working with encoded text files, this module provides additional utility functions and classes that allow the use of a wider range of codecs when working with binary files: 

codecs.open(_filename_ , _mode ='r'_, _encoding =None_, _errors ='strict'_, _buffering =-1_)[¶](https://docs.python.org/3/library/codecs.html#codecs.open "Link to this definition")
    
Open an encoded file using the given _mode_ and return an instance of [`StreamReaderWriter`](https://docs.python.org/3/library/codecs.html#codecs.StreamReaderWriter "codecs.StreamReaderWriter"), providing transparent encoding/decoding. The default file mode is `'r'`, meaning to open the file in read mode.
Note
If _encoding_ is not `None`, then the underlying encoded files are always opened in binary mode. No automatic conversion of `'\n'` is done on reading and writing. The _mode_ argument may be any binary mode acceptable to the built-in [`open()`](https://docs.python.org/3/library/functions.html#open "open") function; the `'b'` is automatically added.
_encoding_ specifies the encoding which is to be used for the file. Any encoding that encodes to and decodes from bytes is allowed, and the data types supported by the file methods depend on the codec used.
_errors_ may be given to define the error handling. It defaults to `'strict'` which causes a [`ValueError`](https://docs.python.org/3/library/exceptions.html#ValueError "ValueError") to be raised in case an encoding error occurs.
_buffering_ has the same meaning as for the built-in [`open()`](https://docs.python.org/3/library/functions.html#open "open") function. It defaults to -1 which means that the default buffer size will be used.
Changed in version 3.11: The `'U'` mode has been removed. 

codecs.EncodedFile(_file_ , _data_encoding_ , _file_encoding =None_, _errors ='strict'_)[¶](https://docs.python.org/3/library/codecs.html#codecs.EncodedFile "Link to this definition")
    
Return a [`StreamRecoder`](https://docs.python.org/3/library/codecs.html#codecs.StreamRecoder "codecs.StreamRecoder") instance, a wrapped version of _file_ which provides transparent transcoding. The original file is closed when the wrapped version is closed.
Data written to the wrapped file is decoded according to the given _data_encoding_ and then written to the original file as bytes using _file_encoding_. Bytes read from the original file are decoded according to _file_encoding_ , and the result is encoded using _data_encoding_.
If _file_encoding_ is not given, it defaults to _data_encoding_.
_errors_ may be given to define the error handling. It defaults to `'strict'`, which causes [`ValueError`](https://docs.python.org/3/library/exceptions.html#ValueError "ValueError") to be raised in case an encoding error occurs. 

codecs.iterencode(_iterator_ , _encoding_ , _errors ='strict'_, _** kwargs_)[¶](https://docs.python.org/3/library/codecs.html#codecs.iterencode "Link to this definition")
    
Uses an incremental encoder to iteratively encode the input provided by _iterator_. This function is a [generator](https://docs.python.org/3/glossary.html#term-generator). The _errors_ argument (as well as any other keyword argument) is passed through to the incremental encoder.
This function requires that the codec accept text [`str`](https://docs.python.org/3/library/stdtypes.html#str "str") objects to encode. Therefore it does not support bytes-to-bytes encoders such as `base64_codec`. 

codecs.iterdecode(_iterator_ , _encoding_ , _errors ='strict'_, _** kwargs_)[¶](https://docs.python.org/3/library/codecs.html#codecs.iterdecode "Link to this definition")
    
Uses an incremental decoder to iteratively decode the input provided by _iterator_. This function is a [generator](https://docs.python.org/3/glossary.html#term-generator). The _errors_ argument (as well as any other keyword argument) is passed through to the incremental decoder.
This function requires that the codec accept [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "bytes") objects to decode. Therefore it does not support text-to-text encoders such as `rot_13`, although `rot_13` may be used equivalently with [`iterencode()`](https://docs.python.org/3/library/codecs.html#codecs.iterencode "codecs.iterencode").
The module also provides the following constants which are useful for reading and writing to platform dependent files: 

codecs.BOM[¶](https://docs.python.org/3/library/codecs.html#codecs.BOM "Link to this definition")