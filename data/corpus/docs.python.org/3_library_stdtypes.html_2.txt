Title: Boolean Operations in Python
URL: https://docs.python.org/3/library/stdtypes.html
Summary: This section discusses Boolean operations in Python, specifically `and`, `or`, and `not`, detailing their precedence and evaluation rules. It highlights that `or` and `and` are short-circuit operators and explains the return values for each operation.
---

Operations and built-in functions that have a Boolean result always return `0` or `False` for false and `1` or `True` for true, unless otherwise stated. (Important exception: the Boolean operations `or` and `and` always return one of their operands.)
## Boolean Operations — `and`, `or`, `not`[¶](https://docs.python.org/3/library/stdtypes.html#boolean-operations-and-or-not "Link to this heading")
These are the Boolean operations, ordered by ascending priority:
Operation | Result | Notes  
---|---|---  
`x or y` | if _x_ is true, then _x_ , else _y_ | (1)  
`x and y` | if _x_ is false, then _x_ , else _y_ | (2)  
`not x` | if _x_ is false, then `True`, else `False` | (3)  
Notes:
  1. This is a short-circuit operator, so it only evaluates the second argument if the first one is false.
  2. This is a short-circuit operator, so it only evaluates the second argument if the first one is true.
  3. `not` has a lower priority than non-Boolean operators, so `not a == b` is interpreted as `not (a == b)`, and `a == not b` is a syntax error.


## Comparisons[¶](https://docs.python.org/3/library/stdtypes.html#comparisons "Link to this heading")
There are eight comparison operations in Python. They all have the same priority (which is higher than that of the Boolean operations). Comparisons can be chained arbitrarily; for example, `x < y <= z` is equivalent to `x < y and y <= z`, except that _y_ is evaluated only once (but in both cases _z_ is not evaluated at all when `x < y` is found to be false).
This table summarizes the comparison operations:
Operation | Meaning  
---|---  
`<` | strictly less than  
`<=` | less than or equal  
`>` | strictly greater than  
`>=` | greater than or equal  
`==` | equal  
`!=` | not equal  
`is` | object identity  
`is not` | negated object identity  
Objects of different types, except different numeric types, never compare equal. The `==` operator is always defined but for some object types (for example, class objects) is equivalent to [`is`](https://docs.python.org/3/reference/expressions.html#is). The `<`, `<=`, `>` and `>=` operators are only defined where they make sense; for example, they raise a [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError "TypeError") exception when one of the arguments is a complex number.
Non-identical instances of a class normally compare as non-equal unless the class defines the [`__eq__()`](https://docs.python.org/3/reference/datamodel.html#object.__eq__ "object.__eq__") method.
Instances of a class cannot be ordered with respect to other instances of the same class, or other types of object, unless the class defines enough of the methods [`__lt__()`](https://docs.python.org/3/reference/datamodel.html#object.__lt__ "object.__lt__"), [`__le__()`](https://docs.python.org/3/reference/datamodel.html#object.__le__ "object.__le__"), [`__gt__()`](https://docs.python.org/3/reference/datamodel.html#object.__gt__ "object.__gt__"), and [`__ge__()`](https://docs.python.org/3/reference/datamodel.html#object.__ge__ "object.__ge__") (in general, [`__lt__()`](https://docs.python.org/3/reference/datamodel.html#object.__lt__ "object.__lt__") and [`__eq__()`](https://docs.python.org/3/reference/datamodel.html#object.__eq__ "object.__eq__") are sufficient, if you want the conventional meanings of the comparison operators).
The behavior of the [`is`](https://docs.python.org/3/reference/expressions.html#is) and [`is not`](https://docs.python.org/3/reference/expressions.html#is-not) operators cannot be customized; also they can be applied to any two objects and never raise an exception.
Two more operations with the same syntactic priority, [`in`](https://docs.python.org/3/reference/expressions.html#in) and [`not in`](https://docs.python.org/3/reference/expressions.html#not-in), are supported by types that are [iterable](https://docs.python.org/3/glossary.html#term-iterable) or implement the [`__contains__()`](https://docs.python.org/3/reference/datamodel.html#object.__contains__ "object.__contains__") method.
## Numeric Types — [`int`](https://docs.python.org/3/library/functions.html#int "int"), [`float`](https://docs.python.org/3/library/functions.html#float "float"), [`complex`](https://docs.python.org/3/library/functions.html#complex "complex")[¶](https://docs.python.org/3/library/stdtypes.html#numeric-types-int-float-complex "Link to this heading")
There are three distinct numeric types: _integers_ , _floating-point numbers_ , and _complex numbers_. In addition, Booleans are a subtype of integers. Integers have unlimited precision. Floating-point numbers are usually implemented using double in C; information about the precision and internal representation of floating-point numbers for the machine on which your program is running is available in [`sys.float_info`](https://docs.python.org/3/library/sys.html#sys.float_info "sys.float_info"). Complex numbers have a real and imaginary part, which are each a floating-point number. To extract these pa