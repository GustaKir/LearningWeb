Title: LoggingContext Class for Logger Management
URL: https://docs.python.org/3/howto/logging-cookbook.html
Summary: This section defines the `LoggingContext` class, a context manager for managing a logger's level and handlers. It temporarily changes the logging level and adds handlers for the duration of a `with` block, and restores the original state upon exit.
---

```
importlogging
importsys
classLoggingContext:
  def__init__(self, logger, level=None, handler=None, close=True):
    self.logger = logger
    self.level = level
    self.handler = handler
    self.close = close
  def__enter__(self):
    if self.level is not None:
      self.old_level = self.logger.level
      self.logger.setLevel(self.level)
    if self.handler:
      self.logger.addHandler(self.handler)
  def__exit__(self, et, ev, tb):
    if self.level is not None:
      self.logger.setLevel(self.old_level)
    if self.handler:
      self.logger.removeHandler(self.handler)
    if self.handler and self.close:
      self.handler.close()
    # implicit return of None => don't swallow exceptions

```

If you specify a level value, the logger’s level is set to that value in the scope of the with block covered by the context manager. If you specify a handler, it is added to the logger on entry to the block and removed on exit from the block. You can also ask the manager to close the handler for you on block exit - you could do this if you don’t need the handler any more.
To illustrate how it works, we can add the following block of code to the above:
```
if __name__ == '__main__':
  logger = logging.getLogger('foo')
  logger.addHandler(logging.StreamHandler())
  logger.setLevel(logging.INFO)
  logger.info('1. This should appear just once on stderr.')
  logger.debug('2. This should not appear.')
  with LoggingContext(logger, level=logging.DEBUG):
    logger.debug('3. This should appear once on stderr.')
  logger.debug('4. This should not appear.')
  h = logging.StreamHandler(sys.stdout)
  with LoggingContext(logger, level=logging.DEBUG, handler=h, close=True):
    logger.debug('5. This should appear twice - once on stderr and once on stdout.')
  logger.info('6. This should appear just once on stderr.')
  logger.debug('7. This should not appear.')

```

We initially set the logger’s level to `INFO`, so message #1 appears and message #2 doesn’t. We then change the level to `DEBUG` temporarily in the following `with` block, and so message #3 appears. After the block exits, the logger’s level is restored to `INFO` and so message #4 doesn’t appear. In the next `with` block, we set the level to `DEBUG` again but also add a handler writing to `sys.stdout`. Thus, message #5 appears twice on the console (once via `stderr` and once via `stdout`). After the `with` statement’s completion, the status is as it was before so message #6 appears (like message #1) whereas message #7 doesn’t (just like message #2).
If we run the resulting script, the result is as follows:
```
$ pythonlogctx.py
1. This should appear just once on stderr.
3. This should appear once on stderr.
5. This should appear twice - once on stderr and once on stdout.
5. This should appear twice - once on stderr and once on stdout.
6. This should appear just once on stderr.

```

If we run it again, but pipe `stderr` to `/dev/null`, we see the following, which is the only message written to `stdout`:
```
$ pythonlogctx.py2>/dev/null
5. This should appear twice - once on stderr and once on stdout.

```

Once again, but piping `stdout` to `/dev/null`, we get:
```
$ pythonlogctx.py>/dev/null
1. This should appear just once on stderr.
3. This should appear once on stderr.
5. This should appear twice - once on stderr and once on stdout.
6. This should appear just once on stderr.

```

In this case, the message #5 printed to `stdout` doesn’t appear, as expected.
Of course, the approach described here can be generalised, for example to attach logging filters temporarily. Note that the above code works in Python 2 as well as Python 3.
## A CLI application starter template[¶](https://docs.python.org/3/howto/logging-cookbook.html#a-cli-application-starter-template "Link to this heading")
Here’s an example which shows how you can:
  * Use a logging level based on command-line arguments
  * Dispatch to multiple subcommands in separate files, all logging at the same level in a consistent way
  * Make use of simple, minimal configuration


Suppose we have a command-line application whose job is to stop, start or restart some services. This could be organised for the purposes of illustration as a file `app.py` that is the main script for the application, with individual commands implemented in `start.py`, `stop.py` and `restart.py`. Suppose further that we want to control the verbosity of the application via a command-line argument, defaulting to `logging.INFO`. Here’s one way that `app.py` could be written: