Title: SSL Module Overview
URL: https://docs.python.org/3/library/ssl.html
Summary: The SSL module in Python provides functions to interact with Windows' system certificate store. The function ssl.enum_crls retrieves Certificate Revocation Lists (CRLs) based on the specified store name (CA, ROOT, MY) and returns a list of tuples containing certificate bytes, encoding type, and trust status. Additionally, all constants in the module are defined as enum.IntEnum or enum.IntFlag.
---

```

[Availability](https://docs.python.org/3/library/intro.html#availability): Windows.
Added in version 3.4. 

ssl.enum_crls(_store_name_)[¶](https://docs.python.org/3/library/ssl.html#ssl.enum_crls "Link to this definition")
    
Retrieve CRLs from Windows’ system cert store. _store_name_ may be one of `CA`, `ROOT` or `MY`. Windows may provide additional cert stores, too.
The function returns a list of (cert_bytes, encoding_type, trust) tuples. The encoding_type specifies the encoding of cert_bytes. It is either `x509_asn` for X.509 ASN.1 data or `pkcs_7_asn` for PKCS#7 ASN.1 data.
[Availability](https://docs.python.org/3/library/intro.html#availability): Windows.
Added in version 3.4.
### Constants[¶](https://docs.python.org/3/library/ssl.html#constants "Link to this heading")
> All constants are now [`enum.IntEnum`](https://docs.python.org/3/library/enum.html#enum.IntEnum "enum.IntEnum") or [`enum.IntFlag`](https://docs.python.org/3/library/enum.html#enum.IntFlag "enum.IntFlag") collections.
> Added in version 3.6. 

ssl.CERT_NONE[¶](https://docs.python.org/3/library/ssl.html#ssl.CERT_NONE "Link to this definition")
    
Possible value for [`SSLContext.verify_mode`](https://docs.python.org/3/library/ssl.html#ssl.SSLContext.verify_mode "ssl.SSLContext.verify_mode"). Except for [`PROTOCOL_TLS_CLIENT`](https://docs.python.org/3/library/ssl.html#ssl.PROTOCOL_TLS_CLIENT "ssl.PROTOCOL_TLS_CLIENT"), it is the default mode. With client-side sockets, just about any cert is accepted. Validation errors, such as untrusted or expired cert, are ignored and do not abort the TLS/SSL handshake.
In server mode, no certificate is requested from the client, so the client does not send any for client cert authentication.
See the discussion of [Security considerations](https://docs.python.org/3/library/ssl.html#ssl-security) below. 

ssl.CERT_OPTIONAL[¶](https://docs.python.org/3/library/ssl.html#ssl.CERT_OPTIONAL "Link to this definition")
    
Possible value for [`SSLContext.verify_mode`](https://docs.python.org/3/library/ssl.html#ssl.SSLContext.verify_mode "ssl.SSLContext.verify_mode"). In client mode, [`CERT_OPTIONAL`](https://docs.python.org/3/library/ssl.html#ssl.CERT_OPTIONAL "ssl.CERT_OPTIONAL") has the same meaning as [`CERT_REQUIRED`](https://docs.python.org/3/library/ssl.html#ssl.CERT_REQUIRED "ssl.CERT_REQUIRED"). It is recommended to use [`CERT_REQUIRED`](https://docs.python.org/3/library/ssl.html#ssl.CERT_REQUIRED "ssl.CERT_REQUIRED") for client-side sockets instead.
In server mode, a client certificate request is sent to the client. The client may either ignore the request or send a certificate in order perform TLS client cert authentication. If the client chooses to send a certificate, it is verified. Any verification error immediately aborts the TLS handshake.
Use of this setting requires a valid set of CA certificates to be passed to [`SSLContext.load_verify_locations()`](https://docs.python.org/3/library/ssl.html#ssl.SSLContext.load_verify_locations "ssl.SSLContext.load_verify_locations"). 

ssl.CERT_REQUIRED[¶](https://docs.python.org/3/library/ssl.html#ssl.CERT_REQUIRED "Link to this definition")
    
Possible value for [`SSLContext.verify_mode`](https://docs.python.org/3/library/ssl.html#ssl.SSLContext.verify_mode "ssl.SSLContext.verify_mode"). In this mode, certificates are required from the other side of the socket connection; an [`SSLError`](https://docs.python.org/3/library/ssl.html#ssl.SSLError "ssl.SSLError") will be raised if no certificate is provided, or if its validation fails. This mode is **not** sufficient to verify a certificate in client mode as it does not match hostnames. [`check_hostname`](https://docs.python.org/3/library/ssl.html#ssl.SSLContext.check_hostname "ssl.SSLContext.check_hostname") must be enabled as well to verify the authenticity of a cert. [`PROTOCOL_TLS_CLIENT`](https://docs.python.org/3/library/ssl.html#ssl.PROTOCOL_TLS_CLIENT "ssl.PROTOCOL_TLS_CLIENT") uses [`CERT_REQUIRED`](https://docs.python.org/3/library/ssl.html#ssl.CERT_REQUIRED "ssl.CERT_REQUIRED") and enables [`check_hostname`](https://docs.python.org/3/library/ssl.html#ssl.SSLContext.check_hostname "ssl.SSLContext.check_hostname") by default.
With server socket, this mode provides mandatory TLS client cert authentication. A client certificate request is sent to the client and the client must provide a valid and trusted certificate.
Use of this setting requires a valid set of CA certificates to be passed to [`SSLContext.load_verify_locations()`](https://docs.python.org/3/library/ssl.html#ssl.SSLContext.load_verify_locations "ssl.SSLContext.load_verify_locations"). 

_class_ ssl.VerifyMode[¶](https://docs.python.org/3/library/ssl.html#ssl.VerifyMode "Link to this definition")
    
[`enum.IntEnum`](https://docs.python.org/3/library/enum.html#enum.IntEnum "enum.IntEnum") collection of CERT_* constants.
Added in version 3.6.