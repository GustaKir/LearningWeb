Title: PEP 612: Parameter Specification Variables
URL: https://docs.python.org/3/whatsnew/3.10.html
Summary: This section introduces new options to enhance the information static type checkers receive for the `Callable` type from PEP 484. The key feature is the introduction of parameter specification variables in the `typing` module, enabling the forwarding of parameter types between callables.
---

```

See [Union Type](https://docs.python.org/3/library/stdtypes.html#types-union) and [**PEP 604**](https://peps.python.org/pep-0604/) for more details.
(Contributed by Maggie Moss and Philippe Prados in [bpo-41428](https://bugs.python.org/issue?@action=redirect&bpo=41428), with additions by Yurii Karabas and Serhiy Storchaka in [bpo-44490](https://bugs.python.org/issue?@action=redirect&bpo=44490).)
### PEP 612: Parameter Specification Variables[¶](https://docs.python.org/3/whatsnew/3.10.html#pep-612-parameter-specification-variables "Link to this heading")
Two new options to improve the information provided to static type checkers for [**PEP 484**](https://peps.python.org/pep-0484/)‘s `Callable` have been added to the [`typing`](https://docs.python.org/3/library/typing.html#module-typing "typing: Support for type hints \(see :pep:`484`\).") module.
The first is the parameter specification variable. They are used to forward the parameter types of one callable to another callable – a pattern commonly found in higher order functions and decorators. Examples of usage can be found in [`typing.ParamSpec`](https://docs.python.org/3/library/typing.html#typing.ParamSpec "typing.ParamSpec"). Previously, there was no easy way to type annotate dependency of parameter types in such a precise manner.
The second option is the new `Concatenate` operator. It’s used in conjunction with parameter specification variables to type annotate a higher order callable which adds or removes parameters of another callable. Examples of usage can be found in [`typing.Concatenate`](https://docs.python.org/3/library/typing.html#typing.Concatenate "typing.Concatenate").
See [`typing.Callable`](https://docs.python.org/3/library/typing.html#typing.Callable "typing.Callable"), [`typing.ParamSpec`](https://docs.python.org/3/library/typing.html#typing.ParamSpec "typing.ParamSpec"), [`typing.Concatenate`](https://docs.python.org/3/library/typing.html#typing.Concatenate "typing.Concatenate"), [`typing.ParamSpecArgs`](https://docs.python.org/3/library/typing.html#typing.ParamSpecArgs "typing.ParamSpecArgs"), [`typing.ParamSpecKwargs`](https://docs.python.org/3/library/typing.html#typing.ParamSpecKwargs "typing.ParamSpecKwargs"), and [**PEP 612**](https://peps.python.org/pep-0612/) for more details.
(Contributed by Ken Jin in [bpo-41559](https://bugs.python.org/issue?@action=redirect&bpo=41559), with minor enhancements by Jelle Zijlstra in [bpo-43783](https://bugs.python.org/issue?@action=redirect&bpo=43783). PEP written by Mark Mendoza.)
### PEP 613: TypeAlias[¶](https://docs.python.org/3/whatsnew/3.10.html#pep-613-typealias "Link to this heading")
[**PEP 484**](https://peps.python.org/pep-0484/) introduced the concept of type aliases, only requiring them to be top-level unannotated assignments. This simplicity sometimes made it difficult for type checkers to distinguish between type aliases and ordinary assignments, especially when forward references or invalid types were involved. Compare:
```
StrCache = 'Cache[str]' # a type alias
LOG_PREFIX = 'LOG[DEBUG]' # a module constant

```

Now the [`typing`](https://docs.python.org/3/library/typing.html#module-typing "typing: Support for type hints \(see :pep:`484`\).") module has a special value [`TypeAlias`](https://docs.python.org/3/library/typing.html#typing.TypeAlias "typing.TypeAlias") which lets you declare type aliases more explicitly:
```
StrCache: TypeAlias = 'Cache[str]' # a type alias
LOG_PREFIX = 'LOG[DEBUG]' # a module constant