Title: Understanding Python Type Hints
URL: https://docs.python.org/3/library/typing.html
Summary: This section of the documentation illustrates the use of type hints in Python, specifically focusing on the `list` and `Mapping` types. It highlights that `list` accepts only one type argument, leading to a type checker error when multiple types are provided. Additionally, it clarifies that `Mapping` requires exactly two type arguments for keys and values, contrasting this with tuples that can contain heterogeneous types.
---

```
fromcollections.abcimport Mapping
# Type checker will infer that all elements in ``x`` are meant to be ints
x: list[int] = []
# Type checker error: ``list`` only accepts a single type argument:
y: list[int, str] = [1, 'foo']
# Type checker will infer that all keys in ``z`` are meant to be strings,
# and that all values in ``z`` are meant to be either strings or ints
z: Mapping[str, str | int] = {}

```

[`list`](https://docs.python.org/3/library/stdtypes.html#list "list") only accepts one type argument, so a type checker would emit an error on the `y` assignment above. Similarly, [`Mapping`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Mapping "collections.abc.Mapping") only accepts two type arguments: the first indicates the type of the keys, and the second indicates the type of the values.
Unlike most other Python containers, however, it is common in idiomatic Python code for tuples to have elements which are not all of the same type. For this reason, tuples are special-cased in Python’s typing system. [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "tuple") accepts _any number_ of type arguments:
```
# OK: ``x`` is assigned to a tuple of length 1 where the sole element is an int
x: tuple[int] = (5,)
# OK: ``y`` is assigned to a tuple of length 2;
# element 1 is an int, element 2 is a str
y: tuple[int, str] = (5, "foo")
# Error: the type annotation indicates a tuple of length 1,
# but ``z`` has been assigned to a tuple of length 3
z: tuple[int] = (1, 2, 3)

```

To denote a tuple which could be of _any_ length, and in which all elements are of the same type `T`, use `tuple[T, ...]`. To denote an empty tuple, use `tuple[()]`. Using plain `tuple` as an annotation is equivalent to using `tuple[Any, ...]`:
```
x: tuple[int, ...] = (1, 2)
# These reassignments are OK: ``tuple[int, ...]`` indicates x can be of any length
x = (1, 2, 3)
x = ()
# This reassignment is an error: all elements in ``x`` must be ints
x = ("foo", "bar")
# ``y`` can only ever be assigned to an empty tuple
y: tuple[()] = ()
z: tuple = ("foo", "bar")
# These reassignments are OK: plain ``tuple`` is equivalent to ``tuple[Any, ...]``
z = (1, 2, 3)
z = ()

```

## The type of class objects[¶](https://docs.python.org/3/library/typing.html#the-type-of-class-objects "Link to this heading")
A variable annotated with `C` may accept a value of type `C`. In contrast, a variable annotated with `type[C]` (or deprecated [`typing.Type[C]`](https://docs.python.org/3/library/typing.html#typing.Type "typing.Type")) may accept values that are classes themselves – specifically, it will accept the _class object_ of `C`. For example:
```
a = 3     # Has type ``int``
b = int    # Has type ``type[int]``
c = type(a)  # Also has type ``type[int]``

```

Note that `type[C]` is covariant:
```
classUser: ...
classProUser(User): ...
classTeamUser(User): ...
defmake_new_user(user_class: type[User]) -> User:
  # ...
  return user_class()
make_new_user(User)   # OK
make_new_user(ProUser)  # Also OK: ``type[ProUser]`` is a subtype of ``type[User]``
make_new_user(TeamUser) # Still fine
make_new_user(User())  # Error: expected ``type[User]`` but got ``User``
make_new_user(int)    # Error: ``type[int]`` is not a subtype of ``type[User]``

```

The only legal parameters for [`type`](https://docs.python.org/3/library/functions.html#type "type") are classes, [`Any`](https://docs.python.org/3/library/typing.html#typing.Any "typing.Any"), [type variables](https://docs.python.org/3/library/typing.html#generics), and unions of any of these types. For example:
```
defnew_non_team_user(user_class: type[BasicUser | ProUser]): ...
new_non_team_user(BasicUser) # OK
new_non_team_user(ProUser)  # OK
new_non_team_user(TeamUser)  # Error: ``type[TeamUser]`` is not a subtype
               # of ``type[BasicUser | ProUser]``
new_non_team_user(User)    # Also an error

```

`type[Any]` is equivalent to [`type`](https://docs.python.org/3/library/functions.html#type "type"), which is the root of Python’s [metaclass hierarchy](https://docs.python.org/3/reference/datamodel.html#metaclasses).
## Annotating generators and coroutines[¶](https://docs.python.org/3/library/typing.html#annotating-generators-and-coroutines "Link to this heading")
A generator can be annotated using the generic type [`Generator[YieldType, SendType, ReturnType]`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Generator "collections.abc.Generator"). For example:
```
defecho_round() -> Generator[int, float, str]:
  sent = yield 0
  while sent >= 0:
    sent = yield round(sent)
  return 'Done'

```

Note that unlike many other generic classes in the standard library, the `SendType` of [`Generator`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Generator "collections.abc.Generator") behaves contravariantly, not covariantly or invariantly.
The `SendType` and `ReturnType` parameters default to `None`: