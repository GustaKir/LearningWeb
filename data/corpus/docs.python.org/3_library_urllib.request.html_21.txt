Title: User Authentication in urllib.request
URL: https://docs.python.org/3/library/urllib.request.html
Summary: The `prompt_user_passwd` function in the `urllib.request` module prompts the user for authentication details required for basic authentication at a specified host and realm, returning a tuple of (user, password). It is designed to be overridden for different interaction models. Additionally, the module supports HTTP, FTP, local files, and data URLs, with data URL support added in version 3.4.
---

prompt_user_passwd(_host_ , _realm_)[¶](https://docs.python.org/3/library/urllib.request.html#urllib.request.FancyURLopener.prompt_user_passwd "Link to this definition")
    
Return information needed to authenticate the user at the given host in the specified security realm. The return value should be a tuple, `(user, password)`, which can be used for basic authentication.
The implementation prompts for this information on the terminal; an application should override this method to use an appropriate interaction model in the local environment.
## [`urllib.request`](https://docs.python.org/3/library/urllib.request.html#module-urllib.request "urllib.request: Extensible library for opening URLs.") Restrictions[¶](https://docs.python.org/3/library/urllib.request.html#urllib-request-restrictions "Link to this heading")
  * Currently, only the following protocols are supported: HTTP (versions 0.9 and 1.0), FTP, local files, and data URLs.
Changed in version 3.4: Added support for data URLs.
  * The caching feature of [`urlretrieve()`](https://docs.python.org/3/library/urllib.request.html#urllib.request.urlretrieve "urllib.request.urlretrieve") has been disabled until someone finds the time to hack proper processing of Expiration time headers.
  * There should be a function to query whether a particular URL is in the cache.
  * For backward compatibility, if a URL appears to point to a local file but the file can’t be opened, the URL is re-interpreted using the FTP protocol. This can sometimes cause confusing error messages.
  * The [`urlopen()`](https://docs.python.org/3/library/urllib.request.html#urllib.request.urlopen "urllib.request.urlopen") and [`urlretrieve()`](https://docs.python.org/3/library/urllib.request.html#urllib.request.urlretrieve "urllib.request.urlretrieve") functions can cause arbitrarily long delays while waiting for a network connection to be set up. This means that it is difficult to build an interactive web client using these functions without using threads.
  * The data returned by [`urlopen()`](https://docs.python.org/3/library/urllib.request.html#urllib.request.urlopen "urllib.request.urlopen") or [`urlretrieve()`](https://docs.python.org/3/library/urllib.request.html#urllib.request.urlretrieve "urllib.request.urlretrieve") is the raw data returned by the server. This may be binary data (such as an image), plain text or (for example) HTML. The HTTP protocol provides type information in the reply header, which can be inspected by looking at the _Content-Type_ header. If the returned data is HTML, you can use the module [`html.parser`](https://docs.python.org/3/library/html.parser.html#module-html.parser "html.parser: A simple parser that can handle HTML and XHTML.") to parse it.
  * The code handling the FTP protocol cannot differentiate between a file and a directory. This can lead to unexpected behavior when attempting to read a URL that points to a file that is not accessible. If the URL ends in a `/`, it is assumed to refer to a directory and will be handled accordingly. But if an attempt to read a file leads to a 550 error (meaning the URL cannot be found or is not accessible, often for permission reasons), then the path is treated as a directory in order to handle the case when a directory is specified by a URL but the trailing `/` has been left off. This can cause misleading results when you try to fetch a file whose read permissions make it inaccessible; the FTP code will try to read it, fail with a 550 error, and then perform a directory listing for the unreadable file. If fine-grained control is needed, consider using the [`ftplib`](https://docs.python.org/3/library/ftplib.html#module-ftplib "ftplib: FTP protocol client \(requires sockets\).") module, subclassing [`FancyURLopener`](https://docs.python.org/3/library/urllib.request.html#urllib.request.FancyURLopener "urllib.request.FancyURLopener"), or changing __urlopener_ to meet your needs.


# [`urllib.response`](https://docs.python.org/3/library/urllib.request.html#module-urllib.response "urllib.response: Response classes used by urllib.") — Response classes used by urllib[¶](https://docs.python.org/3/library/urllib.request.html#module-urllib.response "Link to this heading")
The [`urllib.response`](https://docs.python.org/3/library/urllib.request.html#module-urllib.response "urllib.response: Response classes used by urllib.") module defines functions and classes which define a minimal file-like interface, including `read()` and `readline()`. Functions defined by this module are used internally by the [`urllib.request`](https://docs.python.org/3/library/urllib.request.html#module-urllib.request "urllib.request: Extensible library for opening URLs.") module. The typical response object is a [`urllib.response.addinfourl`](https://docs.python.org/3/library/urllib.request.html#urllib.response.addinfourl "urllib.response.addinfourl") instance: