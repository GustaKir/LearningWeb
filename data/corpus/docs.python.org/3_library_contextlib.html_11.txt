Title: Reusable Context Managers in Python
URL: https://docs.python.org/3/library/contextlib.html
Summary: This section explains the distinction between reentrant and reusable context managers in Python. It notes that reentrancy involves complex interactions between multiple functions and is different from thread safety, using `redirect_stdout()` as an example of a non-thread-safe function. The concept of reusable context managers, which can be used multiple times but are not necessarily reentrant, is introduced.
---

```

Real world examples of reentrancy are more likely to involve multiple functions calling each other and hence be far more complicated than this example.
Note also that being reentrant is _not_ the same thing as being thread safe. [`redirect_stdout()`](https://docs.python.org/3/library/contextlib.html#contextlib.redirect_stdout "contextlib.redirect_stdout"), for example, is definitely not thread safe, as it makes a global modification to the system state by binding [`sys.stdout`](https://docs.python.org/3/library/sys.html#sys.stdout "sys.stdout") to a different stream.
### Reusable context managers[¶](https://docs.python.org/3/library/contextlib.html#reusable-context-managers "Link to this heading")
Distinct from both single use and reentrant context managers are “reusable” context managers (or, to be completely explicit, “reusable, but not reentrant” context managers, since reentrant context managers are also reusable). These context managers support being used multiple times, but will fail (or otherwise not work correctly) if the specific context manager instance has already been used in a containing with statement.
[`threading.Lock`](https://docs.python.org/3/library/threading.html#threading.Lock "threading.Lock") is an example of a reusable, but not reentrant, context manager (for a reentrant lock, it is necessary to use [`threading.RLock`](https://docs.python.org/3/library/threading.html#threading.RLock "threading.RLock") instead).
Another example of a reusable, but not reentrant, context manager is [`ExitStack`](https://docs.python.org/3/library/contextlib.html#contextlib.ExitStack "contextlib.ExitStack"), as it invokes _all_ currently registered callbacks when leaving any with statement, regardless of where those callbacks were added:
>>>```
>>> fromcontextlibimport ExitStack
>>> stack = ExitStack()
>>> with stack:
...   stack.callback(print, "Callback: from first context")
...   print("Leaving first context")
...
Leaving first context
Callback: from first context
>>> with stack:
...   stack.callback(print, "Callback: from second context")
...   print("Leaving second context")
...
Leaving second context
Callback: from second context
>>> with stack:
...   stack.callback(print, "Callback: from outer context")
...   with stack:
...     stack.callback(print, "Callback: from inner context")
...     print("Leaving inner context")
...   print("Leaving outer context")
...
Leaving inner context
Callback: from inner context
Callback: from outer context
Leaving outer context

```

As the output from the example shows, reusing a single stack object across multiple with statements works correctly, but attempting to nest them will cause the stack to be cleared at the end of the innermost with statement, which is unlikely to be desirable behaviour.
Using separate [`ExitStack`](https://docs.python.org/3/library/contextlib.html#contextlib.ExitStack "contextlib.ExitStack") instances instead of reusing a single instance avoids that problem:
>>>```
>>> fromcontextlibimport ExitStack
>>> with ExitStack() as outer_stack:
...   outer_stack.callback(print, "Callback: from outer context")
...   with ExitStack() as inner_stack:
...     inner_stack.callback(print, "Callback: from inner context")
...     print("Leaving inner context")
...   print("Leaving outer context")
...
Leaving inner context
Callback: from inner context
Leaving outer context
Callback: from outer context