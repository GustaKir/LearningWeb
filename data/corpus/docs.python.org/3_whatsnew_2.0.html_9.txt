Title: Python 2.0 Changes and Compatibility
URL: https://docs.python.org/3/whatsnew/2.0.html
Summary: Python 2.0 introduces the ability to read and modify the maximum recursion depth via `sys.getrecursionlimit()` and `sys.setrecursionlimit()`, shifting from a fixed limit. This change aims to enhance error handling by preventing core dumps. The section also addresses compatibility efforts for transitioning to version 2.0.
---

```

can be reduced to a single `return dict.setdefault(key, [])` statement.
The interpreter sets a maximum recursion depth in order to catch runaway recursion before filling the C stack and causing a core dump or GPF.. Previously this limit was fixed when you compiled Python, but in 2.0 the maximum recursion depth can be read and modified using [`sys.getrecursionlimit()`](https://docs.python.org/3/library/sys.html#sys.getrecursionlimit "sys.getrecursionlimit") and [`sys.setrecursionlimit()`](https://docs.python.org/3/library/sys.html#sys.setrecursionlimit "sys.setrecursionlimit"). The default value is 1000, and a rough maximum value for a given platform can be found by running a new script, `Misc/find_recursionlimit.py`.
## Porting to 2.0[¶](https://docs.python.org/3/whatsnew/2.0.html#porting-to-2-0 "Link to this heading")
New Python releases try hard to be compatible with previous releases, and the record has been pretty good. However, some changes are considered useful enough, usually because they fix initial design decisions that turned out to be actively mistaken, that breaking backward compatibility can’t always be avoided. This section lists the changes in Python 2.0 that may cause old Python code to break.
The change which will probably break the most code is tightening up the arguments accepted by some methods. Some methods would take multiple arguments and treat them as a tuple, particularly various list methods such as `append()` and `insert()`. In earlier versions of Python, if `L` is a list, `L.append( 1,2 )` appends the tuple `(1,2)` to the list. In Python 2.0 this causes a [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError "TypeError") exception to be raised, with the message: ‘append requires exactly 1 argument; 2 given’. The fix is to simply add an extra set of parentheses to pass both values as a tuple: `L.append( (1,2) )`.
The earlier versions of these methods were more forgiving because they used an old function in Python’s C interface to parse their arguments; 2.0 modernizes them to use [`PyArg_ParseTuple()`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple "PyArg_ParseTuple"), the current argument parsing function, which provides more helpful error messages and treats multi-argument calls as errors. If you absolutely must use 2.0 but can’t fix your code, you can edit `Objects/listobject.c` and define the preprocessor symbol `NO_STRICT_LIST_APPEND` to preserve the old behaviour; this isn’t recommended.
Some of the functions in the [`socket`](https://docs.python.org/3/library/socket.html#module-socket "socket: Low-level networking interface.") module are still forgiving in this way. For example, `socket.connect( ('hostname', 25) )` is the correct form, passing a tuple representing an IP address, but `socket.connect('hostname', 25)` also works. [`socket.connect_ex`](https://docs.python.org/3/library/socket.html#socket.socket.connect_ex "socket.socket.connect_ex") and [`socket.bind`](https://docs.python.org/3/library/socket.html#socket.socket.bind "socket.socket.bind") are similarly easy-going. 2.0alpha1 tightened these functions up, but because the documentation actually used the erroneous multiple argument form, many people wrote code which would break with the stricter checking. GvR backed out the changes in the face of public reaction, so for the [`socket`](https://docs.python.org/3/library/socket.html#module-socket "socket: Low-level networking interface.") module, the documentation was fixed and the multiple argument form is simply marked as deprecated; it _will_ be tightened up again in a future Python version.
The `\x` escape in string literals now takes exactly 2 hex digits. Previously it would consume all the hex digits following the ‘x’ and take the lowest 8 bits of the result, so `\x123456` was equivalent to `\x56`.
The [`AttributeError`](https://docs.python.org/3/library/exceptions.html#AttributeError "AttributeError") and [`NameError`](https://docs.python.org/3/library/exceptions.html#NameError "NameError") exceptions have a more friendly error message, whose text will be something like `'Spam' instance has no attribute 'eggs'` or `name 'eggs' is not defined`. Previously the error message was just the missing attribute name `eggs`, and code written to take advantage of this fact will break in 2.0.
Some work has been done to make integers and long integers a bit more interchangeable. In 1.5.2, large-file support was added for Solaris, to allow reading files larger than 2 GiB; this made the `tell()` method of file objects return a long integer instead of a regular integer. Some code would subtract two file offsets and attempt to use the result to multiply a sequence or slice a string, but this raised a [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError "TypeError"). In 2.0, long integers can be used to multiply or slice a sequence, and it’ll behave as you’d intuitively expect it to; `3L * 'abc'` produces ‘abcabcabc’, and