Title: Email Policy Framework in Python 3.3
URL: https://docs.python.org/3/whatsnew/3.3.html
Summary: Python 3.3 introduces a policy framework to simplify message generation for applications by allowing users to set parameters like `linesep` in a single place. This framework supports custom policies for different message formats and ensures backward compatibility.
---

```

Policies can be used to make the generation of messages in the format needed by your application simpler. Instead of having to remember to specify `linesep='\r\n'` in all the places you call a `generator`, you can specify it once, when you set the policy used by the `parser` or the `Message`, whichever your program uses to create `Message` objects. On the other hand, if you need to generate messages in multiple forms, you can still specify the parameters in the appropriate `generator` call. Or you can have custom policy instances for your different cases, and pass those in when you create the `generator`.
#### Provisional Policy with New Header API[¶](https://docs.python.org/3/whatsnew/3.3.html#provisional-policy-with-new-header-api "Link to this heading")
While the policy framework is worthwhile all by itself, the main motivation for introducing it is to allow the creation of new policies that implement new features for the email package in a way that maintains backward compatibility for those who do not use the new policies. Because the new policies introduce a new API, we are releasing them in Python 3.3 as a [provisional policy](https://docs.python.org/3/glossary.html#term-provisional-package). Backwards incompatible changes (up to and including removal of the code) may occur if deemed necessary by the core developers.
The new policies are instances of [`EmailPolicy`](https://docs.python.org/3/library/email.policy.html#email.policy.EmailPolicy "email.policy.EmailPolicy"), and add the following additional controls:
refold_source | Controls whether or not headers parsed by a [`parser`](https://docs.python.org/3/library/email.parser.html#module-email.parser "email.parser: Parse flat text email messages to produce a message object structure.") are refolded by the [`generator`](https://docs.python.org/3/library/email.generator.html#module-email.generator "email.generator: Generate flat text email messages from a message structure."). It can be `none`, `long`, or `all`. The default is `long`, which means that source headers with a line longer than `max_line_length` get refolded. `none` means no line get refolded, and `all` means that all lines get refolded.  
---|---  
header_factory | A callable that take a `name` and `value` and produces a custom header object.  
The `header_factory` is the key to the new features provided by the new policies. When one of the new policies is used, any header retrieved from a `Message` object is an object produced by the `header_factory`, and any time you set a header on a `Message` it becomes an object produced by `header_factory`. All such header objects have a `name` attribute equal to the header name. Address and Date headers have additional attributes that give you access to the parsed data of the header. This means you can now do things like this:
>>>```
>>> m = Message(policy=SMTP)
>>> m['To'] = 'Éric <foo@example.com>'
>>> m['to']
'Éric <foo@example.com>'
>>> m['to'].addresses
(Address(display_name='Éric', username='foo', domain='example.com'),)
>>> m['to'].addresses[0].username
'foo'
>>> m['to'].addresses[0].display_name
'Éric'
>>> m['Date'] = email.utils.localtime()
>>> m['Date'].datetime
datetime.datetime(2012, 5, 25, 21, 39, 24, 465484, tzinfo=datetime.timezone(datetime.timedelta(-1, 72000), 'EDT'))
>>> m['Date']
'Fri, 25 May 2012 21:44:27 -0400'
>>> print(m)
To: =?utf-8?q?=C3=89ric?= <foo@example.com>
Date: Fri, 25 May 2012 21:44:27 -0400

```

You will note that the unicode display name is automatically encoded as `utf-8` when the message is serialized, but that when the header is accessed directly, you get the unicode version. This eliminates any need to deal with the [`email.header`](https://docs.python.org/3/library/email.header.html#module-email.header "email.header: Representing non-ASCII headers") [`decode_header()`](https://docs.python.org/3/library/email.header.html#email.header.decode_header "email.header.decode_header") or [`make_header()`](https://docs.python.org/3/library/email.header.html#email.header.make_header "email.header.make_header") functions.
You can also create addresses from parts:
>>>```
>>> m['cc'] = [Group('pals', [Address('Bob', 'bob', 'example.com'),
...              Address('Sally', 'sally', 'example.com')]),
...       Address('Bonzo', addr_spec='bonz@laugh.com')]
>>> print(m)
To: =?utf-8?q?=C3=89ric?= <foo@example.com>
Date: Fri, 25 May 2012 21:44:27 -0400
cc: pals: Bob <bob@example.com>, Sally <sally@example.com>;, Bonzo <bonz@laugh.com>

```

Decoding to unicode is done automatically:
>>>```
>>> m2 = message_from_string(str(m))
>>> m2['to']
'Éric <foo@example.com>'

```

When you parse a message, you can use the `addresses` and `groups` attributes of the header objects to access the groups and individual addresses:
>>>