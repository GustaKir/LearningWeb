Title: Descriptors in Python
URL: https://docs.python.org/3/glossary.html
Summary: Descriptors are objects that implement the methods __get__(), __set__(), or __delete__(), allowing for custom behavior when accessing class attributes. This section references decorators related to functions and classes, highlighting the special binding behavior associated with descriptors.
---

```

The same concept exists for classes, but is less commonly used there. See the documentation for [function definitions](https://docs.python.org/3/reference/compound_stmts.html#function) and [class definitions](https://docs.python.org/3/reference/compound_stmts.html#class) for more about decorators. 

descriptor[¶](https://docs.python.org/3/glossary.html#term-descriptor "Link to this term")
    
Any object which defines the methods [`__get__()`](https://docs.python.org/3/reference/datamodel.html#object.__get__ "object.__get__"), [`__set__()`](https://docs.python.org/3/reference/datamodel.html#object.__set__ "object.__set__"), or [`__delete__()`](https://docs.python.org/3/reference/datamodel.html#object.__delete__ "object.__delete__"). When a class attribute is a descriptor, its special binding behavior is triggered upon attribute lookup. Normally, using _a.b_ to get, set or delete an attribute looks up the object named _b_ in the class dictionary for _a_ , but if _b_ is a descriptor, the respective descriptor method gets called. Understanding descriptors is a key to a deep understanding of Python because they are the basis for many features including functions, methods, properties, class methods, static methods, and reference to super classes.
For more information about descriptors’ methods, see [Implementing Descriptors](https://docs.python.org/3/reference/datamodel.html#descriptors) or the [Descriptor How To Guide](https://docs.python.org/3/howto/descriptor.html#descriptorhowto). 

dictionary[¶](https://docs.python.org/3/glossary.html#term-dictionary "Link to this term")
    
An associative array, where arbitrary keys are mapped to values. The keys can be any object with [`__hash__()`](https://docs.python.org/3/reference/datamodel.html#object.__hash__ "object.__hash__") and [`__eq__()`](https://docs.python.org/3/reference/datamodel.html#object.__eq__ "object.__eq__") methods. Called a hash in Perl. 

dictionary comprehension[¶](https://docs.python.org/3/glossary.html#term-dictionary-comprehension "Link to this term")
    
A compact way to process all or part of the elements in an iterable and return a dictionary with the results. `results = {n: n ** 2 for n in range(10)}` generates a dictionary containing key `n` mapped to value `n ** 2`. See [Displays for lists, sets and dictionaries](https://docs.python.org/3/reference/expressions.html#comprehensions). 

dictionary view[¶](https://docs.python.org/3/glossary.html#term-dictionary-view "Link to this term")
    
The objects returned from [`dict.keys()`](https://docs.python.org/3/library/stdtypes.html#dict.keys "dict.keys"), [`dict.values()`](https://docs.python.org/3/library/stdtypes.html#dict.values "dict.values"), and [`dict.items()`](https://docs.python.org/3/library/stdtypes.html#dict.items "dict.items") are called dictionary views. They provide a dynamic view on the dictionary’s entries, which means that when the dictionary changes, the view reflects these changes. To force the dictionary view to become a full list use `list(dictview)`. See [Dictionary view objects](https://docs.python.org/3/library/stdtypes.html#dict-views). 

docstring[¶](https://docs.python.org/3/glossary.html#term-docstring "Link to this term")
    
A string literal which appears as the first expression in a class, function or module. While ignored when the suite is executed, it is recognized by the compiler and put into the [`__doc__`](https://docs.python.org/3/library/stdtypes.html#definition.__doc__ "definition.__doc__") attribute of the enclosing class, function or module. Since it is available via introspection, it is the canonical place for documentation of the object. 

duck-typing[¶](https://docs.python.org/3/glossary.html#term-duck-typing "Link to this term")
    
A programming style which does not look at an object’s type to determine if it has the right interface; instead, the method or attribute is simply called or used (“If it looks like a duck and quacks like a duck, it must be a duck.”) By emphasizing interfaces rather than specific types, well-designed code improves its flexibility by allowing polymorphic substitution. Duck-typing avoids tests using [`type()`](https://docs.python.org/3/library/functions.html#type "type") or [`isinstance()`](https://docs.python.org/3/library/functions.html#isinstance "isinstance"). (Note, however, that duck-typing can be complemented with [abstract base classes](https://docs.python.org/3/glossary.html#term-abstract-base-class).) Instead, it typically employs [`hasattr()`](https://docs.python.org/3/library/functions.html#hasattr "hasattr") tests or [EAFP](https://docs.python.org/3/glossary.html#term-EAFP) programming.