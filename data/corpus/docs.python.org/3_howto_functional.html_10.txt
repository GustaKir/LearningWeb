Title: Calling Functions on Elements
URL: https://docs.python.org/3/howto/functional.html
Summary: This section discusses the `operator` module, which provides functions corresponding to Python's operators. It highlights examples like `operator.add`, `operator.ne`, and `operator.attrgetter`. Additionally, it introduces `itertools.starmap`, which applies a function to elements of an iterable containing tuples.
---

```

### Calling functions on elements[¶](https://docs.python.org/3/howto/functional.html#calling-functions-on-elements "Link to this heading")
The [`operator`](https://docs.python.org/3/library/operator.html#module-operator "operator: Functions corresponding to the standard operators.") module contains a set of functions corresponding to Python’s operators. Some examples are [`operator.add(a, b)`](https://docs.python.org/3/library/operator.html#operator.add "operator.add") (adds two values), [`operator.ne(a, b)`](https://docs.python.org/3/library/operator.html#operator.ne "operator.ne") (same as `a != b`), and [`operator.attrgetter('id')`](https://docs.python.org/3/library/operator.html#operator.attrgetter "operator.attrgetter") (returns a callable that fetches the `.id` attribute).
[`itertools.starmap(func, iter)`](https://docs.python.org/3/library/itertools.html#itertools.starmap "itertools.starmap") assumes that the iterable will return a stream of tuples, and calls _func_ using these tuples as the arguments:
```
itertools.starmap(os.path.join,
         [('/bin', 'python'), ('/usr', 'bin', 'java'),
          ('/usr', 'bin', 'perl'), ('/usr', 'bin', 'ruby')])
=>
 /bin/python, /usr/bin/java, /usr/bin/perl, /usr/bin/ruby

```

### Selecting elements[¶](https://docs.python.org/3/howto/functional.html#selecting-elements "Link to this heading")
Another group of functions chooses a subset of an iterator’s elements based on a predicate.
[`itertools.filterfalse(predicate, iter)`](https://docs.python.org/3/library/itertools.html#itertools.filterfalse "itertools.filterfalse") is the opposite of [`filter()`](https://docs.python.org/3/library/functions.html#filter "filter"), returning all elements for which the predicate returns false:
```
itertools.filterfalse(is_even, itertools.count()) =>
 1, 3, 5, 7, 9, 11, 13, 15, ...

```

[`itertools.takewhile(predicate, iter)`](https://docs.python.org/3/library/itertools.html#itertools.takewhile "itertools.takewhile") returns elements for as long as the predicate returns true. Once the predicate returns false, the iterator will signal the end of its results.
```
defless_than_10(x):
  return x < 10
itertools.takewhile(less_than_10, itertools.count()) =>
 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
itertools.takewhile(is_even, itertools.count()) =>
 0

```

[`itertools.dropwhile(predicate, iter)`](https://docs.python.org/3/library/itertools.html#itertools.dropwhile "itertools.dropwhile") discards elements while the predicate returns true, and then returns the rest of the iterable’s results.
```
itertools.dropwhile(less_than_10, itertools.count()) =>
 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, ...
itertools.dropwhile(is_even, itertools.count()) =>
 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...

```

[`itertools.compress(data, selectors)`](https://docs.python.org/3/library/itertools.html#itertools.compress "itertools.compress") takes two iterators and returns only those elements of _data_ for which the corresponding element of _selectors_ is true, stopping whenever either one is exhausted:
```
itertools.compress([1, 2, 3, 4, 5], [True, True, False, False, True]) =>
  1, 2, 5

```

### Combinatoric functions[¶](https://docs.python.org/3/howto/functional.html#combinatoric-functions "Link to this heading")
The [`itertools.combinations(iterable, r)`](https://docs.python.org/3/library/itertools.html#itertools.combinations "itertools.combinations") returns an iterator giving all possible _r_ -tuple combinations of the elements contained in _iterable_.
```
itertools.combinations([1, 2, 3, 4, 5], 2) =>
 (1, 2), (1, 3), (1, 4), (1, 5),
 (2, 3), (2, 4), (2, 5),
 (3, 4), (3, 5),
 (4, 5)
itertools.combinations([1, 2, 3, 4, 5], 3) =>
 (1, 2, 3), (1, 2, 4), (1, 2, 5), (1, 3, 4), (1, 3, 5), (1, 4, 5),
 (2, 3, 4), (2, 3, 5), (2, 4, 5),
 (3, 4, 5)

```

The elements within each tuple remain in the same order as _iterable_ returned them. For example, the number 1 is always before 2, 3, 4, or 5 in the examples above. A similar function, [`itertools.permutations(iterable, r=None)`](https://docs.python.org/3/library/itertools.html#itertools.permutations "itertools.permutations"), removes this constraint on the order, returning all possible arrangements of length _r_ :
```
itertools.permutations([1, 2, 3, 4, 5], 2) =>
 (1, 2), (1, 3), (1, 4), (1, 5),
 (2, 1), (2, 3), (2, 4), (2, 5),
 (3, 1), (3, 2), (3, 4), (3, 5),
 (4, 1), (4, 2), (4, 3), (4, 5),
 (5, 1), (5, 2), (5, 3), (5, 4)
itertools.permutations([1, 2, 3, 4, 5]) =>
 (1, 2, 3, 4, 5), (1, 2, 3, 5, 4), (1, 2, 4, 3, 5),
 ...
 (5, 4, 3, 2, 1)

```

If you don’t supply a value for _r_ the length of the iterable is used, meaning that all the elements are permuted.
Note that these functions produce all of the possible combinations by position and don’t require that the contents of _iterable_ are unique:
```
itertools.permutations('aba', 3) =>
 ('a', 'b', 'a'), ('a', 'a', 'b'), ('b', 'a', 'a'),
 ('b', 'a', 'a'), ('a', 'a', 'b'), ('a', 'b', 'a')