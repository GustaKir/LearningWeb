Title: Automatic Name Notification in Descriptors
URL: https://docs.python.org/3/howto/descriptor.html
Summary: This section discusses how descriptors in Python can automatically receive notifications about the class variable name they are assigned to via the `__set_name__()` method. It explains the role of the `type` metaclass during class creation and the implementation details in `type_new()` and `set_names()`. The mechanism ensures that descriptors are aware of their context within a class.
---

### [Automatic name notification](https://docs.python.org/3/howto/descriptor.html#id21)[¶](https://docs.python.org/3/howto/descriptor.html#automatic-name-notification "Link to this heading")
Sometimes it is desirable for a descriptor to know what class variable name it was assigned to. When a new class is created, the [`type`](https://docs.python.org/3/library/functions.html#type "type") metaclass scans the dictionary of the new class. If any of the entries are descriptors and if they define [`__set_name__()`](https://docs.python.org/3/reference/datamodel.html#object.__set_name__ "object.__set_name__"), that method is called with two arguments. The _owner_ is the class where the descriptor is used, and the _name_ is the class variable the descriptor was assigned to.
The implementation details are in `type_new()` and `set_names()` in [Objects/typeobject.c](https://github.com/python/cpython/tree/3.13/Objects/typeobject.c).
Since the update logic is in `type.__new__()`, notifications only take place at the time of class creation. If descriptors are added to the class afterwards, [`__set_name__()`](https://docs.python.org/3/reference/datamodel.html#object.__set_name__ "object.__set_name__") will need to be called manually.
### [ORM example](https://docs.python.org/3/howto/descriptor.html#id22)[¶](https://docs.python.org/3/howto/descriptor.html#orm-example "Link to this heading")
The following code is a simplified skeleton showing how data descriptors could be used to implement an [object relational mapping](https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping).
The essential idea is that the data is stored in an external database. The Python instances only hold keys to the database’s tables. Descriptors take care of lookups or updates:
```
classField:
  def__set_name__(self, owner, name):
    self.fetch = f'SELECT {name} FROM {owner.table} WHERE {owner.key}=?;'
    self.store = f'UPDATE {owner.table} SET {name}=? WHERE {owner.key}=?;'
  def__get__(self, obj, objtype=None):
    return conn.execute(self.fetch, [obj.key]).fetchone()[0]
  def__set__(self, obj, value):
    conn.execute(self.store, [value, obj.key])
    conn.commit()

```

We can use the `Field` class to define [models](https://en.wikipedia.org/wiki/Database_model) that describe the schema for each table in a database:
```
classMovie:
  table = 'Movies'          # Table name
  key = 'title'            # Primary key
  director = Field()
  year = Field()
  def__init__(self, key):
    self.key = key
classSong:
  table = 'Music'
  key = 'title'
  artist = Field()
  year = Field()
  genre = Field()
  def__init__(self, key):
    self.key = key

```

To use the models, first connect to the database:
>>>```
>>> importsqlite3
>>> conn = sqlite3.connect('entertainment.db')

```

An interactive session shows how data is retrieved from the database and how it can be updated:
>>>```
>>> Movie('Star Wars').director
'George Lucas'
>>> jaws = Movie('Jaws')
>>> f'Released in {jaws.year} by {jaws.director}'
'Released in 1975 by Steven Spielberg'
>>> Song('Country Roads').artist
'John Denver'
>>> Movie('Star Wars').director = 'J.J. Abrams'
>>> Movie('Star Wars').director
'J.J. Abrams'

```

## [Pure Python Equivalents](https://docs.python.org/3/howto/descriptor.html#id23)[¶](https://docs.python.org/3/howto/descriptor.html#pure-python-equivalents "Link to this heading")
The descriptor protocol is simple and offers exciting possibilities. Several use cases are so common that they have been prepackaged into built-in tools. Properties, bound methods, static methods, class methods, and __slots__ are all based on the descriptor protocol.
### [Properties](https://docs.python.org/3/howto/descriptor.html#id24)[¶](https://docs.python.org/3/howto/descriptor.html#properties "Link to this heading")
Calling [`property()`](https://docs.python.org/3/library/functions.html#property "property") is a succinct way of building a data descriptor that triggers a function call upon access to an attribute. Its signature is:
```
property(fget=None, fset=None, fdel=None, doc=None) -> property

```

The documentation shows a typical use to define a managed attribute `x`:
```
classC:
  defgetx(self): return self.__x
  defsetx(self, value): self.__x = value
  defdelx(self): del self.__x
  x = property(getx, setx, delx, "I'm the 'x' property.")

```

To see how [`property()`](https://docs.python.org/3/library/functions.html#property "property") is implemented in terms of the descriptor protocol, here is a pure Python equivalent that implements most of the core functionality: