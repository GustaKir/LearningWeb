Title: Implementing Structured Logging
URL: https://docs.python.org/3/howto/logging-cookbook.html
Summary: This section details how to ensure that messages produced by `SysLogHandler` are RFC 5424-compliant when encoded in UTF-8. It outlines the need to replace sections of data with appropriate placeholders, maintaining ASCII compliance for certain parts while allowing Unicode characters in others to guarantee proper encoding.
---

```

The Unicode code point U+FEFF, when encoded using UTF-8, will be encoded as a UTF-8 BOM – the byte-string `b'\xef\xbb\xbf'`.
  2. Replace the ASCII section with whatever placeholders you like, but make sure that the data that appears in there after substitution is always ASCII (that way, it will remain unchanged after UTF-8 encoding).
  3. Replace the Unicode section with whatever placeholders you like; if the data which appears there after substitution contains characters outside the ASCII range, that’s fine – it will be encoded using UTF-8.


The formatted message _will_ be encoded using UTF-8 encoding by `SysLogHandler`. If you follow the above rules, you should be able to produce [**RFC 5424**](https://datatracker.ietf.org/doc/html/rfc5424.html)-compliant messages. If you don’t, logging may not complain, but your messages will not be RFC 5424-compliant, and your syslog daemon may complain.
## Implementing structured logging[¶](https://docs.python.org/3/howto/logging-cookbook.html#implementing-structured-logging "Link to this heading")
Although most logging messages are intended for reading by humans, and thus not readily machine-parseable, there might be circumstances where you want to output messages in a structured format which _is_ capable of being parsed by a program (without needing complex regular expressions to parse the log message). This is straightforward to achieve using the logging package. There are a number of ways in which this could be achieved, but the following is a simple approach which uses JSON to serialise the event in a machine-parseable manner:
```
importjson
importlogging
classStructuredMessage:
  def__init__(self, message, /, **kwargs):
    self.message = message
    self.kwargs = kwargs
  def__str__(self):
    return '%s >>> %s' % (self.message, json.dumps(self.kwargs))
_ = StructuredMessage  # optional, to improve readability
logging.basicConfig(level=logging.INFO, format='%(message)s')
logging.info(_('message 1', foo='bar', bar='baz', num=123, fnum=123.456))

```

If the above script is run, it prints:
```
message 1 >>> {"fnum": 123.456, "num": 123, "bar": "baz", "foo": "bar"}

```

Note that the order of items might be different according to the version of Python used.
If you need more specialised processing, you can use a custom JSON encoder, as in the following complete example:
```
importjson
importlogging

classEncoder(json.JSONEncoder):
  defdefault(self, o):
    if isinstance(o, set):
      return tuple(o)
    elif isinstance(o, str):
      return o.encode('unicode_escape').decode('ascii')
    return super().default(o)
classStructuredMessage:
  def__init__(self, message, /, **kwargs):
    self.message = message
    self.kwargs = kwargs
  def__str__(self):
    s = Encoder().encode(self.kwargs)
    return '%s >>> %s' % (self.message, s)
_ = StructuredMessage  # optional, to improve readability
defmain():
  logging.basicConfig(level=logging.INFO, format='%(message)s')
  logging.info(_('message 1', set_value={1, 2, 3}, snowman='\u2603'))
if __name__ == '__main__':
  main()

```

When the above script is run, it prints:
```
message 1 >>> {"snowman": "\u2603", "set_value": [1, 2, 3]}

```

Note that the order of items might be different according to the version of Python used.
## Customizing handlers with [`dictConfig()`](https://docs.python.org/3/library/logging.config.html#logging.config.dictConfig "logging.config.dictConfig")[¶](https://docs.python.org/3/howto/logging-cookbook.html#customizing-handlers-with-dictconfig "Link to this heading")
There are times when you want to customize logging handlers in particular ways, and if you use [`dictConfig()`](https://docs.python.org/3/library/logging.config.html#logging.config.dictConfig "logging.config.dictConfig") you may be able to do this without subclassing. As an example, consider that you may want to set the ownership of a log file. On POSIX, this is easily done using [`shutil.chown()`](https://docs.python.org/3/library/shutil.html#shutil.chown "shutil.chown"), but the file handlers in the stdlib don’t offer built-in support. You can customize handler creation using a plain function such as:
```
defowned_file_handler(filename, mode='a', encoding=None, owner=None):
  if owner:
    if not os.path.exists(filename):
      open(filename, 'a').close()
    shutil.chown(filename, *owner)
  return logging.FileHandler(filename, mode, encoding)

```

You can then specify, in a logging configuration passed to [`dictConfig()`](https://docs.python.org/3/library/logging.config.html#logging.config.dictConfig "logging.config.dictConfig"), that a logging handler be created by calling this function: