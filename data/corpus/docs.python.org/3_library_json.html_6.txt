Title: JSON Decoding in Python
URL: https://docs.python.org/3/library/json.html
Summary: This section covers the methods for decoding JSON documents in Python using the `json` library. The `decode` method converts a JSON string into a Python representation, raising a `JSONDecodeError` for invalid documents. The `raw_decode` method decodes a JSON document from a string, returning the Python representation and the position index where the document ended, allowing for extraneous data handling.
---

decode(_s_)[¶](https://docs.python.org/3/library/json.html#json.JSONDecoder.decode "Link to this definition")
    
Return the Python representation of _s_ (a [`str`](https://docs.python.org/3/library/stdtypes.html#str "str") instance containing a JSON document).
[`JSONDecodeError`](https://docs.python.org/3/library/json.html#json.JSONDecodeError "json.JSONDecodeError") will be raised if the given JSON document is not valid. 

raw_decode(_s_)[¶](https://docs.python.org/3/library/json.html#json.JSONDecoder.raw_decode "Link to this definition")
    
Decode a JSON document from _s_ (a [`str`](https://docs.python.org/3/library/stdtypes.html#str "str") beginning with a JSON document) and return a 2-tuple of the Python representation and the index in _s_ where the document ended.
This can be used to decode a JSON document from a string that may have extraneous data at the end. 

_class_ json.JSONEncoder(_*_ , _skipkeys =False_, _ensure_ascii =True_, _check_circular =True_, _allow_nan =True_, _sort_keys =False_, _indent =None_, _separators =None_, _default =None_)[¶](https://docs.python.org/3/library/json.html#json.JSONEncoder "Link to this definition")
    
Extensible JSON encoder for Python data structures.
Supports the following objects and types by default:
Python | JSON  
---|---  
dict | object  
list, tuple | array  
str | string  
int, float, int- & float-derived Enums | number  
True | true  
False | false  
None | null  
Changed in version 3.4: Added support for int- and float-derived Enum classes.
To extend this to recognize other objects, subclass and implement a [`default()`](https://docs.python.org/3/library/json.html#json.JSONEncoder.default "json.JSONEncoder.default") method with another method that returns a serializable object for `o` if possible, otherwise it should call the superclass implementation (to raise [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError "TypeError")).
If _skipkeys_ is false (the default), a [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError "TypeError") will be raised when trying to encode keys that are not [`str`](https://docs.python.org/3/library/stdtypes.html#str "str"), [`int`](https://docs.python.org/3/library/functions.html#int "int"), [`float`](https://docs.python.org/3/library/functions.html#float "float"), [`bool`](https://docs.python.org/3/library/functions.html#bool "bool") or `None`. If _skipkeys_ is true, such items are simply skipped.
If _ensure_ascii_ is true (the default), the output is guaranteed to have all incoming non-ASCII characters escaped. If _ensure_ascii_ is false, these characters will be output as-is.
If _check_circular_ is true (the default), then lists, dicts, and custom encoded objects will be checked for circular references during encoding to prevent an infinite recursion (which would cause a [`RecursionError`](https://docs.python.org/3/library/exceptions.html#RecursionError "RecursionError")). Otherwise, no such check takes place.
If _allow_nan_ is true (the default), then `NaN`, `Infinity`, and `-Infinity` will be encoded as such. This behavior is not JSON specification compliant, but is consistent with most JavaScript based encoders and decoders. Otherwise, it will be a [`ValueError`](https://docs.python.org/3/library/exceptions.html#ValueError "ValueError") to encode such floats.
If _sort_keys_ is true (default: `False`), then the output of dictionaries will be sorted by key; this is useful for regression tests to ensure that JSON serializations can be compared on a day-to-day basis.
If _indent_ is a non-negative integer or string, then JSON array elements and object members will be pretty-printed with that indent level. An indent level of 0, negative, or `""` will only insert newlines. `None` (the default) selects the most compact representation. Using a positive integer indent indents that many spaces per level. If _indent_ is a string (such as `"\t"`), that string is used to indent each level.
Changed in version 3.2: Allow strings for _indent_ in addition to integers.
If specified, _separators_ should be an `(item_separator, key_separator)` tuple. The default is `(', ', ': ')` if _indent_ is `None` and `(',', ': ')` otherwise. To get the most compact JSON representation, you should specify `(',', ':')` to eliminate whitespace.
Changed in version 3.4: Use `(',', ': ')` as default if _indent_ is not `None`.
If specified, _default_ should be a function that gets called for objects that can’t otherwise be serialized. It should return a JSON encodable version of the object or raise a [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError "TypeError"). If not specified, [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError "TypeError") is raised.
Changed in version 3.6: All parameters are now [keyword-only](https://docs.python.org/3/glossary.html#keyword-only-parameter).