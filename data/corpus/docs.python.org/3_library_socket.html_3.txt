Title: Python Socket Library: AF_VSOCK and AF_PACKET
URL: https://docs.python.org/3/library/socket.html
Summary: This documentation chunk discusses the AF_VSOCK and AF_PACKET socket types in Python's socket library. AF_VSOCK facilitates communication between virtual machines and their hosts, using a (CID, port) tuple, and is available on Linux >= 3.9. AF_PACKET is mentioned as a low-level socket type, with details on its availability and versions.
---

k]])`, where:
    * _type_ is the algorithm type as string, e.g. `aead`, `hash`, `skcipher` or `rng`.
    * _name_ is the algorithm name and operation mode as string, e.g. `sha256`, `hmac(sha256)`, `cbc(aes)` or `drbg_nopr_ctr_aes256`.
    * _feat_ and _mask_ are unsigned 32bit integers.
[Availability](https://docs.python.org/3/library/intro.html#availability): Linux >= 2.6.38.
Some algorithm types require more recent Kernels.
Added in version 3.6.
  * [`AF_VSOCK`](https://docs.python.org/3/library/socket.html#socket.AF_VSOCK "socket.AF_VSOCK") allows communication between virtual machines and their hosts. The sockets are represented as a `(CID, port)` tuple where the context ID or CID and port are integers.
[Availability](https://docs.python.org/3/library/intro.html#availability): Linux >= 3.9
See _[vsock(7)](https://manpages.debian.org/vsock\(7\))_
Added in version 3.7.
  * [`AF_PACKET`](https://docs.python.org/3/library/socket.html#socket.AF_PACKET "socket.AF_PACKET") is a low-level interface directly to network devices. The addresses are represented by the tuple `(ifname, proto[, pkttype[, hatype[, addr]]])` where:
    * _ifname_ - String specifying the device name.
    * _proto_ - The Ethernet protocol number. May be [`ETH_P_ALL`](https://docs.python.org/3/library/socket.html#socket.ETH_P_ALL "socket.ETH_P_ALL") to capture all protocols, one of the [ETHERTYPE_* constants](https://docs.python.org/3/library/socket.html#socket-ethernet-types) or any other Ethernet protocol number.
    * _pkttype_ - Optional integer specifying the packet type:
      * `PACKET_HOST` (the default) - Packet addressed to the local host.
      * `PACKET_BROADCAST` - Physical-layer broadcast packet.
      * `PACKET_MULTICAST` - Packet sent to a physical-layer multicast address.
      * `PACKET_OTHERHOST` - Packet to some other host that has been caught by a device driver in promiscuous mode.
      * `PACKET_OUTGOING` - Packet originating from the local host that is looped back to a packet socket.
    * _hatype_ - Optional integer specifying the ARP hardware address type.
    * _addr_ - Optional bytes-like object specifying the hardware physical address, whose interpretation depends on the device.
[Availability](https://docs.python.org/3/library/intro.html#availability): Linux >= 2.2.
  * [`AF_QIPCRTR`](https://docs.python.org/3/library/socket.html#socket.AF_QIPCRTR "socket.AF_QIPCRTR") is a Linux-only socket based interface for communicating with services running on co-processors in Qualcomm platforms. The address family is represented as a `(node, port)` tuple where the _node_ and _port_ are non-negative integers.
[Availability](https://docs.python.org/3/library/intro.html#availability): Linux >= 4.7.
Added in version 3.8.
  * `IPPROTO_UDPLITE` is a variant of UDP which allows you to specify what portion of a packet is covered with the checksum. It adds two socket options that you can change. `self.setsockopt(IPPROTO_UDPLITE, UDPLITE_SEND_CSCOV, length)` will change what portion of outgoing packets are covered by the checksum and `self.setsockopt(IPPROTO_UDPLITE, UDPLITE_RECV_CSCOV, length)` will filter out packets which cover too little of their data. In both cases `length` should be in `range(8, 2**16, 8)`.
Such a socket should be constructed with `socket(AF_INET, SOCK_DGRAM, IPPROTO_UDPLITE)` for IPv4 or `socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDPLITE)` for IPv6.
[Availability](https://docs.python.org/3/library/intro.html#availability): Linux >= 2.6.20, FreeBSD >= 10.1
Added in version 3.9.
  * [`AF_HYPERV`](https://docs.python.org/3/library/socket.html#socket.AF_HYPERV "socket.AF_HYPERV") is a Windows-only socket based interface for communicating with Hyper-V hosts and guests. The address family is represented as a `(vm_id, service_id)` tuple where the `vm_id` and `service_id` are UUID strings.
The `vm_id` is the virtual machine identifier or a set of known VMID values if the target is not a specific virtual machine. Known VMID constants defined on `socket` are:
    * `HV_GUID_ZERO`
    * `HV_GUID_BROADCAST`
    * `HV_GUID_WILDCARD` - Used to bind on itself and accept connections from all partitions.
    * `HV_GUID_CHILDREN` - Used to bind on itself and accept connection from child partitions.
    * `HV_GUID_LOOPBACK` - Used as a target to itself.
    * `HV_GUID_PARENT` - When used as a bind accepts connection from the parent partition. When used as an address target it will connect to the parent partition.
The `service_id` is the service identifier of the registered service.
Added in version 3.12.