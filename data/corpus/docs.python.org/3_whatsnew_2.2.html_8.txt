Title: N-Queens and Knight’s Tour Problem Solutions Using Generators
URL: https://docs.python.org/3/whatsnew/2.2.html
Summary: This section provides examples of using generators in Python to solve the N-Queens problem and the Knight’s Tour challenge on an NxN chessboard. It highlights that the concept of generators originates from the Icon programming language, where expressions and function calls operate as generators.
---

```

Two other examples in `Lib/test/test_generators.py` produce solutions for the N-Queens problem (placing $N$ queens on an $NxN$ chess board so that no queen threatens another) and the Knight’s Tour (a route that takes a knight to every square of an $NxN$ chessboard without visiting any square twice).
The idea of generators comes from other programming languages, especially Icon (<https://www2.cs.arizona.edu/icon/>), where the idea of generators is central. In Icon, every expression and function call behaves like a generator. One example from “An Overview of the Icon Programming Language” at <https://www2.cs.arizona.edu/icon/docs/ipd266.htm> gives an idea of what this looks like:
```
sentence := "Store it in the neighboring harbor"
if (i := find("or", sentence)) > 5 then write(i)

```

In Icon the `find()` function returns the indexes at which the substring “or” is found: 3, 23, 33. In the [`if`](https://docs.python.org/3/reference/compound_stmts.html#if) statement, `i` is first assigned a value of 3, but 3 is less than 5, so the comparison fails, and Icon retries it with the second value of 23. 23 is greater than 5, so the comparison now succeeds, and the code prints the value 23 to the screen.
Python doesn’t go nearly as far as Icon in adopting generators as a central concept. Generators are considered a new part of the core Python language, but learning or using them isn’t compulsory; if they don’t solve any problems that you have, feel free to ignore them. One novel feature of Python’s interface as compared to Icon’s is that a generator’s state is represented as a concrete object (the iterator) that can be passed around to other functions or stored in a data structure.
See also 

[**PEP 255**](https://peps.python.org/pep-0255/) - Simple Generators
    
Written by Neil Schemenauer, Tim Peters, Magnus Lie Hetland. Implemented mostly by Neil Schemenauer and Tim Peters, with other fixes from the Python Labs crew.
## PEP 237: Unifying Long Integers and Integers[¶](https://docs.python.org/3/whatsnew/2.2.html#pep-237-unifying-long-integers-and-integers "Link to this heading")
In recent versions, the distinction between regular integers, which are 32-bit values on most machines, and long integers, which can be of arbitrary size, was becoming an annoyance. For example, on platforms that support files larger than `2**32` bytes, the `tell()` method of file objects has to return a long integer. However, there were various bits of Python that expected plain integers and would raise an error if a long integer was provided instead. For example, in Python 1.5, only regular integers could be used as a slice index, and `'abc'[1L:]` would raise a [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError "TypeError") exception with the message ‘slice index must be int’.
Python 2.2 will shift values from short to long integers as required. The ‘L’ suffix is no longer needed to indicate a long integer literal, as now the compiler will choose the appropriate type. (Using the ‘L’ suffix will be discouraged in future 2.x versions of Python, triggering a warning in Python 2.4, and probably dropped in Python 3.0.) Many operations that used to raise an [`OverflowError`](https://docs.python.org/3/library/exceptions.html#OverflowError "OverflowError") will now return a long integer as their result. For example:
>>>```
>>> 1234567890123
1234567890123L
>>> 2 ** 64
18446744073709551616L