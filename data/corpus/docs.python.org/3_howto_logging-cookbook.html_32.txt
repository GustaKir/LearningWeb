Title: Customizing Exception Formatting and Audible Logging
URL: https://docs.python.org/3/howto/logging-cookbook.html
Summary: This section discusses how to format exception information using the `traceback` module and explores the implementation of audible logging messages using text-to-speech (TTS) systems. It suggests using the `subprocess` module to invoke TTS command line programs for auditory output of logging messages.
---

```

While the above treatment is simplistic, it points the way to how exception information can be formatted to your liking. The [`traceback`](https://docs.python.org/3/library/traceback.html#module-traceback "traceback: Print or retrieve a stack traceback.") module may be helpful for more specialized needs.
## Speaking logging messages[¶](https://docs.python.org/3/howto/logging-cookbook.html#speaking-logging-messages "Link to this heading")
There might be situations when it is desirable to have logging messages rendered in an audible rather than a visible format. This is easy to do if you have text-to-speech (TTS) functionality available in your system, even if it doesn’t have a Python binding. Most TTS systems have a command line program you can run, and this can be invoked from a handler using [`subprocess`](https://docs.python.org/3/library/subprocess.html#module-subprocess "subprocess: Subprocess management."). It’s assumed here that TTS command line programs won’t expect to interact with users or take a long time to complete, and that the frequency of logged messages will be not so high as to swamp the user with messages, and that it’s acceptable to have the messages spoken one at a time rather than concurrently, The example implementation below waits for one message to be spoken before the next is processed, and this might cause other handlers to be kept waiting. Here is a short example showing the approach, which assumes that the `espeak` TTS package is available:
```
importlogging
importsubprocess
importsys
classTTSHandler(logging.Handler):
  defemit(self, record):
    msg = self.format(record)
    # Speak slowly in a female English voice
    cmd = ['espeak', '-s150', '-ven+f3', msg]
    p = subprocess.Popen(cmd, stdout=subprocess.PIPE,
               stderr=subprocess.STDOUT)
    # wait for the program to finish
    p.communicate()
defconfigure_logging():
  h = TTSHandler()
  root = logging.getLogger()
  root.addHandler(h)
  # the default formatter just returns the message
  root.setLevel(logging.DEBUG)
defmain():
  logging.info('Hello')
  logging.debug('Goodbye')
if __name__ == '__main__':
  configure_logging()
  sys.exit(main())

```

When run, this script should say “Hello” and then “Goodbye” in a female voice.
The above approach can, of course, be adapted to other TTS systems and even other systems altogether which can process messages via external programs run from a command line.
## Buffering logging messages and outputting them conditionally[¶](https://docs.python.org/3/howto/logging-cookbook.html#buffering-logging-messages-and-outputting-them-conditionally "Link to this heading")
There might be situations where you want to log messages in a temporary area and only output them if a certain condition occurs. For example, you may want to start logging debug events in a function, and if the function completes without errors, you don’t want to clutter the log with the collected debug information, but if there is an error, you want all the debug information to be output as well as the error.
Here is an example which shows how you could do this using a decorator for your functions where you want logging to behave this way. It makes use of the [`logging.handlers.MemoryHandler`](https://docs.python.org/3/library/logging.handlers.html#logging.handlers.MemoryHandler "logging.handlers.MemoryHandler"), which allows buffering of logged events until some condition occurs, at which point the buffered events are `flushed` - passed to another handler (the `target` handler) for processing. By default, the `MemoryHandler` flushed when its buffer gets filled up or an event whose level is greater than or equal to a specified threshold is seen. You can use this recipe with a more specialised subclass of `MemoryHandler` if you want custom flushing behavior.
The example script has a simple function, `foo`, which just cycles through all the logging levels, writing to `sys.stderr` to say what level it’s about to log at, and then actually logging a message at that level. You can pass a parameter to `foo` which, if true, will log at ERROR and CRITICAL levels - otherwise, it only logs at DEBUG, INFO and WARNING levels.
The script just arranges to decorate `foo` with a decorator which will do the conditional logging that’s required. The decorator takes a logger as a parameter and attaches a memory handler for the duration of the call to the decorated function. The decorator can be additionally parameterised using a target handler, a level at which flushing should occur, and a capacity for the buffer (number of records buffered). These default to a [`StreamHandler`](https://docs.python.org/3/library/logging.handlers.html#logging.StreamHandler "logging.StreamHandler") which writes to `sys.stderr`, `logging.ERROR` and `100` respectively.
Here’s the script: