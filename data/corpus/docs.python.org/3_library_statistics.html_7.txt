Title: Sample Variance Calculation in Statistics
URL: https://docs.python.org/3/library/statistics.html
Summary: The `statistics.variance()` function calculates the sample variance of a dataset, represented by an iterable of at least two real numbers. It measures the spread or dispersion of data around the mean, with a larger variance indicating greater spread. The function accepts an optional parameter for the sample mean; if omitted, the mean is calculated automatically. This function is intended for sample data, while `pvariance()` should be used for complete population variance calculations.
---

```


statistics.variance(_data_ , _xbar =None_)[¶](https://docs.python.org/3/library/statistics.html#statistics.variance "Link to this definition")
    
Return the sample variance of _data_ , an iterable of at least two real-valued numbers. Variance, or second moment about the mean, is a measure of the variability (spread or dispersion) of data. A large variance indicates that the data is spread out; a small variance indicates it is clustered closely around the mean.
If the optional second argument _xbar_ is given, it should be the _sample_ mean of _data_. If it is missing or `None` (the default), the mean is automatically calculated.
Use this function when your data is a sample from a population. To calculate the variance from the entire population, see [`pvariance()`](https://docs.python.org/3/library/statistics.html#statistics.pvariance "statistics.pvariance").
Raises [`StatisticsError`](https://docs.python.org/3/library/statistics.html#statistics.StatisticsError "statistics.StatisticsError") if _data_ has fewer than two values.
Examples:
>>>```
>>> data = [2.75, 1.75, 1.25, 0.25, 0.5, 1.25, 3.5]
>>> variance(data)
1.3720238095238095

```

If you have already calculated the sample mean of your data, you can pass it as the optional second argument _xbar_ to avoid recalculation:
>>>```
>>> m = mean(data)
>>> variance(data, m)
1.3720238095238095

```

This function does not attempt to verify that you have passed the actual mean as _xbar_. Using arbitrary values for _xbar_ can lead to invalid or impossible results.
Decimal and Fraction values are supported:
>>>```
>>> fromdecimalimport Decimal as D
>>> variance([D("27.5"), D("30.25"), D("30.25"), D("34.5"), D("41.75")])
Decimal('31.01875')
>>> fromfractionsimport Fraction as F
>>> variance([F(1, 6), F(1, 2), F(5, 3)])
Fraction(67, 108)

```

Note
This is the sample variance s² with Bessel’s correction, also known as variance with N-1 degrees of freedom. Provided that the data points are representative (e.g. independent and identically distributed), the result should be an unbiased estimate of the true population variance.
If you somehow know the actual population mean μ you should pass it to the [`pvariance()`](https://docs.python.org/3/library/statistics.html#statistics.pvariance "statistics.pvariance") function as the _mu_ parameter to get the variance of a sample. 

statistics.quantiles(_data_ , _*_ , _n =4_, _method ='exclusive'_)[¶](https://docs.python.org/3/library/statistics.html#statistics.quantiles "Link to this definition")
    
Divide _data_ into _n_ continuous intervals with equal probability. Returns a list of `n - 1` cut points separating the intervals.
Set _n_ to 4 for quartiles (the default). Set _n_ to 10 for deciles. Set _n_ to 100 for percentiles which gives the 99 cuts points that separate _data_ into 100 equal sized groups. Raises [`StatisticsError`](https://docs.python.org/3/library/statistics.html#statistics.StatisticsError "statistics.StatisticsError") if _n_ is not least 1.
The _data_ can be any iterable containing sample data. For meaningful results, the number of data points in _data_ should be larger than _n_. Raises [`StatisticsError`](https://docs.python.org/3/library/statistics.html#statistics.StatisticsError "statistics.StatisticsError") if there is not at least one data point.
The cut points are linearly interpolated from the two nearest data points. For example, if a cut point falls one-third of the distance between two sample values, `100` and `112`, the cut-point will evaluate to `104`.
The _method_ for computing quantiles can be varied depending on whether the _data_ includes or excludes the lowest and highest possible values from the population.
The default _method_ is “exclusive” and is used for data sampled from a population that can have more extreme values than found in the samples. The portion of the population falling below the _i-th_ of _m_ sorted data points is computed as `i / (m + 1)`. Given nine sample values, the method sorts them and assigns the following percentiles: 10%, 20%, 30%, 40%, 50%, 60%, 70%, 80%, 90%.
Setting the _method_ to “inclusive” is used for describing population data or for samples that are known to include the most extreme values from the population. The minimum value in _data_ is treated as the 0th percentile and the maximum value is treated as the 100th percentile. The portion of the population falling below the _i-th_ of _m_ sorted data points is computed as `(i - 1) / (m - 1)`. Given 11 sample values, the method sorts them and assigns the following percentiles: 0%, 10%, 20%, 30%, 40%, 50%, 60%, 70%, 80%, 90%, 100%.
>>>