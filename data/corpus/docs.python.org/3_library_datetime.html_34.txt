Title: USTimeZone Class in Python's datetime Module
URL: https://docs.python.org/3/library/datetime.html
Summary: The USTimeZone class, inheriting from tzinfo, allows for the representation and management of time zones in Python. It utilizes an initializer to set standard and daylight saving time offsets along with their respective names. Key methods include __repr__ for string representation, utcoffset for calculating the UTC offset, and dst for determining if daylight saving time is in effect.
---

classUSTimeZone(tzinfo):
  def__init__(self, hours, reprname, stdname, dstname):
    self.stdoffset = timedelta(hours=hours)
    self.reprname = reprname
    self.stdname = stdname
    self.dstname = dstname
  def__repr__(self):
    return self.reprname
  deftzname(self, dt):
    if self.dst(dt):
      return self.dstname
    else:
      return self.stdname
  defutcoffset(self, dt):
    return self.stdoffset + self.dst(dt)
  defdst(self, dt):
    if dt is None or dt.tzinfo is None:
      # An exception may be sensible here, in one or both cases.
      # It depends on how you want to treat them. The default
      # fromutc() implementation (called by the default astimezone()
      # implementation) passes a datetime with dt.tzinfo is self.
      return ZERO
    assert dt.tzinfo is self
    start, end = us_dst_range(dt.year)
    # Can't compare naive to aware objects, so strip the timezone from
    # dt first.
    dt = dt.replace(tzinfo=None)
    if start + HOUR <= dt < end - HOUR:
      # DST is in effect.
      return HOUR
    if end - HOUR <= dt < end:
      # Fold (an ambiguous hour): use dt.fold to disambiguate.
      return ZERO if dt.fold else HOUR
    if start <= dt < start + HOUR:
      # Gap (a non-existent hour): reverse the fold rule.
      return HOUR if dt.fold else ZERO
    # DST is off.
    return ZERO
  deffromutc(self, dt):
    assert dt.tzinfo is self
    start, end = us_dst_range(dt.year)
    start = start.replace(tzinfo=self)
    end = end.replace(tzinfo=self)
    std_time = dt + self.stdoffset
    dst_time = std_time + HOUR
    if end <= dst_time < end + HOUR:
      # Repeated hour
      return std_time.replace(fold=1)
    if std_time < start or dst_time >= end:
      # Standard time
      return std_time
    if start <= std_time < end - HOUR:
      # Daylight saving time
      return dst_time

Eastern = USTimeZone(-5, "Eastern", "EST", "EDT")
Central = USTimeZone(-6, "Central", "CST", "CDT")
Mountain = USTimeZone(-7, "Mountain", "MST", "MDT")
Pacific = USTimeZone(-8, "Pacific", "PST", "PDT")

```

Note that there are unavoidable subtleties twice per year in a [`tzinfo`](https://docs.python.org/3/library/datetime.html#datetime.tzinfo "datetime.tzinfo") subclass accounting for both standard and daylight time, at the DST transition points. For concreteness, consider US Eastern (UTC -0500), where EDT begins the minute after 1:59 (EST) on the second Sunday in March, and ends the minute after 1:59 (EDT) on the first Sunday in November:
```
 UTC  3:MM 4:MM 5:MM 6:MM 7:MM 8:MM
 EST 22:MM 23:MM 0:MM 1:MM 2:MM 3:MM
 EDT 23:MM 0:MM 1:MM 2:MM 3:MM 4:MM
start 22:MM 23:MM 0:MM 1:MM 3:MM 4:MM
 end 23:MM 0:MM 1:MM 1:MM 2:MM 3:MM

```

When DST starts (the “start” line), the local wall clock leaps from 1:59 to 3:00. A wall time of the form 2:MM doesn’t really make sense on that day, so `astimezone(Eastern)` won’t deliver a result with `hour == 2` on the day DST begins. For example, at the Spring forward transition of 2016, we get:
>>>```
>>> fromdatetimeimport datetime, timezone
>>> fromtzinfo_examplesimport HOUR, Eastern
>>> u0 = datetime(2016, 3, 13, 5, tzinfo=timezone.utc)
>>> for i in range(4):
...   u = u0 + i*HOUR
...   t = u.astimezone(Eastern)
...   print(u.time(), 'UTC =', t.time(), t.tzname())
...
05:00:00 UTC = 00:00:00 EST
06:00:00 UTC = 01:00:00 EST
07:00:00 UTC = 03:00:00 EDT
08:00:00 UTC = 04:00:00 EDT

```

When DST ends (the “end” line), there’s a potentially worse problem: there’s an hour that can’t be spelled unambiguously in local wall time: the last hour of daylight time. In Eastern, that’s times of the form 5:MM UTC on the day daylight time ends. The local wall clock leaps from 1:59 (daylight time) back to 1:00 (standard time) again. Local times of the form 1:MM are ambiguous. [`astimezone()`](https://docs.python.org/3/library/datetime.html#datetime.datetime.astimezone "datetime.datetime.astimezone") mimics the local clock’s behavior by mapping two adjacent UTC hours into the same local hour then. In the Eastern example, UTC times of the form 5:MM and 6:MM both map to 1:MM when converted to Eastern, but earlier times have the [`fold`](https://docs.python.org/3/library/datetime.html#datetime.datetime.fold "datetime.datetime.fold") attribute set to 0 and the later times have it set to 1. For example, at the Fall back transition of 2016, we get:
>>>```
>>> u0 = datetime(2016, 11, 6, 4, tzinfo=timezone.utc)
>>> for i in range(4):
...   u = u0 + i*HOUR
...   t = u.astimezone(Eastern)
...   print(u.time(), 'UTC =', t.time(), t.tzname(), t.fold)
...
04:00:00 UTC = 00:00:00 EDT 0
05:00:00 UTC = 01:00:00 EDT 0
06:00:00 UTC = 01:00:00 EST 1
07:00:00 UTC = 02:00:00 EST 0