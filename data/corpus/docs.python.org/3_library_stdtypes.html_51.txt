Title: Dictionary View Objects in Python
URL: https://docs.python.org/3/library/stdtypes.html
Summary: Introduces dictionary view objects in Python, which are returned by methods like `dict.keys()`, `dict.values()`, and `dict.items()`. These views provide a dynamic, up-to-date representation of the dictionary's content, enabling iteration and membership tests. The document also notes that dictionaries became reversible in version 3.8.
---

```

Changed in version 3.8: Dictionaries are now reversible.
See also
[`types.MappingProxyType`](https://docs.python.org/3/library/types.html#types.MappingProxyType "types.MappingProxyType") can be used to create a read-only view of a [`dict`](https://docs.python.org/3/library/stdtypes.html#dict "dict").
### Dictionary view objects[¶](https://docs.python.org/3/library/stdtypes.html#dictionary-view-objects "Link to this heading")
The objects returned by [`dict.keys()`](https://docs.python.org/3/library/stdtypes.html#dict.keys "dict.keys"), [`dict.values()`](https://docs.python.org/3/library/stdtypes.html#dict.values "dict.values") and [`dict.items()`](https://docs.python.org/3/library/stdtypes.html#dict.items "dict.items") are _view objects_. They provide a dynamic view on the dictionary’s entries, which means that when the dictionary changes, the view reflects these changes.
Dictionary views can be iterated over to yield their respective data, and support membership tests: 

len(dictview)
    
Return the number of entries in the dictionary. 

iter(dictview)
    
Return an iterator over the keys, values or items (represented as tuples of `(key, value)`) in the dictionary.
Keys and values are iterated over in insertion order. This allows the creation of `(value, key)` pairs using [`zip()`](https://docs.python.org/3/library/functions.html#zip "zip"): `pairs = zip(d.values(), d.keys())`. Another way to create the same list is `pairs = [(v, k) for (k, v) in d.items()]`.
Iterating views while adding or deleting entries in the dictionary may raise a [`RuntimeError`](https://docs.python.org/3/library/exceptions.html#RuntimeError "RuntimeError") or fail to iterate over all entries.
Changed in version 3.7: Dictionary order is guaranteed to be insertion order. 

x in dictview
    
Return `True` if _x_ is in the underlying dictionary’s keys, values or items (in the latter case, _x_ should be a `(key, value)` tuple). 

reversed(dictview)
    
Return a reverse iterator over the keys, values or items of the dictionary. The view will be iterated in reverse order of the insertion.
Changed in version 3.8: Dictionary views are now reversible. 

dictview.mapping
    
Return a [`types.MappingProxyType`](https://docs.python.org/3/library/types.html#types.MappingProxyType "types.MappingProxyType") that wraps the original dictionary to which the view refers.
Added in version 3.10.
Keys views are set-like since their entries are unique and [hashable](https://docs.python.org/3/glossary.html#term-hashable). Items views also have set-like operations since the (key, value) pairs are unique and the keys are hashable. If all values in an items view are hashable as well, then the items view can interoperate with other sets. (Values views are not treated as set-like since the entries are generally not unique.) For set-like views, all of the operations defined for the abstract base class [`collections.abc.Set`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Set "collections.abc.Set") are available (for example, `==`, `<`, or `^`). While using set operators, set-like views accept any iterable as the other operand, unlike sets which only accept sets as the input.
An example of dictionary view usage:
>>>```
>>> dishes = {'eggs': 2, 'sausage': 1, 'bacon': 1, 'spam': 500}
>>> keys = dishes.keys()
>>> values = dishes.values()
>>> # iteration
>>> n = 0
>>> for val in values:
...   n += val
...
>>> print(n)
504
>>> # keys and values are iterated over in the same order (insertion order)
>>> list(keys)
['eggs', 'sausage', 'bacon', 'spam']
>>> list(values)
[2, 1, 1, 500]
>>> # view objects are dynamic and reflect dict changes
>>> del dishes['eggs']
>>> del dishes['sausage']
>>> list(keys)
['bacon', 'spam']
>>> # set operations
>>> keys & {'eggs', 'bacon', 'salad'}
{'bacon'}
>>> keys ^ {'sausage', 'juice'} == {'juice', 'sausage', 'bacon', 'spam'}
True
>>> keys | ['juice', 'juice', 'juice'] == {'bacon', 'spam', 'juice'}
True
>>> # get back a read-only proxy for the original dictionary
>>> values.mapping
mappingproxy({'bacon': 1, 'spam': 500})
>>> values.mapping['spam']
500