Title: Unpacking Argument Lists in Python
URL: https://docs.python.org/3/tutorial/controlflow.html
Summary: This section explains how to unpack argument lists in Python using the `*` operator for lists or tuples, and the `**` operator for dictionaries when calling functions. It demonstrates unpacking with examples using the `range()` function and a sample function that accepts keyword arguments.
---

```

### 4.9.5. Unpacking Argument Lists[¶](https://docs.python.org/3/tutorial/controlflow.html#unpacking-argument-lists "Link to this heading")
The reverse situation occurs when the arguments are already in a list or tuple but need to be unpacked for a function call requiring separate positional arguments. For instance, the built-in [`range()`](https://docs.python.org/3/library/stdtypes.html#range "range") function expects separate _start_ and _stop_ arguments. If they are not available separately, write the function call with the `*`-operator to unpack the arguments out of a list or tuple:
>>>```
>>> list(range(3, 6))      # normal call with separate arguments
[3, 4, 5]
>>> args = [3, 6]
>>> list(range(*args))      # call with arguments unpacked from a list
[3, 4, 5]

```

In the same fashion, dictionaries can deliver keyword arguments with the `**`-operator:
>>>```
>>> defparrot(voltage, state='a stiff', action='voom'):
...   print("-- This parrot wouldn't", action, end=' ')
...   print("if you put", voltage, "volts through it.", end=' ')
...   print("E's", state, "!")
...
>>> d = {"voltage": "four million", "state": "bleedin' demised", "action": "VOOM"}
>>> parrot(**d)
-- This parrot wouldn't VOOM if you put four million volts through it. E's bleedin' demised !

```

### 4.9.6. Lambda Expressions[¶](https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions "Link to this heading")
Small anonymous functions can be created with the [`lambda`](https://docs.python.org/3/reference/expressions.html#lambda) keyword. This function returns the sum of its two arguments: `lambda a, b: a+b`. Lambda functions can be used wherever function objects are required. They are syntactically restricted to a single expression. Semantically, they are just syntactic sugar for a normal function definition. Like nested function definitions, lambda functions can reference variables from the containing scope:
>>>```
>>> defmake_incrementor(n):
...   return lambda x: x + n
...
>>> f = make_incrementor(42)
>>> f(0)
42
>>> f(1)
43

```

The above example uses a lambda expression to return a function. Another use is to pass a small function as an argument:
>>>```
>>> pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]
>>> pairs.sort(key=lambda pair: pair[1])
>>> pairs
[(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')]

```

### 4.9.7. Documentation Strings[¶](https://docs.python.org/3/tutorial/controlflow.html#documentation-strings "Link to this heading")
Here are some conventions about the content and formatting of documentation strings.
The first line should always be a short, concise summary of the object’s purpose. For brevity, it should not explicitly state the object’s name or type, since these are available by other means (except if the name happens to be a verb describing a function’s operation). This line should begin with a capital letter and end with a period.
If there are more lines in the documentation string, the second line should be blank, visually separating the summary from the rest of the description. The following lines should be one or more paragraphs describing the object’s calling conventions, its side effects, etc.
The Python parser does not strip indentation from multi-line string literals in Python, so tools that process documentation have to strip indentation if desired. This is done using the following convention. The first non-blank line _after_ the first line of the string determines the amount of indentation for the entire documentation string. (We can’t use the first line since it is generally adjacent to the string’s opening quotes so its indentation is not apparent in the string literal.) Whitespace “equivalent” to this indentation is then stripped from the start of all lines of the string. Lines that are indented less should not occur, but if they occur all their leading whitespace should be stripped. Equivalence of whitespace should be tested after expansion of tabs (to 8 spaces, normally).
Here is an example of a multi-line docstring:
>>>```
>>> defmy_function():
... """Do nothing, but document it.
...
...   No, really, it doesn't do anything.
...   """
...   pass
...
>>> print(my_function.__doc__)
Do nothing, but document it.
  No, really, it doesn't do anything.