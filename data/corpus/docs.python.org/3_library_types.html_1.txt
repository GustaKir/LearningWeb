Title: types.prepare_class Function
URL: https://docs.python.org/3/library/types.html
Summary: The `types.prepare_class` function computes the metaclass and prepares the class namespace based on the given class name, base classes, and keyword arguments. It returns a 3-tuple consisting of the metaclass, prepared namespace, and updated keyword arguments without the 'metaclass' entry. This function was introduced in version 3.3 and modified in version 3.6 to change the behavior of the returned namespace.
---

types.prepare_class(_name_ , _bases =()_, _kwds =None_)[¶](https://docs.python.org/3/library/types.html#types.prepare_class "Link to this definition")
    
Calculates the appropriate metaclass and creates the class namespace.
The arguments are the components that make up a class definition header: the class name, the base classes (in order) and the keyword arguments (such as `metaclass`).
The return value is a 3-tuple: `metaclass, namespace, kwds`
_metaclass_ is the appropriate metaclass, _namespace_ is the prepared class namespace and _kwds_ is an updated copy of the passed in _kwds_ argument with any `'metaclass'` entry removed. If no _kwds_ argument is passed in, this will be an empty dict.
Added in version 3.3.
Changed in version 3.6: The default value for the `namespace` element of the returned tuple has changed. Now an insertion-order-preserving mapping is used when the metaclass does not have a `__prepare__` method.
See also 

[Metaclasses](https://docs.python.org/3/reference/datamodel.html#metaclasses)
    
Full details of the class creation process supported by these functions 

[**PEP 3115**](https://peps.python.org/pep-3115/) - Metaclasses in Python 3000
    
Introduced the `__prepare__` namespace hook 

types.resolve_bases(_bases_)[¶](https://docs.python.org/3/library/types.html#types.resolve_bases "Link to this definition")
    
Resolve MRO entries dynamically as specified by [**PEP 560**](https://peps.python.org/pep-0560/).
This function looks for items in _bases_ that are not instances of [`type`](https://docs.python.org/3/library/functions.html#type "type"), and returns a tuple where each such object that has an [`__mro_entries__()`](https://docs.python.org/3/reference/datamodel.html#object.__mro_entries__ "object.__mro_entries__") method is replaced with an unpacked result of calling this method. If a _bases_ item is an instance of [`type`](https://docs.python.org/3/library/functions.html#type "type"), or it doesn’t have an `__mro_entries__()` method, then it is included in the return tuple unchanged.
Added in version 3.7. 

types.get_original_bases(_cls_ , _/_)[¶](https://docs.python.org/3/library/types.html#types.get_original_bases "Link to this definition")
    
Return the tuple of objects originally given as the bases of _cls_ before the [`__mro_entries__()`](https://docs.python.org/3/reference/datamodel.html#object.__mro_entries__ "object.__mro_entries__") method has been called on any bases (following the mechanisms laid out in [**PEP 560**](https://peps.python.org/pep-0560/)). This is useful for introspecting [Generics](https://docs.python.org/3/library/typing.html#user-defined-generics).
For classes that have an `__orig_bases__` attribute, this function returns the value of `cls.__orig_bases__`. For classes without the `__orig_bases__` attribute, [`cls.__bases__`](https://docs.python.org/3/reference/datamodel.html#type.__bases__ "type.__bases__") is returned.
Examples:
```
fromtypingimport TypeVar, Generic, NamedTuple, TypedDict
T = TypeVar("T")
classFoo(Generic[T]): ...
classBar(Foo[int], float): ...
classBaz(list[str]): ...
Eggs = NamedTuple("Eggs", [("a", int), ("b", str)])
Spam = TypedDict("Spam", {"a": int, "b": str})
assert Bar.__bases__ == (Foo, float)
assert get_original_bases(Bar) == (Foo[int], float)
assert Baz.__bases__ == (list,)
assert get_original_bases(Baz) == (list[str],)
assert Eggs.__bases__ == (tuple,)
assert get_original_bases(Eggs) == (NamedTuple,)
assert Spam.__bases__ == (dict,)
assert get_original_bases(Spam) == (TypedDict,)
assert int.__bases__ == (object,)
assert get_original_bases(int) == (object,)