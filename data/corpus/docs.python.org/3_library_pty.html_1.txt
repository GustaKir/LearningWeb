Title: pty.spawn Function
URL: https://docs.python.org/3/library/pty.html
Summary: The pty.spawn function spawns a process and connects its controlling terminal to the current process's standard input/output. It facilitates interaction with child processes by copying input and output streams between them. The function can be customized with user-defined read functions, and to signal the end of a process, an empty byte array must be returned.
---

pty.spawn(_argv_[, _master_read_[, _stdin_read_]])[¶](https://docs.python.org/3/library/pty.html#pty.spawn "Link to this definition")
    
Spawn a process, and connect its controlling terminal with the current process’s standard io. This is often used to baffle programs which insist on reading from the controlling terminal. It is expected that the process spawned behind the pty will eventually terminate, and when it does _spawn_ will return.
A loop copies STDIN of the current process to the child and data received from the child to STDOUT of the current process. It is not signaled to the child if STDIN of the current process closes down.
The functions _master_read_ and _stdin_read_ are passed a file descriptor which they should read from, and they should always return a byte string. In order to force spawn to return before the child process exits an empty byte array should be returned to signal end of file.
The default implementation for both functions will read and return up to 1024 bytes each time the function is called. The _master_read_ callback is passed the pseudoterminal’s master file descriptor to read output from the child process, and _stdin_read_ is passed file descriptor 0, to read from the parent process’s standard input.
Returning an empty byte string from either callback is interpreted as an end-of-file (EOF) condition, and that callback will not be called after that. If _stdin_read_ signals EOF the controlling terminal can no longer communicate with the parent process OR the child process. Unless the child process will quit without any input, _spawn_ will then loop forever. If _master_read_ signals EOF the same behavior results (on linux at least).
Return the exit status value from [`os.waitpid()`](https://docs.python.org/3/library/os.html#os.waitpid "os.waitpid") on the child process.
[`os.waitstatus_to_exitcode()`](https://docs.python.org/3/library/os.html#os.waitstatus_to_exitcode "os.waitstatus_to_exitcode") can be used to convert the exit status into an exit code.
Raises an [auditing event](https://docs.python.org/3/library/sys.html#auditing) `pty.spawn` with argument `argv`.
Changed in version 3.4: [`spawn()`](https://docs.python.org/3/library/pty.html#pty.spawn "pty.spawn") now returns the status value from [`os.waitpid()`](https://docs.python.org/3/library/os.html#os.waitpid "os.waitpid") on the child process.
## Example[¶](https://docs.python.org/3/library/pty.html#example "Link to this heading")
The following program acts like the Unix command _[script(1)](https://manpages.debian.org/script\(1\))_ , using a pseudo-terminal to record all input and output of a terminal session in a “typescript”.
```
importargparse
importos
importpty
importsys
importtime
parser = argparse.ArgumentParser()
parser.add_argument('-a', dest='append', action='store_true')
parser.add_argument('-p', dest='use_python', action='store_true')
parser.add_argument('filename', nargs='?', default='typescript')
options = parser.parse_args()
shell = sys.executable if options.use_python else os.environ.get('SHELL', 'sh')
filename = options.filename
mode = 'ab' if options.append else 'wb'
with open(filename, mode) as script:
  defread(fd):
    data = os.read(fd, 1024)
    script.write(data)
    return data
  print('Script started, file is', filename)
  script.write(('Script started on %s\n' % time.asctime()).encode())
  pty.spawn(shell, read)
  script.write(('Script done on %s\n' % time.asctime()).encode())
  print('Script done, file is', filename)