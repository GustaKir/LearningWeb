Title: Setting Interval Timers with setitimer
URL: https://docs.python.org/3/library/signal.html
Summary: The `signal.setitimer` function configures an interval timer specified by _which_ (either `ITIMER_REAL`, `ITIMER_VIRTUAL`, or `ITIMER_PROF`) to trigger after a set number of _seconds_ and at specified _interval_ intervals. A signal is sent to the process when the timer fires, and the timer can be reset by setting _seconds_ to zero.
---

signal.setitimer(_which_ , _seconds_ , _interval =0.0_)[¶](https://docs.python.org/3/library/signal.html#signal.setitimer "Link to this definition")
    
Sets given interval timer (one of [`signal.ITIMER_REAL`](https://docs.python.org/3/library/signal.html#signal.ITIMER_REAL "signal.ITIMER_REAL"), [`signal.ITIMER_VIRTUAL`](https://docs.python.org/3/library/signal.html#signal.ITIMER_VIRTUAL "signal.ITIMER_VIRTUAL") or [`signal.ITIMER_PROF`](https://docs.python.org/3/library/signal.html#signal.ITIMER_PROF "signal.ITIMER_PROF")) specified by _which_ to fire after _seconds_ (float is accepted, different from [`alarm()`](https://docs.python.org/3/library/signal.html#signal.alarm "signal.alarm")) and after that every _interval_ seconds (if _interval_ is non-zero). The interval timer specified by _which_ can be cleared by setting _seconds_ to zero.
When an interval timer fires, a signal is sent to the process. The signal sent is dependent on the timer being used; [`signal.ITIMER_REAL`](https://docs.python.org/3/library/signal.html#signal.ITIMER_REAL "signal.ITIMER_REAL") will deliver [`SIGALRM`](https://docs.python.org/3/library/signal.html#signal.SIGALRM "signal.SIGALRM"), [`signal.ITIMER_VIRTUAL`](https://docs.python.org/3/library/signal.html#signal.ITIMER_VIRTUAL "signal.ITIMER_VIRTUAL") sends `SIGVTALRM`, and [`signal.ITIMER_PROF`](https://docs.python.org/3/library/signal.html#signal.ITIMER_PROF "signal.ITIMER_PROF") will deliver `SIGPROF`.
The old values are returned as a tuple: (delay, interval).
Attempting to pass an invalid interval timer will cause an [`ItimerError`](https://docs.python.org/3/library/signal.html#signal.ItimerError "signal.ItimerError").
[Availability](https://docs.python.org/3/library/intro.html#availability): Unix. 

signal.getitimer(_which_)[¶](https://docs.python.org/3/library/signal.html#signal.getitimer "Link to this definition")
    
Returns current value of a given interval timer specified by _which_.
[Availability](https://docs.python.org/3/library/intro.html#availability): Unix. 

signal.set_wakeup_fd(_fd_ , _*_ , _warn_on_full_buffer =True_)[¶](https://docs.python.org/3/library/signal.html#signal.set_wakeup_fd "Link to this definition")
    
Set the wakeup file descriptor to _fd_. When a signal your program has registered a signal handler for is received, the signal number is written as a single byte into the fd. If you haven’t registered a signal handler for the signals you care about, then nothing will be written to the wakeup fd. This can be used by a library to wakeup a poll or select call, allowing the signal to be fully processed.
The old wakeup fd is returned (or -1 if file descriptor wakeup was not enabled). If _fd_ is -1, file descriptor wakeup is disabled. If not -1, _fd_ must be non-blocking. It is up to the library to remove any bytes from _fd_ before calling poll or select again.
When threads are enabled, this function can only be called from [the main thread of the main interpreter](https://docs.python.org/3/library/signal.html#signals-and-threads); attempting to call it from other threads will cause a [`ValueError`](https://docs.python.org/3/library/exceptions.html#ValueError "ValueError") exception to be raised.
There are two common ways to use this function. In both approaches, you use the fd to wake up when a signal arrives, but then they differ in how they determine _which_ signal or signals have arrived.
In the first approach, we read the data out of the fd’s buffer, and the byte values give you the signal numbers. This is simple, but in rare cases it can run into a problem: generally the fd will have a limited amount of buffer space, and if too many signals arrive too quickly, then the buffer may become full, and some signals may be lost. If you use this approach, then you should set `warn_on_full_buffer=True`, which will at least cause a warning to be printed to stderr when signals are lost.
In the second approach, we use the wakeup fd _only_ for wakeups, and ignore the actual byte values. In this case, all we care about is whether the fd’s buffer is empty or non-empty; a full buffer doesn’t indicate a problem at all. If you use this approach, then you should set `warn_on_full_buffer=False`, so that your users are not confused by spurious warning messages.
Changed in version 3.5: On Windows, the function now also supports socket handles.
Changed in version 3.7: Added `warn_on_full_buffer` parameter.