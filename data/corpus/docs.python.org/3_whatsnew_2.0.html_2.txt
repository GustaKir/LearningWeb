Title: Python Enhancement Proposal Voting Process
URL: https://docs.python.org/3/whatsnew/2.0.html
Summary: The document outlines the Python developer group's approval process for patches, which involves a voting system (+1, +0, -0, -1) similar to the Apache model. While developers express their opinions on changes, the final decision rests with Guido van Rossum, the Benevolent Dictator For Life, allowing him to override community votes. The text highlights the challenges of discussing new features amidst lengthy mailing list threads.
---

he developer group. The approval process that has emerged is somewhat similar to that used by the Apache group. Developers can vote +1, +0, -0, or -1 on a patch; +1 and -1 denote acceptance or rejection, while +0 and -0 mean the developer is mostly indifferent to the change, though with a slight positive or negative slant. The most significant change from the Apache model is that the voting is essentially advisory, letting Guido van Rossum, who has Benevolent Dictator For Life status, know what the general opinion is. He can still ignore the result of a vote, and approve or reject a change even if the community disagrees with him.
Producing an actual patch is the last step in adding a new feature, and is usually easy compared to the earlier task of coming up with a good design. Discussions of new features can often explode into lengthy mailing list threads, making the discussion hard to follow, and no one can read every posting to python-dev. Therefore, a relatively formal process has been set up to write Python Enhancement Proposals (PEPs), modelled on the internet RFC process. PEPs are draft documents that describe a proposed new feature, and are continually revised until the community reaches a consensus, either accepting or rejecting the proposal. Quoting from the introduction to [**PEP 1**](https://peps.python.org/pep-0001/), “PEP Purpose and Guidelines”:
> PEP stands for Python Enhancement Proposal. A PEP is a design document providing information to the Python community, or describing a new feature for Python. The PEP should provide a concise technical specification of the feature and a rationale for the feature.
> We intend PEPs to be the primary mechanisms for proposing new features, for collecting community input on an issue, and for documenting the design decisions that have gone into Python. The PEP author is responsible for building consensus within the community and documenting dissenting opinions.
Read the rest of [**PEP 1**](https://peps.python.org/pep-0001/) for the details of the PEP editorial process, style, and format. PEPs are kept in the Python CVS tree on SourceForge, though they’re not part of the Python 2.0 distribution, and are also available in HTML form from <https://peps.python.org/>. As of September 2000, there are 25 PEPs, ranging from [**PEP 201**](https://peps.python.org/pep-0201/), “Lockstep Iteration”, to PEP 225, “Elementwise/Objectwise Operators”.
## Unicode[¶](https://docs.python.org/3/whatsnew/2.0.html#unicode "Link to this heading")
The largest new feature in Python 2.0 is a new fundamental data type: Unicode strings. Unicode uses 16-bit numbers to represent characters instead of the 8-bit number used by ASCII, meaning that 65,536 distinct characters can be supported.
The final interface for Unicode support was arrived at through countless often-stormy discussions on the python-dev mailing list, and mostly implemented by Marc-André Lemburg, based on a Unicode string type implementation by Fredrik Lundh. A detailed explanation of the interface was written up as [**PEP 100**](https://peps.python.org/pep-0100/), “Python Unicode Integration”. This article will simply cover the most significant points about the Unicode interfaces.
In Python source code, Unicode strings are written as `u"string"`. Arbitrary Unicode characters can be written using a new escape sequence, `\u_HHHH_`, where _HHHH_ is a 4-digit hexadecimal number from 0000 to FFFF. The existing `\x_HH_`escape sequence can also be used, and octal escapes can be used for characters up to U+01FF, which is represented by`\777`.
Unicode strings, just like regular strings, are an immutable sequence type. They can be indexed and sliced, but not modified in place. Unicode strings have an `encode( [encoding] )` method that returns an 8-bit string in the desired encoding. Encodings are named by strings, such as `'ascii'`, `'utf-8'`, `'iso-8859-1'`, or whatever. A codec API is defined for implementing and registering new encodings that are then available throughout a Python program. If an encoding isn’t specified, the default encoding is usually 7-bit ASCII, though it can be changed for your Python installation by calling the `sys.setdefaultencoding(encoding)` function in a customized version of `site.py`.
Combining 8-bit and Unicode strings always coerces to Unicode, using the default ASCII encoding; the result of `'a' + u'bc'` is `u'abc'`.
New built-in functions have been added, and existing built-ins modified to support Unicode:
  * `unichr(ch)` returns a Unicode string 1 character long, containing the character _ch_.
  * `ord(u)`, where _u_ is a 1-character regular or Unicode string, returns the number of the character as an integer.
  * `unicode(string [, encoding]  [, errors] )` creates a Unicode string from an 8-bit string. `encoding` is a string naming the encoding to use.