Title: Type Aliases and Their Usage in Python 3.12
URL: https://docs.python.org/3/library/typing.html
Summary: This section discusses the use of type aliases in Python 3.12, highlighting the new `type` statement for defining type aliases and providing examples of creating type aliases using simple assignment and the `TypeAlias` marker from the `typing` module. It also mentions the static type checker's handling of type signatures.
---

```
fromcollections.abcimport Sequence
type ConnectionOptions = dict[str, str]
type Address = tuple[str, int]
type Server = tuple[Address, ConnectionOptions]
defbroadcast_message(message: str, servers: Sequence[Server]) -> None:
  ...
# The static type checker will treat the previous type signature as
# being exactly equivalent to this one.
defbroadcast_message(
  message: str,
  servers: Sequence[tuple[tuple[str, int], dict[str, str]]]
) -> None:
  ...

```

The [`type`](https://docs.python.org/3/reference/simple_stmts.html#type) statement is new in Python 3.12. For backwards compatibility, type aliases can also be created through simple assignment:
```
Vector = list[float]

```

Or marked with [`TypeAlias`](https://docs.python.org/3/library/typing.html#typing.TypeAlias "typing.TypeAlias") to make it explicit that this is a type alias, not a normal variable assignment:
```
fromtypingimport TypeAlias
Vector: TypeAlias = list[float]

```

## NewType[¶](https://docs.python.org/3/library/typing.html#newtype "Link to this heading")
Use the [`NewType`](https://docs.python.org/3/library/typing.html#typing.NewType "typing.NewType") helper to create distinct types:
```
fromtypingimport NewType
UserId = NewType('UserId', int)
some_id = UserId(524313)

```

The static type checker will treat the new type as if it were a subclass of the original type. This is useful in helping catch logical errors:
```
defget_user_name(user_id: UserId) -> str:
  ...
# passes type checking
user_a = get_user_name(UserId(42351))
# fails type checking; an int is not a UserId
user_b = get_user_name(-1)

```

You may still perform all `int` operations on a variable of type `UserId`, but the result will always be of type `int`. This lets you pass in a `UserId` wherever an `int` might be expected, but will prevent you from accidentally creating a `UserId` in an invalid way:
```
# 'output' is of type 'int', not 'UserId'
output = UserId(23413) + UserId(54341)

```

Note that these checks are enforced only by the static type checker. At runtime, the statement `Derived = NewType('Derived', Base)` will make `Derived` a callable that immediately returns whatever parameter you pass it. That means the expression `Derived(some_value)` does not create a new class or introduce much overhead beyond that of a regular function call.
More precisely, the expression `some_value is Derived(some_value)` is always true at runtime.
It is invalid to create a subtype of `Derived`:
```
fromtypingimport NewType
UserId = NewType('UserId', int)
# Fails at runtime and does not pass type checking
classAdminUserId(UserId): pass

```

However, it is possible to create a [`NewType`](https://docs.python.org/3/library/typing.html#typing.NewType "typing.NewType") based on a ‘derived’ `NewType`:
```
fromtypingimport NewType
UserId = NewType('UserId', int)
ProUserId = NewType('ProUserId', UserId)

```

and typechecking for `ProUserId` will work as expected.
See [**PEP 484**](https://peps.python.org/pep-0484/) for more details.
Note
Recall that the use of a type alias declares two types to be _equivalent_ to one another. Doing `type Alias = Original` will make the static type checker treat `Alias` as being _exactly equivalent_ to `Original` in all cases. This is useful when you want to simplify complex type signatures.
In contrast, `NewType` declares one type to be a _subtype_ of another. Doing `Derived = NewType('Derived', Original)` will make the static type checker treat `Derived` as a _subclass_ of `Original`, which means a value of type `Original` cannot be used in places where a value of type `Derived` is expected. This is useful when you want to prevent logic errors with minimal runtime cost.
Added in version 3.5.2.
Changed in version 3.10: `NewType` is now a class rather than a function. As a result, there is some additional runtime cost when calling `NewType` over a regular function.
Changed in version 3.11: The performance of calling `NewType` has been restored to its level in Python 3.9.
## Annotating callable objects[¶](https://docs.python.org/3/library/typing.html#annotating-callable-objects "Link to this heading")
Functions – or other [callable](https://docs.python.org/3/glossary.html#term-callable) objects – can be annotated using [`collections.abc.Callable`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable "collections.abc.Callable") or deprecated [`typing.Callable`](https://docs.python.org/3/library/typing.html#typing.Callable "typing.Callable"). `Callable[[int], str]` signifies a function that takes a single parameter of type [`int`](https://docs.python.org/3/library/functions.html#int "int") and returns a [`str`](https://docs.python.org/3/library/stdtypes.html#str "str").
For example: