Title: Parsing Arguments and Building Values in Python C API
URL: https://docs.python.org/3/c-api/arg.html
Summary: This section discusses functions like PyArg_ParseTuple, PyArg_ParseTupleAndKeywords, and PyArg_Parse, which are essential for parsing arguments in Python extension functions and methods. It highlights the use of format strings to specify expected arguments and provides links to further resources on extending and embedding the Python interpreter.
---

# Parsing arguments and building values[¶](https://docs.python.org/3/c-api/arg.html#parsing-arguments-and-building-values "Link to this heading")
These functions are useful when creating your own extension functions and methods. Additional information and examples are available in [Extending and Embedding the Python Interpreter](https://docs.python.org/3/extending/index.html#extending-index).
The first three of these functions described, [`PyArg_ParseTuple()`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple "PyArg_ParseTuple"), [`PyArg_ParseTupleAndKeywords()`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTupleAndKeywords "PyArg_ParseTupleAndKeywords"), and [`PyArg_Parse()`](https://docs.python.org/3/c-api/arg.html#c.PyArg_Parse "PyArg_Parse"), all use _format strings_ which are used to tell the function about the expected arguments. The format strings use the same syntax for each of these functions.
## Parsing arguments[¶](https://docs.python.org/3/c-api/arg.html#parsing-arguments "Link to this heading")
A format string consists of zero or more “format units.” A format unit describes one Python object; it is usually a single character or a parenthesized sequence of format units. With a few exceptions, a format unit that is not a parenthesized sequence normally corresponds to a single address argument to these functions. In the following description, the quoted form is the format unit; the entry in (round) parentheses is the Python object type that matches the format unit; and the entry in [square] brackets is the type of the C variable(s) whose address should be passed.
### Strings and buffers[¶](https://docs.python.org/3/c-api/arg.html#strings-and-buffers "Link to this heading")
Note
On Python 3.12 and older, the macro `PY_SSIZE_T_CLEAN` must be defined before including `Python.h` to use all `#` variants of formats (`s#`, `y#`, etc.) explained below. This is not necessary on Python 3.13 and later.
These formats allow accessing an object as a contiguous chunk of memory. You don’t have to provide raw storage for the returned unicode or bytes area.
Unless otherwise stated, buffers are not NUL-terminated.
There are three ways strings and buffers can be converted to C:
  * Formats such as `y*` and `s*` fill a [`Py_buffer`](https://docs.python.org/3/c-api/buffer.html#c.Py_buffer "Py_buffer") structure. This locks the underlying buffer so that the caller can subsequently use the buffer even inside a [`Py_BEGIN_ALLOW_THREADS`](https://docs.python.org/3/c-api/init.html#c.Py_BEGIN_ALLOW_THREADS "Py_BEGIN_ALLOW_THREADS") block without the risk of mutable data being resized or destroyed. As a result, **you have to call** [`PyBuffer_Release()`](https://docs.python.org/3/c-api/buffer.html#c.PyBuffer_Release "PyBuffer_Release") after you have finished processing the data (or in any early abort case).
  * The `es`, `es#`, `et` and `et#` formats allocate the result buffer. **You have to call** [`PyMem_Free()`](https://docs.python.org/3/c-api/memory.html#c.PyMem_Free "PyMem_Free") after you have finished processing the data (or in any early abort case).
  * Other formats take a [`str`](https://docs.python.org/3/library/stdtypes.html#str "str") or a read-only [bytes-like object](https://docs.python.org/3/glossary.html#term-bytes-like-object), such as [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "bytes"), and provide a `const char *` pointer to its buffer. In this case the buffer is “borrowed”: it is managed by the corresponding Python object, and shares the lifetime of this object. You won’t have to release any memory yourself.
To ensure that the underlying buffer may be safely borrowed, the object’s [`PyBufferProcs.bf_releasebuffer`](https://docs.python.org/3/c-api/typeobj.html#c.PyBufferProcs.bf_releasebuffer "PyBufferProcs.bf_releasebuffer") field must be `NULL`. This disallows common mutable objects such as [`bytearray`](https://docs.python.org/3/library/stdtypes.html#bytearray "bytearray"), but also some read-only objects such as [`memoryview`](https://docs.python.org/3/library/stdtypes.html#memoryview "memoryview") of [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "bytes").
Besides this `bf_releasebuffer` requirement, there is no check to verify whether the input object is immutable (e.g. whether it would honor a request for a writable buffer, or whether another thread can mutate the data).