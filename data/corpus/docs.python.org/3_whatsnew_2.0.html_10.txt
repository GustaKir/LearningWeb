Title: Changes in Long Integer Representation and Use in Python 2.0
URL: https://docs.python.org/3/whatsnew/2.0.html
Summary: Python 2.0 allows long integers to be sliced and used in contexts previously limited to integers, such as in the `seek()` method and certain formatting operations. The output of `str()` for long integers no longer includes a trailing 'L', addressing formatting issues, though `repr()` still retains it. This change may break existing code that relied on the presence of 'L'.
---

`(0,1,2,3)[2L:4L]` produces (2,3). Long integers can also be used in various contexts where previously only integers were accepted, such as in the `seek()` method of file objects, and in the formats supported by the `%` operator (`%d`, `%i`, `%x`, etc.). For example, `"%d" % 2L**64` will produce the string `18446744073709551616`.
The subtlest long integer change of all is that the [`str()`](https://docs.python.org/3/library/stdtypes.html#str "str") of a long integer no longer has a trailing ‘L’ character, though [`repr()`](https://docs.python.org/3/library/functions.html#repr "repr") still includes it. The ‘L’ annoyed many people who wanted to print long integers that looked just like regular integers, since they had to go out of their way to chop off the character. This is no longer a problem in 2.0, but code which does `str(longval)[:-1]` and assumes the ‘L’ is there, will now lose the final digit.
Taking the [`repr()`](https://docs.python.org/3/library/functions.html#repr "repr") of a float now uses a different formatting precision than [`str()`](https://docs.python.org/3/library/stdtypes.html#str "str"). [`repr()`](https://docs.python.org/3/library/functions.html#repr "repr") uses `%.17g` format string for C’s `sprintf()`, while [`str()`](https://docs.python.org/3/library/stdtypes.html#str "str") uses `%.12g` as before. The effect is that [`repr()`](https://docs.python.org/3/library/functions.html#repr "repr") may occasionally show more decimal places than [`str()`](https://docs.python.org/3/library/stdtypes.html#str "str"), for certain numbers. For example, the number 8.1 can’t be represented exactly in binary, so `repr(8.1)` is `'8.0999999999999996'`, while str(8.1) is `'8.1'`.
The `-X` command-line option, which turned all standard exceptions into strings instead of classes, has been removed; the standard exceptions will now always be classes. The `exceptions` module containing the standard exceptions was translated from Python to a built-in C module, written by Barry Warsaw and Fredrik Lundh.
## Extending/Embedding Changes[¶](https://docs.python.org/3/whatsnew/2.0.html#extending-embedding-changes "Link to this heading")
Some of the changes are under the covers, and will only be apparent to people writing C extension modules or embedding a Python interpreter in a larger application. If you aren’t dealing with Python’s C API, you can safely skip this section.
The version number of the Python C API was incremented, so C extensions compiled for 1.5.2 must be recompiled in order to work with 2.0. On Windows, it’s not possible for Python 2.0 to import a third party extension built for Python 1.5.x due to how Windows DLLs work, so Python will raise an exception and the import will fail.
Users of Jim Fulton’s ExtensionClass module will be pleased to find out that hooks have been added so that ExtensionClasses are now supported by [`isinstance()`](https://docs.python.org/3/library/functions.html#isinstance "isinstance") and [`issubclass()`](https://docs.python.org/3/library/functions.html#issubclass "issubclass"). This means you no longer have to remember to write code such as `if type(obj) == myExtensionClass`, but can use the more natural `if isinstance(obj, myExtensionClass)`.
The `Python/importdl.c` file, which was a mass of #ifdefs to support dynamic loading on many different platforms, was cleaned up and reorganised by Greg Stein. `importdl.c` is now quite small, and platform-specific code has been moved into a bunch of `Python/dynload_*.c` files. Another cleanup: there were also a number of `my*.h` files in the Include/ directory that held various portability hacks; they’ve been merged into a single file, `Include/pyport.h`.
Vladimir Marangozov’s long-awaited malloc restructuring was completed, to make it easy to have the Python interpreter use a custom allocator instead of C’s standard `malloc()`. For documentation, read the comments in `Include/pymem.h` and `Include/objimpl.h`. For the lengthy discussions during which the interface was hammered out, see the web archives of the ‘patches’ and ‘python-dev’ lists at python.org.
Recent versions of the GUSI development environment for MacOS support POSIX threads. Therefore, Python’s POSIX threading support now works on the Macintosh. Threading support using the user-space GNU `pth` library was also contributed.
Threading support on Windows was enhanced, too. Windows supports thread locks that use kernel objects only in case of contention; in the common case when there’s no contention, they use simpler functions which are an order of magnitude faster. A threaded version of Python 1.5.2 on NT is twice as slow as an unthreaded version; with the 2.0 changes, the difference is only 10%.