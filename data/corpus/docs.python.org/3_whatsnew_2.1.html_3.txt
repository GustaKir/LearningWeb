Title: Overview of Future Statements and PEP 207: Rich Comparisons
URL: https://docs.python.org/3/whatsnew/2.1.html
Summary: This section explains the strict rules governing future statements in Python, which must be placed at the top of a module before any code or regular import statements to ensure correct bytecode generation. It also introduces PEP 207, which discusses enhancements in rich comparisons for user-defined classes.
---

```

While it looks like a normal [`import`](https://docs.python.org/3/reference/simple_stmts.html#import) statement, it’s not; there are strict rules on where such a future statement can be put. They can only be at the top of a module, and must precede any Python code or regular `import` statements. This is because such statements can affect how the Python bytecode compiler parses code and generates bytecode, so they must precede any statement that will result in bytecodes being produced.
See also 

[**PEP 236**](https://peps.python.org/pep-0236/) - Back to the [`__future__`](https://docs.python.org/3/library/__future__.html#module-__future__ "__future__: Future statement definitions")
    
Written by Tim Peters, and primarily implemented by Jeremy Hylton.
## PEP 207: Rich Comparisons[¶](https://docs.python.org/3/whatsnew/2.1.html#pep-207-rich-comparisons "Link to this heading")
In earlier versions, Python’s support for implementing comparisons on user-defined classes and extension types was quite simple. Classes could implement a `__cmp__()` method that was given two instances of a class, and could only return 0 if they were equal or +1 or -1 if they weren’t; the method couldn’t raise an exception or return anything other than a Boolean value. Users of Numeric Python often found this model too weak and restrictive, because in the number-crunching programs that numeric Python is used for, it would be more useful to be able to perform elementwise comparisons of two matrices, returning a matrix containing the results of a given comparison for each element. If the two matrices are of different sizes, then the compare has to be able to raise an exception to signal the error.
In Python 2.1, rich comparisons were added in order to support this need. Python classes can now individually overload each of the `<`, `<=`, `>`, `>=`, `==`, and `!=` operations. The new magic method names are:
Operation | Method name  
---|---  
`<` | [`__lt__()`](https://docs.python.org/3/reference/datamodel.html#object.__lt__ "object.__lt__")  
`<=` | [`__le__()`](https://docs.python.org/3/reference/datamodel.html#object.__le__ "object.__le__")  
`>` | [`__gt__()`](https://docs.python.org/3/reference/datamodel.html#object.__gt__ "object.__gt__")  
`>=` | [`__ge__()`](https://docs.python.org/3/reference/datamodel.html#object.__ge__ "object.__ge__")  
`==` | [`__eq__()`](https://docs.python.org/3/reference/datamodel.html#object.__eq__ "object.__eq__")  
`!=` | [`__ne__()`](https://docs.python.org/3/reference/datamodel.html#object.__ne__ "object.__ne__")  
(The magic methods are named after the corresponding Fortran operators `.LT.`. `.LE.`, &c. Numeric programmers are almost certainly quite familiar with these names and will find them easy to remember.)
Each of these magic methods is of the form `method(self, other)`, where `self` will be the object on the left-hand side of the operator, while `other` will be the object on the right-hand side. For example, the expression `A < B` will cause `A.__lt__(B)` to be called.
Each of these magic methods can return anything at all: a Boolean, a matrix, a list, or any other Python object. Alternatively they can raise an exception if the comparison is impossible, inconsistent, or otherwise meaningless.
The built-in `cmp(A,B)` function can use the rich comparison machinery, and now accepts an optional argument specifying which comparison operation to use; this is given as one of the strings `"<"`, `"<="`, `">"`, `">="`, `"=="`, or `"!="`. If called without the optional third argument, `cmp()` will only return -1, 0, or +1 as in previous versions of Python; otherwise it will call the appropriate method and can return any Python object.
There are also corresponding changes of interest to C programmers; there’s a new slot `tp_richcmp` in type objects and an API for performing a given rich comparison. I won’t cover the C API here, but will refer you to [**PEP 207**](https://peps.python.org/pep-0207/), or to 2.1’s C API documentation, for the full list of related functions.
See also