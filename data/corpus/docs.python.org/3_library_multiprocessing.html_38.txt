Title: Address Formats in Multiprocessing
URL: https://docs.python.org/3/library/multiprocessing.html
Summary: This section outlines the address formats used in Python's multiprocessing module, including 'AF_INET' for network addresses, 'AF_UNIX' for filesystem addresses, and 'AF_PIPE' for named pipes. It also notes the default interpretation of strings starting with two backslashes as 'AF_PIPE'.
---

```

#### Address Formats[¶](https://docs.python.org/3/library/multiprocessing.html#address-formats "Link to this heading")
  * An `'AF_INET'` address is a tuple of the form `(hostname, port)` where _hostname_ is a string and _port_ is an integer.
  * An `'AF_UNIX'` address is a string representing a filename on the filesystem.
  * An `'AF_PIPE'` address is a string of the form `r'\\.\pipe\_PipeName_'`. To use[`Client()`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.connection.Client "multiprocessing.connection.Client") to connect to a named pipe on a remote computer called _ServerName_ one should use an address of the form `r'\\_ServerName_\pipe\_PipeName_'`instead.


Note that any string beginning with two backslashes is assumed by default to be an `'AF_PIPE'` address rather than an `'AF_UNIX'` address.
### Authentication keys[¶](https://docs.python.org/3/library/multiprocessing.html#authentication-keys "Link to this heading")
When one uses [`Connection.recv`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.connection.Connection.recv "multiprocessing.connection.Connection.recv"), the data received is automatically unpickled. Unfortunately unpickling data from an untrusted source is a security risk. Therefore [`Listener`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.connection.Listener "multiprocessing.connection.Listener") and [`Client()`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.connection.Client "multiprocessing.connection.Client") use the [`hmac`](https://docs.python.org/3/library/hmac.html#module-hmac "hmac: Keyed-Hashing for Message Authentication \(HMAC\) implementation") module to provide digest authentication.
An authentication key is a byte string which can be thought of as a password: once a connection is established both ends will demand proof that the other knows the authentication key. (Demonstrating that both ends are using the same key does **not** involve sending the key over the connection.)
If authentication is requested but no authentication key is specified then the return value of `current_process().authkey` is used (see [`Process`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Process "multiprocessing.Process")). This value will be automatically inherited by any [`Process`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Process "multiprocessing.Process") object that the current process creates. This means that (by default) all processes of a multi-process program will share a single authentication key which can be used when setting up connections between themselves.
Suitable authentication keys can also be generated by using [`os.urandom()`](https://docs.python.org/3/library/os.html#os.urandom "os.urandom").
### Logging[¶](https://docs.python.org/3/library/multiprocessing.html#logging "Link to this heading")
Some support for logging is available. Note, however, that the [`logging`](https://docs.python.org/3/library/logging.html#module-logging "logging: Flexible event logging system for applications.") package does not use process shared locks so it is possible (depending on the handler type) for messages from different processes to get mixed up. 

multiprocessing.get_logger()[¶](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.get_logger "Link to this definition")
    
Returns the logger used by [`multiprocessing`](https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing "multiprocessing: Process-based parallelism."). If necessary, a new one will be created.
When first created the logger has level [`logging.NOTSET`](https://docs.python.org/3/library/logging.html#logging.NOTSET "logging.NOTSET") and no default handler. Messages sent to this logger will not by default propagate to the root logger.
Note that on Windows child processes will only inherit the level of the parent process’s logger – any other customization of the logger will not be inherited. 

multiprocessing.log_to_stderr(_level =None_)[¶](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.log_to_stderr "Link to this definition")
    
This function performs a call to [`get_logger()`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.get_logger "multiprocessing.get_logger") but in addition to returning the logger created by get_logger, it adds a handler which sends output to [`sys.stderr`](https://docs.python.org/3/library/sys.html#sys.stderr "sys.stderr") using format `'[%(levelname)s/%(processName)s] %(message)s'`. You can modify `levelname` of the logger by passing a `level` argument.
Below is an example session with logging turned on:
>>>