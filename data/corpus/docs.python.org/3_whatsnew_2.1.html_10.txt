Title: Python 2.1 Release Notes
URL: https://docs.python.org/3/whatsnew/2.1.html
Summary: Python 2.1 introduces several updates including disabling passive FTP mode with `set_pasv(0)`, adding support for raw socket access in the socket module, and a new interactive statistics browser in the pstats module for timing profiles. Additionally, a new function `sys._getframe([depth])` is implemented for accessing call stack frames.
---

mode is unsuitable for your application or network setup, call `set_pasv(0)` on FTP objects to disable passive mode.
  * Support for raw socket access has been added to the [`socket`](https://docs.python.org/3/library/socket.html#module-socket "socket: Low-level networking interface.") module, contributed by Grant Edwards.
  * The [`pstats`](https://docs.python.org/3/library/profile.html#module-pstats "pstats: Statistics object for use with the profiler.") module now contains a simple interactive statistics browser for displaying timing profiles for Python programs, invoked when the module is run as a script. Contributed by Eric S. Raymond.
  * A new implementation-dependent function, `sys._getframe([depth])`, has been added to return a given frame object from the current call stack. [`sys._getframe()`](https://docs.python.org/3/library/sys.html#sys._getframe "sys._getframe") returns the frame at the top of the call stack; if the optional integer argument _depth_ is supplied, the function returns the frame that is _depth_ calls below the top of the stack. For example, `sys._getframe(1)` returns the caller’s frame object.
This function is only present in CPython, not in Jython or the .NET implementation. Use it for debugging, and resist the temptation to put it into production code.


## Other Changes and Fixes[¶](https://docs.python.org/3/whatsnew/2.1.html#other-changes-and-fixes "Link to this heading")
There were relatively few smaller changes made in Python 2.1 due to the shorter release cycle. A search through the CVS change logs turns up 117 patches applied, and 136 bugs fixed; both figures are likely to be underestimates. Some of the more notable changes are:
  * A specialized object allocator is now optionally available, that should be faster than the system `malloc()` and have less memory overhead. The allocator uses C’s `malloc()` function to get large pools of memory, and then fulfills smaller memory requests from these pools. It can be enabled by providing the `--with-pymalloc` option to the **configure** script; see `Objects/obmalloc.c` for the implementation details.
Authors of C extension modules should test their code with the object allocator enabled, because some incorrect code may break, causing core dumps at runtime. There are a bunch of memory allocation functions in Python’s C API that have previously been just aliases for the C library’s `malloc()` and `free()`, meaning that if you accidentally called mismatched functions, the error wouldn’t be noticeable. When the object allocator is enabled, these functions aren’t aliases of `malloc()` and `free()` any more, and calling the wrong function to free memory will get you a core dump. For example, if memory was allocated using [`PyMem_New`](https://docs.python.org/3/c-api/memory.html#c.PyMem_New "PyMem_New"), it has to be freed using [`PyMem_Del()`](https://docs.python.org/3/c-api/memory.html#c.PyMem_Del "PyMem_Del"), not `free()`. A few modules included with Python fell afoul of this and had to be fixed; doubtless there are more third-party modules that will have the same problem.
The object allocator was contributed by Vladimir Marangozov.
  * The speed of line-oriented file I/O has been improved because people often complain about its lack of speed, and because it’s often been used as a naïve benchmark. The [`readline()`](https://docs.python.org/3/library/readline.html#module-readline "readline: GNU readline support for Python. \(Unix\)") method of file objects has therefore been rewritten to be much faster. The exact amount of the speedup will vary from platform to platform depending on how slow the C library’s `getc()` was, but is around 66%, and potentially much faster on some particular operating systems. Tim Peters did much of the benchmarking and coding for this change, motivated by a discussion in comp.lang.python.
A new module and method for file objects was also added, contributed by Jeff Epler. The new method, `xreadlines()`, is similar to the existing `xrange()` built-in. `xreadlines()` returns an opaque sequence object that only supports being iterated over, reading a line on every iteration but not reading the entire file into memory as the existing `readlines()` method does. You’d use it like this:
```
for line in sys.stdin.xreadlines():
  # ... do something for each line ...
  ...