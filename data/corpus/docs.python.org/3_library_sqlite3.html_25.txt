Title: SQLite3 Command Line Options and How-to Guides
URL: https://docs.python.org/3/library/sqlite3.html
Summary: This section outlines basic commands for the SQLite3 shell, including how to exit and access help or version information. It also introduces how to securely use placeholders for binding values in SQL queries to prevent SQL injection attacks.
---

```

Type `.quit` or CTRL-D to exit the shell. 

-h, --help[¶](https://docs.python.org/3/library/sqlite3.html#cmdoption-python-m-sqlite3-h-v-filename-sql-h "Link to this definition")
    
Print CLI help. 

-v, --version[¶](https://docs.python.org/3/library/sqlite3.html#cmdoption-python-m-sqlite3-h-v-filename-sql-v "Link to this definition")
    
Print underlying SQLite library version.
Added in version 3.12.
## How-to guides[¶](https://docs.python.org/3/library/sqlite3.html#how-to-guides "Link to this heading")
### How to use placeholders to bind values in SQL queries[¶](https://docs.python.org/3/library/sqlite3.html#how-to-use-placeholders-to-bind-values-in-sql-queries "Link to this heading")
SQL operations usually need to use values from Python variables. However, beware of using Python’s string operations to assemble queries, as they are vulnerable to [SQL injection attacks](https://en.wikipedia.org/wiki/SQL_injection). For example, an attacker can simply close the single quote and inject `OR TRUE` to select all rows:
>>>```
>>> # Never do this -- insecure!
>>> symbol = input()
' OR TRUE; --
>>> sql = "SELECT * FROM stocks WHERE symbol = '%s'" % symbol
>>> print(sql)
SELECT * FROM stocks WHERE symbol = '' OR TRUE; --'
>>> cur.execute(sql)

```

Instead, use the DB-API’s parameter substitution. To insert a variable into a query string, use a placeholder in the string, and substitute the actual values into the query by providing them as a [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "tuple") of values to the second argument of the cursor’s [`execute()`](https://docs.python.org/3/library/sqlite3.html#sqlite3.Cursor.execute "sqlite3.Cursor.execute") method.
An SQL statement may use one of two kinds of placeholders: question marks (qmark style) or named placeholders (named style). For the qmark style, _parameters_ must be a [sequence](https://docs.python.org/3/glossary.html#term-sequence) whose length must match the number of placeholders, or a [`ProgrammingError`](https://docs.python.org/3/library/sqlite3.html#sqlite3.ProgrammingError "sqlite3.ProgrammingError") is raised. For the named style, _parameters_ must be an instance of a [`dict`](https://docs.python.org/3/library/stdtypes.html#dict "dict") (or a subclass), which must contain keys for all named parameters; any extra items are ignored. Here’s an example of both styles:
```
con = sqlite3.connect(":memory:")
cur = con.execute("CREATE TABLE lang(name, first_appeared)")
# This is the named style used with executemany():
data = (
  {"name": "C", "year": 1972},
  {"name": "Fortran", "year": 1957},
  {"name": "Python", "year": 1991},
  {"name": "Go", "year": 2009},
)
cur.executemany("INSERT INTO lang VALUES(:name, :year)", data)
# This is the qmark style used in a SELECT query:
params = (1972,)
cur.execute("SELECT * FROM lang WHERE first_appeared = ?", params)
print(cur.fetchall())
con.close()

```

Note
[**PEP 249**](https://peps.python.org/pep-0249/) numeric placeholders are _not_ supported. If used, they will be interpreted as named placeholders.
### How to adapt custom Python types to SQLite values[¶](https://docs.python.org/3/library/sqlite3.html#how-to-adapt-custom-python-types-to-sqlite-values "Link to this heading")
SQLite supports only a limited set of data types natively. To store custom Python types in SQLite databases, _adapt_ them to one of the [Python types SQLite natively understands](https://docs.python.org/3/library/sqlite3.html#sqlite3-types).
There are two ways to adapt Python objects to SQLite types: letting your object adapt itself, or using an _adapter callable_. The latter will take precedence above the former. For a library that exports a custom type, it may make sense to enable that type to adapt itself. As an application developer, it may make more sense to take direct control by registering custom adapter functions.
#### How to write adaptable objects[¶](https://docs.python.org/3/library/sqlite3.html#how-to-write-adaptable-objects "Link to this heading")
Suppose we have a `Point` class that represents a pair of coordinates, `x` and `y`, in a Cartesian coordinate system. The coordinate pair will be stored as a text string in the database, using a semicolon to separate the coordinates. This can be implemented by adding a `__conform__(self, protocol)` method which returns the adapted value. The object passed to _protocol_ will be of type [`PrepareProtocol`](https://docs.python.org/3/library/sqlite3.html#sqlite3.PrepareProtocol "sqlite3.PrepareProtocol").
```
classPoint:
  def__init__(self, x, y):
    self.x, self.y = x, y
  def__conform__(self, protocol):
    if protocol is sqlite3.PrepareProtocol:
      return f"{self.x};{self.y}"
con = sqlite3.connect(":memory:")
cur = con.cursor()
cur.execute("SELECT ?", (Point(4.0, -3.2),))
print(cur.fetchone()[0])
con.close()