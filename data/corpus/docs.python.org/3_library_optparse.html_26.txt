Title: Extending Optparse
URL: https://docs.python.org/3/library/optparse.html
Summary: This section describes how to extend the 'optparse' library in Python for customized command-line option parsing. It includes the definition of a callback function to handle variable-length arguments and explains how to add options using the 'add_option' method.
---

```
defvararg_callback(option, opt_str, value, parser):
  assert value is None
  value = []
  deffloatable(str):
    try:
      float(str)
      return True
    except ValueError:
      return False
  for arg in parser.rargs:
    # stop on --foo like options
    if arg[:2] == "--" and len(arg) > 2:
      break
    # stop on -a, but not on -3 or -3.0
    if arg[:1] == "-" and len(arg) > 1 and not floatable(arg):
      break
    value.append(arg)
  del parser.rargs[:len(value)]
  setattr(parser.values, option.dest, value)
...
parser.add_option("-c", "--callback", dest="vararg_attr",
         action="callback", callback=vararg_callback)

```

## Extending [`optparse`](https://docs.python.org/3/library/optparse.html#module-optparse "optparse: Command-line option parsing library.")[¶](https://docs.python.org/3/library/optparse.html#extending-optparse "Link to this heading")
Since the two major controlling factors in how [`optparse`](https://docs.python.org/3/library/optparse.html#module-optparse "optparse: Command-line option parsing library.") interprets command-line options are the action and type of each option, the most likely direction of extension is to add new actions and new types.
### Adding new types[¶](https://docs.python.org/3/library/optparse.html#adding-new-types "Link to this heading")
To add new types, you need to define your own subclass of [`optparse`](https://docs.python.org/3/library/optparse.html#module-optparse "optparse: Command-line option parsing library.")’s [`Option`](https://docs.python.org/3/library/optparse.html#optparse.Option "optparse.Option") class. This class has a couple of attributes that define [`optparse`](https://docs.python.org/3/library/optparse.html#module-optparse "optparse: Command-line option parsing library.")’s types: [`TYPES`](https://docs.python.org/3/library/optparse.html#optparse.Option.TYPES "optparse.Option.TYPES") and [`TYPE_CHECKER`](https://docs.python.org/3/library/optparse.html#optparse.Option.TYPE_CHECKER "optparse.Option.TYPE_CHECKER"). 

Option.TYPES[¶](https://docs.python.org/3/library/optparse.html#optparse.Option.TYPES "Link to this definition")
    
A tuple of type names; in your subclass, simply define a new tuple [`TYPES`](https://docs.python.org/3/library/optparse.html#optparse.Option.TYPES "optparse.Option.TYPES") that builds on the standard one. 

Option.TYPE_CHECKER[¶](https://docs.python.org/3/library/optparse.html#optparse.Option.TYPE_CHECKER "Link to this definition")
    
A dictionary mapping type names to type-checking functions. A type-checking function has the following signature:
```
defcheck_mytype(option, opt, value)

```

where `option` is an [`Option`](https://docs.python.org/3/library/optparse.html#optparse.Option "optparse.Option") instance, `opt` is an option string (e.g., `-f`), and `value` is the string from the command line that must be checked and converted to your desired type. `check_mytype()` should return an object of the hypothetical type `mytype`. The value returned by a type-checking function will wind up in the OptionValues instance returned by [`OptionParser.parse_args()`](https://docs.python.org/3/library/optparse.html#optparse.OptionParser.parse_args "optparse.OptionParser.parse_args"), or be passed to a callback as the `value` parameter.
Your type-checking function should raise [`OptionValueError`](https://docs.python.org/3/library/optparse.html#optparse.OptionValueError "optparse.OptionValueError") if it encounters any problems. [`OptionValueError`](https://docs.python.org/3/library/optparse.html#optparse.OptionValueError "optparse.OptionValueError") takes a single string argument, which is passed as-is to [`OptionParser`](https://docs.python.org/3/library/optparse.html#optparse.OptionParser "optparse.OptionParser")’s `error()` method, which in turn prepends the program name and the string `"error:"` and prints everything to stderr before terminating the process.
Here’s a silly example that demonstrates adding a `"complex"` option type to parse Python-style complex numbers on the command line. (This is even sillier than it used to be, because [`optparse`](https://docs.python.org/3/library/optparse.html#module-optparse "optparse: Command-line option parsing library.") 1.3 added built-in support for complex numbers, but never mind.)
First, the necessary imports:
```
fromcopyimport copy
fromoptparseimport Option, OptionValueError

```

You need to define your type-checker first, since it’s referred to later (in the [`TYPE_CHECKER`](https://docs.python.org/3/library/optparse.html#optparse.Option.TYPE_CHECKER "optparse.Option.TYPE_CHECKER") class attribute of your Option subclass):
```
defcheck_complex(option, opt, value):
  try:
    return complex(value)
  except ValueError:
    raise OptionValueError(
      "option %s: invalid complex value: %r" % (opt, value))

```

Finally, the Option subclass: