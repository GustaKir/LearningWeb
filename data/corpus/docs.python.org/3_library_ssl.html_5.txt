Title: SSL Certificate Retrieval and Time Interpretation Changes
URL: https://docs.python.org/3/library/ssl.html
Summary: The 'notBefore' and 'notAfter' dates in SSL certificates must use GMT as per RFC 5280. Starting from version 3.5, the input time is interpreted as UTC instead of local timezone. The 'ssl.get_server_certificate' function retrieves a server's certificate as a PEM-encoded string using the specified SSL version and optional root certificates.
---

```

“notBefore” or “notAfter” dates must use GMT ([**RFC 5280**](https://datatracker.ietf.org/doc/html/rfc5280.html)).
Changed in version 3.5: Interpret the input time as a time in UTC as specified by ‘GMT’ timezone in the input string. Local timezone was used previously. Return an integer (no fractions of a second in the input format) 

ssl.get_server_certificate(_addr_ , _ssl_version=PROTOCOL_TLS_CLIENT_ , _ca_certs=None_[, _timeout_])[¶](https://docs.python.org/3/library/ssl.html#ssl.get_server_certificate "Link to this definition")
    
Given the address `addr` of an SSL-protected server, as a (_hostname_ , _port-number_) pair, fetches the server’s certificate, and returns it as a PEM-encoded string. If `ssl_version` is specified, uses that version of the SSL protocol to attempt to connect to the server. If _ca_certs_ is specified, it should be a file containing a list of root certificates, the same format as used for the _cafile_ parameter in [`SSLContext.load_verify_locations()`](https://docs.python.org/3/library/ssl.html#ssl.SSLContext.load_verify_locations "ssl.SSLContext.load_verify_locations"). The call will attempt to validate the server certificate against that set of root certificates, and will fail if the validation attempt fails. A timeout can be specified with the `timeout` parameter.
Changed in version 3.3: This function is now IPv6-compatible.
Changed in version 3.5: The default _ssl_version_ is changed from [`PROTOCOL_SSLv3`](https://docs.python.org/3/library/ssl.html#ssl.PROTOCOL_SSLv3 "ssl.PROTOCOL_SSLv3") to [`PROTOCOL_TLS`](https://docs.python.org/3/library/ssl.html#ssl.PROTOCOL_TLS "ssl.PROTOCOL_TLS") for maximum compatibility with modern servers.
Changed in version 3.10: The _timeout_ parameter was added. 

ssl.DER_cert_to_PEM_cert(_DER_cert_bytes_)[¶](https://docs.python.org/3/library/ssl.html#ssl.DER_cert_to_PEM_cert "Link to this definition")
    
Given a certificate as a DER-encoded blob of bytes, returns a PEM-encoded string version of the same certificate. 

ssl.PEM_cert_to_DER_cert(_PEM_cert_string_)[¶](https://docs.python.org/3/library/ssl.html#ssl.PEM_cert_to_DER_cert "Link to this definition")
    
Given a certificate as an ASCII PEM string, returns a DER-encoded sequence of bytes for that same certificate. 

ssl.get_default_verify_paths()[¶](https://docs.python.org/3/library/ssl.html#ssl.get_default_verify_paths "Link to this definition")
    
Returns a named tuple with paths to OpenSSL’s default cafile and capath. The paths are the same as used by [`SSLContext.set_default_verify_paths()`](https://docs.python.org/3/library/ssl.html#ssl.SSLContext.set_default_verify_paths "ssl.SSLContext.set_default_verify_paths"). The return value is a [named tuple](https://docs.python.org/3/glossary.html#term-named-tuple) `DefaultVerifyPaths`:
  * `cafile` - resolved path to cafile or `None` if the file doesn’t exist,
  * `capath` - resolved path to capath or `None` if the directory doesn’t exist,
  * `openssl_cafile_env` - OpenSSL’s environment key that points to a cafile,
  * `openssl_cafile` - hard coded path to a cafile,
  * `openssl_capath_env` - OpenSSL’s environment key that points to a capath,
  * `openssl_capath` - hard coded path to a capath directory


Added in version 3.4. 

ssl.enum_certificates(_store_name_)[¶](https://docs.python.org/3/library/ssl.html#ssl.enum_certificates "Link to this definition")
    
Retrieve certificates from Windows’ system cert store. _store_name_ may be one of `CA`, `ROOT` or `MY`. Windows may provide additional cert stores, too.
The function returns a list of (cert_bytes, encoding_type, trust) tuples. The encoding_type specifies the encoding of cert_bytes. It is either `x509_asn` for X.509 ASN.1 data or `pkcs_7_asn` for PKCS#7 ASN.1 data. Trust specifies the purpose of the certificate as a set of OIDS or exactly `True` if the certificate is trustworthy for all purposes.
Example:
>>>```
>>> ssl.enum_certificates("CA")
[(b'data...', 'x509_asn', {'1.3.6.1.5.5.7.3.1', '1.3.6.1.5.5.7.3.2'}),
 (b'data...', 'x509_asn', True)]