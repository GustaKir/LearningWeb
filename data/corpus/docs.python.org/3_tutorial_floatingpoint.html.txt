Title: Floating-Point Arithmetic: Issues and Limitations
URL: https://docs.python.org/3/tutorial/floatingpoint.html
Summary: This section provides an overview of floating-point arithmetic in Python, discussing the challenges and limitations such as representation errors that can affect numerical calculations.
---

[ ![Python logo](https://docs.python.org/3/_static/py.svg) ](https://www.python.org/) dev (3.14)3.13.33.123.113.103.93.83.73.63.53.43.33.23.13.02.72.6
EnglishSpanish | españolFrench | françaisItalian | italianoJapanese | 日本語Korean | 한국어Polish | polskiBrazilian Portuguese | Português brasileiroTurkish | TürkçeSimplified Chinese | 简体中文Traditional Chinese | 繁體中文
Theme  Auto Light Dark
### [Table of Contents](https://docs.python.org/3/contents.html)
  * [15. Floating-Point Arithmetic: Issues and Limitations](https://docs.python.org/3/tutorial/floatingpoint.html)
    * [15.1. Representation Error](https://docs.python.org/3/tutorial/floatingpoint.html#representation-error)


#### Previous topic
[14. Interactive Input Editing and History Substitution](https://docs.python.org/3/tutorial/interactive.html "previous chapter")
#### Next topic
[16. Appendix](https://docs.python.org/3/tutorial/appendix.html "next chapter")
### This Page
  * [Report a Bug](https://docs.python.org/3/bugs.html)
  * [Show Source ](https://github.com/python/cpython/blob/main/Doc/tutorial/floatingpoint.rst)


### Navigation
  * [index](https://docs.python.org/3/genindex.html "General Index")
  * [modules](https://docs.python.org/3/py-modindex.html "Python Module Index") |
  * [next](https://docs.python.org/3/tutorial/appendix.html "16. Appendix") |
  * [previous](https://docs.python.org/3/tutorial/interactive.html "14. Interactive Input Editing and History Substitution") |
  * ![Python logo](https://docs.python.org/3/_static/py.svg)
  * [Python](https://www.python.org/) »
  * EnglishSpanish | españolFrench | françaisItalian | italianoJapanese | 日本語Korean | 한국어Polish | polskiBrazilian Portuguese | Português brasileiroTurkish | TürkçeSimplified Chinese | 简体中文Traditional Chinese | 繁體中文
dev (3.14)3.13.33.123.113.103.93.83.73.63.53.43.33.23.13.02.72.6
  * [3.13.3 Documentation](https://docs.python.org/3/index.html) » 
  * [The Python Tutorial](https://docs.python.org/3/tutorial/index.html) »
  * [15. Floating-Point Arithmetic: Issues and Limitations](https://docs.python.org/3/tutorial/floatingpoint.html)
  * | 
  * Theme  Auto Light Dark |


# 15. Floating-Point Arithmetic: Issues and Limitations[¶](https://docs.python.org/3/tutorial/floatingpoint.html#floating-point-arithmetic-issues-and-limitations "Link to this heading")
Floating-point numbers are represented in computer hardware as base 2 (binary) fractions. For example, the **decimal** fraction `0.625` has value 6/10 + 2/100 + 5/1000, and in the same way the **binary** fraction `0.101` has value 1/2 + 0/4 + 1/8. These two fractions have identical values, the only real difference being that the first is written in base 10 fractional notation, and the second in base 2.
Unfortunately, most decimal fractions cannot be represented exactly as binary fractions. A consequence is that, in general, the decimal floating-point numbers you enter are only approximated by the binary floating-point numbers actually stored in the machine.
The problem is easier to understand at first in base 10. Consider the fraction 1/3. You can approximate that as a base 10 fraction:
```
0.3

```

or, better,
```
0.33

```

or, better,
```
0.333

```

and so on. No matter how many digits you’re willing to write down, the result will never be exactly 1/3, but will be an increasingly better approximation of 1/3.
In the same way, no matter how many base 2 digits you’re willing to use, the decimal value 0.1 cannot be represented exactly as a base 2 fraction. In base 2, 1/10 is the infinitely repeating fraction
```
0.0001100110011001100110011001100110011001100110011...

```

Stop at any finite number of bits, and you get an approximation. On most machines today, floats are approximated using a binary fraction with the numerator using the first 53 bits starting with the most significant bit and with the denominator as a power of two. In the case of 1/10, the binary fraction is `3602879701896397 / 2 ** 55` which is close to but not exactly equal to the true value of 1/10.
Many users are not aware of the approximation because of the way values are displayed. Python only prints a decimal approximation to the true decimal value of the binary approximation stored by the machine. On most machines, if Python were to print the true decimal value of the binary approximation stored for 0.1, it would have to display:
>>>```
>>> 0.1
0.1000000000000000055511151231257827021181583404541015625

```

That is more digits than most people find useful, so Python keeps the number of digits manageable by displaying a rounded value instead:
>>>```
>>> 1 / 10
0.1