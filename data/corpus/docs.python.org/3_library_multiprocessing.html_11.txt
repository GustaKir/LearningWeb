Title: Multiprocessing - TimeoutError and Communication
URL: https://docs.python.org/3/library/multiprocessing.html
Summary: This section introduces the multiprocessing.TimeoutError, which is raised when a method times out. It also discusses communication methods between processes, emphasizing the use of message passing via Pipe and Queue to avoid the need for synchronization primitives like locks.
---

_exception_ multiprocessing.TimeoutError[¶](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.TimeoutError "Link to this definition")
    
Raised by methods with a timeout when the timeout expires.
### Pipes and Queues[¶](https://docs.python.org/3/library/multiprocessing.html#pipes-and-queues "Link to this heading")
When using multiple processes, one generally uses message passing for communication between processes and avoids having to use any synchronization primitives like locks.
For passing messages one can use [`Pipe()`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Pipe "multiprocessing.Pipe") (for a connection between two processes) or a queue (which allows multiple producers and consumers).
The [`Queue`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Queue "multiprocessing.Queue"), [`SimpleQueue`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.SimpleQueue "multiprocessing.SimpleQueue") and [`JoinableQueue`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.JoinableQueue "multiprocessing.JoinableQueue") types are multi-producer, multi-consumer FIFO queues modelled on the [`queue.Queue`](https://docs.python.org/3/library/queue.html#queue.Queue "queue.Queue") class in the standard library. They differ in that [`Queue`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Queue "multiprocessing.Queue") lacks the [`task_done()`](https://docs.python.org/3/library/queue.html#queue.Queue.task_done "queue.Queue.task_done") and [`join()`](https://docs.python.org/3/library/queue.html#queue.Queue.join "queue.Queue.join") methods introduced into Python 2.5’s [`queue.Queue`](https://docs.python.org/3/library/queue.html#queue.Queue "queue.Queue") class.
If you use [`JoinableQueue`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.JoinableQueue "multiprocessing.JoinableQueue") then you **must** call [`JoinableQueue.task_done()`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.JoinableQueue.task_done "multiprocessing.JoinableQueue.task_done") for each task removed from the queue or else the semaphore used to count the number of unfinished tasks may eventually overflow, raising an exception.
One difference from other Python queue implementations, is that [`multiprocessing`](https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing "multiprocessing: Process-based parallelism.") queues serializes all objects that are put into them using [`pickle`](https://docs.python.org/3/library/pickle.html#module-pickle "pickle: Convert Python objects to streams of bytes and back."). The object return by the get method is a re-created object that does not share memory with the original object.
Note that one can also create a shared queue by using a manager object – see [Managers](https://docs.python.org/3/library/multiprocessing.html#multiprocessing-managers).
Note
[`multiprocessing`](https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing "multiprocessing: Process-based parallelism.") uses the usual [`queue.Empty`](https://docs.python.org/3/library/queue.html#queue.Empty "queue.Empty") and [`queue.Full`](https://docs.python.org/3/library/queue.html#queue.Full "queue.Full") exceptions to signal a timeout. They are not available in the [`multiprocessing`](https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing "multiprocessing: Process-based parallelism.") namespace so you need to import them from [`queue`](https://docs.python.org/3/library/queue.html#module-queue "queue: A synchronized queue class.").
Note
When an object is put on a queue, the object is pickled and a background thread later flushes the pickled data to an underlying pipe. This has some consequences which are a little surprising, but should not cause any practical difficulties – if they really bother you then you can instead use a queue created with a [manager](https://docs.python.org/3/library/multiprocessing.html#multiprocessing-managers).
  1. After putting an object on an empty queue there may be an infinitesimal delay before the queue’s [`empty()`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Queue.empty "multiprocessing.Queue.empty") method returns [`False`](https://docs.python.org/3/library/constants.html#False "False") and [`get_nowait()`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Queue.get_nowait "multiprocessing.Queue.get_nowait") can return without raising [`queue.Empty`](https://docs.python.org/3/library/queue.html#queue.Empty "queue.Empty").
  2. If multiple processes are enqueuing objects, it is possible for the objects to be received at the other end out-of-order. However, objects enqueued by the same process will always be in the expected order with respect to each other.