Title: Validating Poker Hands with Regular Expressions
URL: https://docs.python.org/3/library/re.html
Summary: This document chunk demonstrates how to use regular expressions in Python to validate a poker hand represented as a 5-character string. It shows the use of the `re.compile` function to create a regex pattern for valid hands and provides examples of matching both valid and invalid hands. Additionally, it introduces the concept of backreferences for identifying pairs within the hand.
---

```
defdisplaymatch(match):
  if match is None:
    return None
  return '<Match: %r, groups=%r>' % (match.group(), match.groups())

```

Suppose you are writing a poker program where a player’s hand is represented as a 5-character string with each character representing a card, “a” for ace, “k” for king, “q” for queen, “j” for jack, “t” for 10, and “2” through “9” representing the card with that value.
To see if a given string is a valid hand, one could do the following:
>>>```
>>> valid = re.compile(r"^[a2-9tjqk]{5}$")
>>> displaymatch(valid.match("akt5q")) # Valid.
"<Match: 'akt5q', groups=()>"
>>> displaymatch(valid.match("akt5e")) # Invalid.
>>> displaymatch(valid.match("akt"))  # Invalid.
>>> displaymatch(valid.match("727ak")) # Valid.
"<Match: '727ak', groups=()>"

```

That last hand, `"727ak"`, contained a pair, or two of the same valued cards. To match this with a regular expression, one could use backreferences as such:
>>>```
>>> pair = re.compile(r".*(.).*\1")
>>> displaymatch(pair.match("717ak"))   # Pair of 7s.
"<Match: '717', groups=('7',)>"
>>> displaymatch(pair.match("718ak"))   # No pairs.
>>> displaymatch(pair.match("354aa"))   # Pair of aces.
"<Match: '354aa', groups=('a',)>"

```

To find out what card the pair consists of, one could use the [`group()`](https://docs.python.org/3/library/re.html#re.Match.group "re.Match.group") method of the match object in the following manner:
>>>```
>>> pair = re.compile(r".*(.).*\1")
>>> pair.match("717ak").group(1)
'7'
# Error because re.match() returns None, which doesn't have a group() method:
>>> pair.match("718ak").group(1)
Traceback (most recent call last):
 File "<pyshell#23>", line 1, in <module>
re.match(r".*(.).*\1", "718ak").group(1)
AttributeError: 'NoneType' object has no attribute 'group'
>>> pair.match("354aa").group(1)
'a'

```

### Simulating scanf()[¶](https://docs.python.org/3/library/re.html#simulating-scanf "Link to this heading")
Python does not currently have an equivalent to `scanf()`. Regular expressions are generally more powerful, though also more verbose, than `scanf()` format strings. The table below offers some more-or-less equivalent mappings between `scanf()` format tokens and regular expressions.
`scanf()` Token | Regular Expression  
---|---  
`%c` | `.`  
`%5c` | `.{5}`  
`%d` | `[-+]?\d+`  
`%e`, `%E`, `%f`, `%g` | `[-+]?(\d+(\.\d*)?|\.\d+)([eE][-+]?\d+)?`  
`%i` | `[-+]?(0[xX][\dA-Fa-f]+|0[0-7]*|\d+)`  
`%o` | `[-+]?[0-7]+`  
`%s` | `\S+`  
`%u` | `\d+`  
`%x`, `%X` | `[-+]?(0[xX])?[\dA-Fa-f]+`  
To extract the filename and numbers from a string like
```
/usr/sbin/sendmail - 0 errors, 4 warnings

```

you would use a `scanf()` format like
```
%s - %d errors, %d warnings

```

The equivalent regular expression would be
```
(\S+) - (\d+) errors, (\d+) warnings

```

### search() vs. match()[¶](https://docs.python.org/3/library/re.html#search-vs-match "Link to this heading")
Python offers different primitive operations based on regular expressions:
  * [`re.match()`](https://docs.python.org/3/library/re.html#re.match "re.match") checks for a match only at the beginning of the string
  * [`re.search()`](https://docs.python.org/3/library/re.html#re.search "re.search") checks for a match anywhere in the string (this is what Perl does by default)
  * [`re.fullmatch()`](https://docs.python.org/3/library/re.html#re.fullmatch "re.fullmatch") checks for entire string to be a match


For example:
>>>```
>>> re.match("c", "abcdef")  # No match
>>> re.search("c", "abcdef")  # Match
<re.Match object; span=(2, 3), match='c'>
>>> re.fullmatch("p.*n", "python") # Match
<re.Match object; span=(0, 6), match='python'>
>>> re.fullmatch("r.*n", "python") # No match

```

Regular expressions beginning with `'^'` can be used with [`search()`](https://docs.python.org/3/library/re.html#re.search "re.search") to restrict the match at the beginning of the string:
>>>```
>>> re.match("c", "abcdef")  # No match
>>> re.search("^c", "abcdef") # No match
>>> re.search("^a", "abcdef") # Match
<re.Match object; span=(0, 1), match='a'>

```

Note however that in [`MULTILINE`](https://docs.python.org/3/library/re.html#re.MULTILINE "re.MULTILINE") mode [`match()`](https://docs.python.org/3/library/re.html#re.match "re.match") only matches at the beginning of the string, whereas using [`search()`](https://docs.python.org/3/library/re.html#re.search "re.search") with a regular expression beginning with `'^'` will match at the beginning of each line.
>>>```
>>> re.match("X", "A\nB\nX", re.MULTILINE) # No match
>>> re.search("^X", "A\nB\nX", re.MULTILINE) # Match
<re.Match object; span=(4, 5), match='X'>