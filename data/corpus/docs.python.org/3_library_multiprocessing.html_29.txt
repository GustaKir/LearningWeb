Title: Multiprocessing Namespace in Python
URL: https://docs.python.org/3/library/multiprocessing.html
Summary: The `multiprocessing.managers.Namespace` class allows for the creation of namespace objects that can be registered with the `SyncManager`. These objects have writable attributes and their representation reflects the attribute values. Notably, attributes prefixed with '_' are part of the proxy rather than the referent.
---

_class_ multiprocessing.managers.Namespace[¶](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.managers.Namespace "Link to this definition")
    
A type that can register with [`SyncManager`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.managers.SyncManager "multiprocessing.managers.SyncManager").
A namespace object has no public methods, but does have writable attributes. Its representation shows the values of its attributes.
However, when using a proxy for a namespace object, an attribute beginning with `'_'` will be an attribute of the proxy and not an attribute of the referent:
>>>```
>>> mp_context = multiprocessing.get_context('spawn')
>>> manager = mp_context.Manager()
>>> Global = manager.Namespace()
>>> Global.x = 10
>>> Global.y = 'hello'
>>> Global._z = 12.3  # this is an attribute of the proxy
>>> print(Global)
Namespace(x=10, y='hello')

```

#### Customized managers[¶](https://docs.python.org/3/library/multiprocessing.html#customized-managers "Link to this heading")
To create one’s own manager, one creates a subclass of [`BaseManager`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.managers.BaseManager "multiprocessing.managers.BaseManager") and uses the [`register()`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.managers.BaseManager.register "multiprocessing.managers.BaseManager.register") classmethod to register new types or callables with the manager class. For example:
```
frommultiprocessing.managersimport BaseManager
classMathsClass:
  defadd(self, x, y):
    return x + y
  defmul(self, x, y):
    return x * y
classMyManager(BaseManager):
  pass
MyManager.register('Maths', MathsClass)
if __name__ == '__main__':
  with MyManager() as manager:
    maths = manager.Maths()
    print(maths.add(4, 3))     # prints 7
    print(maths.mul(7, 8))     # prints 56

```

#### Using a remote manager[¶](https://docs.python.org/3/library/multiprocessing.html#using-a-remote-manager "Link to this heading")
It is possible to run a manager server on one machine and have clients use it from other machines (assuming that the firewalls involved allow it).
Running the following commands creates a server for a single shared queue which remote clients can access:
>>>```
>>> frommultiprocessing.managersimport BaseManager
>>> fromqueueimport Queue
>>> queue = Queue()
>>> classQueueManager(BaseManager): pass
>>> QueueManager.register('get_queue', callable=lambda:queue)
>>> m = QueueManager(address=('', 50000), authkey=b'abracadabra')
>>> s = m.get_server()
>>> s.serve_forever()

```

One client can access the server as follows:
>>>```
>>> frommultiprocessing.managersimport BaseManager
>>> classQueueManager(BaseManager): pass
>>> QueueManager.register('get_queue')
>>> m = QueueManager(address=('foo.bar.org', 50000), authkey=b'abracadabra')
>>> m.connect()
>>> queue = m.get_queue()
>>> queue.put('hello')

```

Another client can also use it:
>>>```
>>> frommultiprocessing.managersimport BaseManager
>>> classQueueManager(BaseManager): pass
>>> QueueManager.register('get_queue')
>>> m = QueueManager(address=('foo.bar.org', 50000), authkey=b'abracadabra')
>>> m.connect()
>>> queue = m.get_queue()
>>> queue.get()
'hello'

```

Local processes can also access that queue, using the code from above on the client to access it remotely:
>>>```
>>> frommultiprocessingimport Process, Queue
>>> frommultiprocessing.managersimport BaseManager
>>> classWorker(Process):
...   def__init__(self, q):
...     self.q = q
...     super().__init__()
...   defrun(self):
...     self.q.put('local hello')
...
>>> queue = Queue()
>>> w = Worker(queue)
>>> w.start()
>>> classQueueManager(BaseManager): pass
...
>>> QueueManager.register('get_queue', callable=lambda: queue)
>>> m = QueueManager(address=('', 50000), authkey=b'abracadabra')
>>> s = m.get_server()
>>> s.serve_forever()

```

### Proxy Objects[¶](https://docs.python.org/3/library/multiprocessing.html#proxy-objects "Link to this heading")
A proxy is an object which _refers_ to a shared object which lives (presumably) in a different process. The shared object is said to be the _referent_ of the proxy. Multiple proxy objects may have the same referent.
A proxy object has methods which invoke corresponding methods of its referent (although not every method of the referent will necessarily be available through the proxy). In this way, a proxy can be used just like its referent can:
>>>```
>>> mp_context = multiprocessing.get_context('spawn')
>>> manager = mp_context.Manager()
>>> l = manager.list([i*i for i in range(10)])
>>> print(l)
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
>>> print(repr(l))
<ListProxy object, typeid 'list' at 0x...>
>>> l[4]
16
>>> l[2:5]
[4, 9, 16]