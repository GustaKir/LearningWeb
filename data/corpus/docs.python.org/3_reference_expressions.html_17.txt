Title: Operator Precedence and Power Operations in Python
URL: https://docs.python.org/3/reference/expressions.html
Summary: In Python, the evaluation of unparenthesized power and unary operators occurs from right to left. The power operator, similar to the 'pow()' function, raises the left operand to the power of the right. Numeric types are converted to a common type, and the result type depends on the operands. For integers, results match operand types unless the exponent is negative, which yields a float. Additionally, raising zero to a negative power raises a ZeroDivisionError.
---

```

Thus, in an unparenthesized sequence of power and unary operators, the operators are evaluated from right to left (this does not constrain the evaluation order for the operands): `-1**2` results in `-1`.
The power operator has the same semantics as the built-in [`pow()`](https://docs.python.org/3/library/functions.html#pow "pow") function, when called with two arguments: it yields its left argument raised to the power of its right argument. The numeric arguments are first converted to a common type, and the result is of that type.
For int operands, the result has the same type as the operands unless the second argument is negative; in that case, all arguments are converted to float and a float result is delivered. For example, `10**2` returns `100`, but `10**-2` returns `0.01`.
Raising `0.0` to a negative power results in a [`ZeroDivisionError`](https://docs.python.org/3/library/exceptions.html#ZeroDivisionError "ZeroDivisionError"). Raising a negative number to a fractional power results in a [`complex`](https://docs.python.org/3/library/functions.html#complex "complex") number. (In earlier versions it raised a [`ValueError`](https://docs.python.org/3/library/exceptions.html#ValueError "ValueError").)
This operation can be customized using the special [`__pow__()`](https://docs.python.org/3/reference/datamodel.html#object.__pow__ "object.__pow__") and [`__rpow__()`](https://docs.python.org/3/reference/datamodel.html#object.__rpow__ "object.__rpow__") methods.
## 6.6. Unary arithmetic and bitwise operations[¶](https://docs.python.org/3/reference/expressions.html#unary-arithmetic-and-bitwise-operations "Link to this heading")
All unary arithmetic and bitwise operations have the same priority:
```
**u_expr** ::= [power](https://docs.python.org/3/reference/expressions.html#grammar-token-python-grammar-power) | "-" [u_expr](https://docs.python.org/3/reference/expressions.html#grammar-token-python-grammar-u_expr) | "+" [u_expr](https://docs.python.org/3/reference/expressions.html#grammar-token-python-grammar-u_expr) | "~" [u_expr](https://docs.python.org/3/reference/expressions.html#grammar-token-python-grammar-u_expr)

```

The unary `-` (minus) operator yields the negation of its numeric argument; the operation can be overridden with the [`__neg__()`](https://docs.python.org/3/reference/datamodel.html#object.__neg__ "object.__neg__") special method.
The unary `+` (plus) operator yields its numeric argument unchanged; the operation can be overridden with the [`__pos__()`](https://docs.python.org/3/reference/datamodel.html#object.__pos__ "object.__pos__") special method.
The unary `~` (invert) operator yields the bitwise inversion of its integer argument. The bitwise inversion of `x` is defined as `-(x+1)`. It only applies to integral numbers or to custom objects that override the [`__invert__()`](https://docs.python.org/3/reference/datamodel.html#object.__invert__ "object.__invert__") special method.
In all three cases, if the argument does not have the proper type, a [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError "TypeError") exception is raised.
## 6.7. Binary arithmetic operations[¶](https://docs.python.org/3/reference/expressions.html#binary-arithmetic-operations "Link to this heading")
The binary arithmetic operations have the conventional priority levels. Note that some of these operations also apply to certain non-numeric types. Apart from the power operator, there are only two levels, one for multiplicative operators and one for additive operators: