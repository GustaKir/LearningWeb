Title: ASDL Built-in Types and Module Structure
URL: https://docs.python.org/3/library/ast.html
Summary: This document chunk describes ASDL's four built-in types: identifier, int, string, and constant. It outlines the structure of a Python module, including various statement types such as FunctionDef, AsyncFunctionDef, ClassDef, Return, and others in the context of Python's abstract syntax representation.
---

```
-- ASDL's 4 builtin types are:
-- identifier, int, string, constant
module Python
{
  mod = Module(stmt* body, type_ignore* type_ignores)
    | Interactive(stmt* body)
    | Expression(exprbody)
    | FunctionType(expr* argtypes, exprreturns)
  stmt = FunctionDef(identifiername, argumentsargs,
            stmt* body, expr* decorator_list, expr? returns,
            string? type_comment, type_param* type_params)
     | AsyncFunctionDef(identifiername, argumentsargs,
               stmt* body, expr* decorator_list, expr? returns,
               string? type_comment, type_param* type_params)
     | ClassDef(identifiername,
       expr* bases,
       keyword* keywords,
       stmt* body,
       expr* decorator_list,
       type_param* type_params)
     | Return(expr? value)
     | Delete(expr* targets)
     | Assign(expr* targets, exprvalue, string? type_comment)
     | TypeAlias(exprname, type_param* type_params, exprvalue)
     | AugAssign(exprtarget, operatorop, exprvalue)
     -- 'simple' indicates that we annotate simple name without parens
     | AnnAssign(exprtarget, exprannotation, expr? value, intsimple)
     -- use 'orelse' because else is a keyword in target languages
     | For(exprtarget, expriter, stmt* body, stmt* orelse, string? type_comment)
     | AsyncFor(exprtarget, expriter, stmt* body, stmt* orelse, string? type_comment)
     | While(exprtest, stmt* body, stmt* orelse)
     | If(exprtest, stmt* body, stmt* orelse)
     | With(withitem* items, stmt* body, string? type_comment)
     | AsyncWith(withitem* items, stmt* body, string? type_comment)
     | Match(exprsubject, match_case* cases)
     | Raise(expr? exc, expr? cause)
     | Try(stmt* body, excepthandler* handlers, stmt* orelse, stmt* finalbody)
     | TryStar(stmt* body, excepthandler* handlers, stmt* orelse, stmt* finalbody)
     | Assert(exprtest, expr? msg)
     | Import(alias* names)
     | ImportFrom(identifier? module, alias* names, int? level)
     | Global(identifier* names)
     | Nonlocal(identifier* names)
     | Expr(exprvalue)
     | Pass | Break | Continue
     -- col_offset is the byte offset in the utf8 string the parser uses
     attributes (intlineno, intcol_offset, int? end_lineno, int? end_col_offset)
     -- BoolOp() can use left & right?
  expr = BoolOp(boolopop, expr* values)
     | NamedExpr(exprtarget, exprvalue)
     | BinOp(exprleft, operatorop, exprright)
     | UnaryOp(unaryopop, exproperand)
     | Lambda(argumentsargs, exprbody)
     | IfExp(exprtest, exprbody, exprorelse)
     | Dict(expr* keys, expr* values)
     | Set(expr* elts)
     | ListComp(exprelt, comprehension* generators)
     | SetComp(exprelt, comprehension* generators)
     | DictComp(exprkey, exprvalue, comprehension* generators)
     | GeneratorExp(exprelt, comprehension* generators)
     -- the grammar constrains where yield expressions can occur
     | Await(exprvalue)
     | Yield(expr? value)
     | YieldFrom(exprvalue)
     -- need sequences for compare to distinguish between
     -- x < 4 < 3 and (x < 4) < 3
     | Compare(exprleft, cmpop* ops, expr* comparators)
     | Call(exprfunc, expr* args, keyword* keywords)
     | FormattedValue(exprvalue, intconversion, expr? format_spec)
     | JoinedStr(expr* values)
     | Constant(constantvalue, string? kind)
     -- the following expression can appear in assignment context
     | Attribute(exprvalue, identifierattr, expr_contextctx)
     | Subscript(exprvalue, exprslice, expr_contextctx)
     | Starred(exprvalue, expr_contextctx)
     | Name(identifierid, expr_contextctx)
     | List(expr* elts, expr_contextctx)
     | Tuple(expr* elts, expr_contextctx)
     -- can appear only in Subscript
     | Slice(expr? lower, expr? upper, expr? step)
     -- col_offset is the byte offset in the utf8 string the parser uses
     attributes (intlineno, intcol_offset, int? end_lineno, int? end_col_offset)
  expr_context = Load | Store | Del
  boolop = And | Or
  operator = Add | Sub | Mult | MatMult | Div | Mod | Pow | LShift
         | RShift | BitOr | BitXor | BitAnd | FloorDiv
  unaryop = Invert | Not | UAdd | USub
  cmpop = Eq | NotEq | Lt | LtE | Gt | GtE | Is | IsNot | In | NotIn
  comprehension = (exprtarget, expriter, expr* ifs, intis_async)
  excepthandler = ExceptHandler(expr? type, identifier? name, stmt* body)
          attributes (intlineno, intcol_offset, int? end_lineno, int? end_col_offset)
  arguments = (arg* posonlyargs, arg* args, arg? vararg, arg* kwonlyargs,
         expr* kw_defaults, arg? kwarg, expr* defaults)
  arg = (identifierarg, expr? annotation, string? type_comment)
      attributes (intlineno, intcol_offset, int? end_lineno, int? end_col_offset)
  -- keyword arguments supplied to call (NULL identifier for **kwargs)
  keyword = (identifier? arg, exprvalue)
        attributes (intlineno, intcol_offset, int? end_lineno, int? end_col_offset)
  -- import name with optional 'as' alias.
  alias = (identifiername, identifier? asname)
       attributes (intlineno, intcol_