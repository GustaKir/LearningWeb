Title: Logging Cookbook - Using MemoryHandler
URL: https://docs.python.org/3/howto/logging-cookbook.html
Summary: This document provides an example of how to use Python's logging library with a MemoryHandler to log errors. It defines a function 'log_if_errors' that sets up a MemoryHandler to capture log messages if a function fails. The handler can be customized with a target and other parameters, allowing for flexible logging behavior.
---

```
importlogging
fromlogging.handlersimport MemoryHandler
importsys
logger = logging.getLogger(__name__)
logger.addHandler(logging.NullHandler())
deflog_if_errors(logger, target_handler=None, flush_level=None, capacity=None):
  if target_handler is None:
    target_handler = logging.StreamHandler()
  if flush_level is None:
    flush_level = logging.ERROR
  if capacity is None:
    capacity = 100
  handler = MemoryHandler(capacity, flushLevel=flush_level, target=target_handler)
  defdecorator(fn):
    defwrapper(*args, **kwargs):
      logger.addHandler(handler)
      try:
        return fn(*args, **kwargs)
      except Exception:
        logger.exception('call failed')
        raise
      finally:
        super(MemoryHandler, handler).flush()
        logger.removeHandler(handler)
    return wrapper
  return decorator
defwrite_line(s):
  sys.stderr.write('%s\n' % s)
deffoo(fail=False):
  write_line('about to log at DEBUG ...')
  logger.debug('Actually logged at DEBUG')
  write_line('about to log at INFO ...')
  logger.info('Actually logged at INFO')
  write_line('about to log at WARNING ...')
  logger.warning('Actually logged at WARNING')
  if fail:
    write_line('about to log at ERROR ...')
    logger.error('Actually logged at ERROR')
    write_line('about to log at CRITICAL ...')
    logger.critical('Actually logged at CRITICAL')
  return fail
decorated_foo = log_if_errors(logger)(foo)
if __name__ == '__main__':
  logger.setLevel(logging.DEBUG)
  write_line('Calling undecorated foo with False')
  assert not foo(False)
  write_line('Calling undecorated foo with True')
  assert foo(True)
  write_line('Calling decorated foo with False')
  assert not decorated_foo(False)
  write_line('Calling decorated foo with True')
  assert decorated_foo(True)

```

When this script is run, the following output should be observed:
```
Calling undecorated foo with False
about to log at DEBUG ...
about to log at INFO ...
about to log at WARNING ...
Calling undecorated foo with True
about to log at DEBUG ...
about to log at INFO ...
about to log at WARNING ...
about to log at ERROR ...
about to log at CRITICAL ...
Calling decorated foo with False
about to log at DEBUG ...
about to log at INFO ...
about to log at WARNING ...
Calling decorated foo with True
about to log at DEBUG ...
about to log at INFO ...
about to log at WARNING ...
about to log at ERROR ...
Actually logged at DEBUG
Actually logged at INFO
Actually logged at WARNING
Actually logged at ERROR
about to log at CRITICAL ...
Actually logged at CRITICAL

```

As you can see, actual logging output only occurs when an event is logged whose severity is ERROR or greater, but in that case, any previous events at lower severities are also logged.
You can of course use the conventional means of decoration:
```
@log_if_errors(logger)
deffoo(fail=False):
  ...

```

## Sending logging messages to email, with buffering[Â¶](https://docs.python.org/3/howto/logging-cookbook.html#sending-logging-messages-to-email-with-buffering "Link to this heading")
To illustrate how you can send log messages via email, so that a set number of messages are sent per email, you can subclass [`BufferingHandler`](https://docs.python.org/3/library/logging.handlers.html#logging.handlers.BufferingHandler "logging.handlers.BufferingHandler"). In the following example, which you can adapt to suit your specific needs, a simple test harness is provided which allows you to run the script with command line arguments specifying what you typically need to send things via SMTP. (Run the downloaded script with the `-h` argument to see the required and optional arguments.)