Title: Introduction to Pattern Matching in Python 3.10
URL: https://docs.python.org/3/whatsnew/3.10.html
Summary: The match statement in Python 3.10 allows for pattern matching by comparing an expression's value against various patterns in case blocks. The process involves evaluating a subject, checking against patterns sequentially, executing actions upon confirmed matches, and using a wildcard for unmatched cases.
---

```

A match statement takes an expression and compares its value to successive patterns given as one or more case blocks. Specifically, pattern matching operates by:
  1. using data with type and shape (the `subject`)
  2. evaluating the `subject` in the `match` statement
  3. comparing the subject with each pattern in a `case` statement from top to bottom until a match is confirmed.
  4. executing the action associated with the pattern of the confirmed match
  5. If an exact match is not confirmed, the last case, a wildcard `_`, if provided, will be used as the matching case. If an exact match is not confirmed and a wildcard case does not exist, the entire match block is a no-op.


#### Declarative approach[¶](https://docs.python.org/3/whatsnew/3.10.html#declarative-approach "Link to this heading")
Readers may be aware of pattern matching through the simple example of matching a subject (data object) to a literal (pattern) with the switch statement found in C, Java or JavaScript (and many other languages). Often the switch statement is used for comparison of an object/expression with case statements containing literals.
More powerful examples of pattern matching can be found in languages such as Scala and Elixir. With structural pattern matching, the approach is “declarative” and explicitly states the conditions (the patterns) for data to match.
While an “imperative” series of instructions using nested “if” statements could be used to accomplish something similar to structural pattern matching, it is less clear than the “declarative” approach. Instead the “declarative” approach states the conditions to meet for a match and is more readable through its explicit patterns. While structural pattern matching can be used in its simplest form comparing a variable to a literal in a case statement, its true value for Python lies in its handling of the subject’s type and shape.
#### Simple pattern: match to a literal[¶](https://docs.python.org/3/whatsnew/3.10.html#simple-pattern-match-to-a-literal "Link to this heading")
Let’s look at this example as pattern matching in its simplest form: a value, the subject, being matched to several literals, the patterns. In the example below, `status` is the subject of the match statement. The patterns are each of the case statements, where literals represent request status codes. The associated action to the case is executed after a match:
```
defhttp_error(status):
  match status:
    case 400:
      return "Bad request"
    case 404:
      return "Not found"
    case 418:
      return "I'm a teapot"
    case_:
      return "Something's wrong with the internet"

```

If the above function is passed a `status` of 418, “I’m a teapot” is returned. If the above function is passed a `status` of 500, the case statement with `_` will match as a wildcard, and “Something’s wrong with the internet” is returned. Note the last block: the variable name, `_`, acts as a _wildcard_ and insures the subject will always match. The use of `_` is optional.
You can combine several literals in a single pattern using `|` (“or”):
```
case 401 | 403 | 404:
  return "Not allowed"

```

##### Behavior without the wildcard[¶](https://docs.python.org/3/whatsnew/3.10.html#behavior-without-the-wildcard "Link to this heading")
If we modify the above example by removing the last case block, the example becomes:
```
defhttp_error(status):
  match status:
    case 400:
      return "Bad request"
    case 404:
      return "Not found"
    case 418:
      return "I'm a teapot"

```

Without the use of `_` in a case statement, a match may not exist. If no match exists, the behavior is a no-op. For example, if `status` of 500 is passed, a no-op occurs.
#### Patterns with a literal and variable[¶](https://docs.python.org/3/whatsnew/3.10.html#patterns-with-a-literal-and-variable "Link to this heading")
Patterns can look like unpacking assignments, and a pattern may be used to bind variables. In this example, a data point can be unpacked to its x-coordinate and y-coordinate:
```
# point is an (x, y) tuple
match point:
  case (0, 0):
    print("Origin")
  case (0, y):
    print(f"Y={y}")
  case (x, 0):
    print(f"X={x}")
  case (x, y):
    print(f"X={x}, Y={y}")
  case_:
    raise ValueError("Not a point")

```

The first pattern has two literals, `(0, 0)`, and may be thought of as an extension of the literal pattern shown above. The next two patterns combine a literal and a variable, and the variable _binds_ a value from the subject (`point`). The fourth pattern captures two values, which makes it conceptually similar to the unpacking assignment `(x, y) = point`.
#### Patterns and classes[¶](https://docs.python.org/3/whatsnew/3.10.html#patterns-and-classes "Link to this heading")
If you are using classes to structure your data, you can use as a pattern the class name followed by an argument list resembling a constructor. This pattern has the ability to capture class attributes into variables: