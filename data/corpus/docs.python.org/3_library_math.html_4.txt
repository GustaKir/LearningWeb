Title: Math Library Functions: Fused Multiply-Add and Floating-Point Remainder
URL: https://docs.python.org/3/library/math.html
Summary: The `math.fma(x, y, z)` function performs a fused multiply-add operation, returning `(x * y) + z` with improved accuracy through infinite precision and a single rounding. It adheres to IEEE 754 standards, returning NaN for certain edge cases. Additionally, `math.fmod(x, y)` provides the floating-point remainder of `x / y`, aligning with the C library's `fmod`, which may differ from the Python modulus operator.
---

math.fma(_x_ , _y_ , _z_)[¶](https://docs.python.org/3/library/math.html#math.fma "Link to this definition")
    
Fused multiply-add operation. Return `(x * y) + z`, computed as though with infinite precision and range followed by a single round to the `float` format. This operation often provides better accuracy than the direct expression `(x * y) + z`.
This function follows the specification of the fusedMultiplyAdd operation described in the IEEE 754 standard. The standard leaves one case implementation-defined, namely the result of `fma(0, inf, nan)` and `fma(inf, 0, nan)`. In these cases, `math.fma` returns a NaN, and does not raise any exception.
Added in version 3.13. 

math.fmod(_x_ , _y_)[¶](https://docs.python.org/3/library/math.html#math.fmod "Link to this definition")
    
Return the floating-point remainder of `x / y`, as defined by the platform C library function `fmod(x, y)`. Note that the Python expression `x % y` may not return the same result. The intent of the C standard is that `fmod(x, y)` be exactly (mathematically; to infinite precision) equal to `x - n*y` for some integer _n_ such that the result has the same sign as _x_ and magnitude less than `abs(y)`. Python’s `x % y` returns a result with the sign of _y_ instead, and may not be exactly computable for float arguments. For example, `fmod(-1e-100, 1e100)` is `-1e-100`, but the result of Python’s `-1e-100 % 1e100` is `1e100-1e-100`, which cannot be represented exactly as a float, and rounds to the surprising `1e100`. For this reason, function [`fmod()`](https://docs.python.org/3/library/math.html#math.fmod "math.fmod") is generally preferred when working with floats, while Python’s `x % y` is preferred when working with integers. 

math.modf(_x_)[¶](https://docs.python.org/3/library/math.html#math.modf "Link to this definition")
    
Return the fractional and integer parts of _x_. Both results carry the sign of _x_ and are floats.
Note that [`modf()`](https://docs.python.org/3/library/math.html#math.modf "math.modf") has a different call/return pattern than its C equivalents: it takes a single argument and return a pair of values, rather than returning its second return value through an ‘output parameter’ (there is no such thing in Python). 

math.remainder(_x_ , _y_)[¶](https://docs.python.org/3/library/math.html#math.remainder "Link to this definition")
    
Return the IEEE 754-style remainder of _x_ with respect to _y_. For finite _x_ and finite nonzero _y_ , this is the difference `x - n*y`, where `n` is the closest integer to the exact value of the quotient `x / y`. If `x / y` is exactly halfway between two consecutive integers, the nearest _even_ integer is used for `n`. The remainder `r = remainder(x, y)` thus always satisfies `abs(r) <= 0.5 * abs(y)`.
Special cases follow IEEE 754: in particular, `remainder(x, math.inf)` is _x_ for any finite _x_ , and `remainder(x, 0)` and `remainder(math.inf, x)` raise [`ValueError`](https://docs.python.org/3/library/exceptions.html#ValueError "ValueError") for any non-NaN _x_. If the result of the remainder operation is zero, that zero will have the same sign as _x_.
On platforms using IEEE 754 binary floating point, the result of this operation is always exactly representable: no rounding error is introduced.
Added in version 3.7. 

math.trunc(_x_)[¶](https://docs.python.org/3/library/math.html#math.trunc "Link to this definition")
    
Return _x_ with the fractional part removed, leaving the integer part. This rounds toward 0: `trunc()` is equivalent to [`floor()`](https://docs.python.org/3/library/math.html#math.floor "math.floor") for positive _x_ , and equivalent to [`ceil()`](https://docs.python.org/3/library/math.html#math.ceil "math.ceil") for negative _x_. If _x_ is not a float, delegates to [`x.__trunc__`](https://docs.python.org/3/reference/datamodel.html#object.__trunc__ "object.__trunc__"), which should return an [`Integral`](https://docs.python.org/3/library/numbers.html#numbers.Integral "numbers.Integral") value.
For the [`ceil()`](https://docs.python.org/3/library/math.html#math.ceil "math.ceil"), [`floor()`](https://docs.python.org/3/library/math.html#math.floor "math.floor"), and [`modf()`](https://docs.python.org/3/library/math.html#math.modf "math.modf") functions, note that _all_ floating-point numbers of sufficiently large magnitude are exact integers. Python floats typically carry no more than 53 bits of precision (the same as the platform C double type), in which case any float _x_ with `abs(x) >= 2**52` necessarily has no fractional bits.
## Floating point manipulation functions[¶](https://docs.python.org/3/library/math.html#floating-point-manipulation-functions "Link to this heading") 

math.copysign(_x_ , _y_)[¶](https://docs.python.org/3/library/math.html#math.copysign "Link to this definition")
    
Return a float with the magnitude (absolute value) of _x_ but the sign of _y_. On platforms that support signed zeros, `copysign(1.0, -0.0)` returns _-1.0_.