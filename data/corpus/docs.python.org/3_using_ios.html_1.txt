Title: Using Python on iOS
URL: https://docs.python.org/3/using/ios.html
Summary: Python on iOS differs from desktop platforms as it cannot be installed as a system resource. Instead, it is used in embedded mode within native iOS applications by integrating a Python interpreter through `libPython`. This requires packaging the interpreter and library with the app, as there is no console or REPL interface available on iOS.
---

Authors:
    
Russell Keith-Magee (2024-03)
Python on iOS is unlike Python on desktop platforms. On a desktop platform, Python is generally installed as a system resource that can be used by any user of that computer. Users then interact with Python by running a **python** executable and entering commands at an interactive prompt, or by running a Python script.
On iOS, there is no concept of installing as a system resource. The only unit of software distribution is an “app”. There is also no console where you could run a **python** executable, or interact with a Python REPL.
As a result, the only way you can use Python on iOS is in embedded mode - that is, by writing a native iOS application, and embedding a Python interpreter using `libPython`, and invoking Python code using the [Python embedding API](https://docs.python.org/3/extending/embedding.html#embedding). The full Python interpreter, the standard library, and all your Python code is then packaged as a standalone bundle that can be distributed via the iOS App Store.
If you’re looking to experiment for the first time with writing an iOS app in Python, projects such as [BeeWare](https://beeware.org) and [Kivy](https://kivy.org) will provide a much more approachable user experience. These projects manage the complexities associated with getting an iOS project running, so you only need to deal with the Python code itself.
## 7.1. Python at runtime on iOS[¶](https://docs.python.org/3/using/ios.html#python-at-runtime-on-ios "Link to this heading")
### 7.1.1. iOS version compatibility[¶](https://docs.python.org/3/using/ios.html#ios-version-compatibility "Link to this heading")
The minimum supported iOS version is specified at compile time, using the [`--host`](https://docs.python.org/3/using/configure.html#cmdoption-host) option to `configure`. By default, when compiled for iOS, Python will be compiled with a minimum supported iOS version of 13.0. To use a different minimum iOS version, provide the version number as part of the `--host` argument - for example, `--host=arm64-apple-ios15.4-simulator` would compile an ARM64 simulator build with a deployment target of 15.4.
### 7.1.2. Platform identification[¶](https://docs.python.org/3/using/ios.html#platform-identification "Link to this heading")
When executing on iOS, `sys.platform` will report as `ios`. This value will be returned on an iPhone or iPad, regardless of whether the app is running on the simulator or a physical device.
Information about the specific runtime environment, including the iOS version, device model, and whether the device is a simulator, can be obtained using [`platform.ios_ver()`](https://docs.python.org/3/library/platform.html#platform.ios_ver "platform.ios_ver"). [`platform.system()`](https://docs.python.org/3/library/platform.html#platform.system "platform.system") will report `iOS` or `iPadOS`, depending on the device.
[`os.uname()`](https://docs.python.org/3/library/os.html#os.uname "os.uname") reports kernel-level details; it will report a name of `Darwin`.
### 7.1.3. Standard library availability[¶](https://docs.python.org/3/using/ios.html#standard-library-availability "Link to this heading")
The Python standard library has some notable omissions and restrictions on iOS. See the [API availability guide for iOS](https://docs.python.org/3/library/intro.html#mobile-availability) for details.
### 7.1.4. Binary extension modules[¶](https://docs.python.org/3/using/ios.html#binary-extension-modules "Link to this heading")
One notable difference about iOS as a platform is that App Store distribution imposes hard requirements on the packaging of an application. One of these requirements governs how binary extension modules are distributed.
The iOS App Store requires that _all_ binary modules in an iOS app must be dynamic libraries, contained in a framework with appropriate metadata, stored in the `Frameworks` folder of the packaged app. There can be only a single binary per framework, and there can be no executable binary material outside the `Frameworks` folder.
This conflicts with the usual Python approach for distributing binaries, which allows a binary extension module to be loaded from any location on `sys.path`. To ensure compliance with App Store policies, an iOS project must post-process any Python packages, converting `.so` binary modules into individual standalone frameworks with appropriate metadata and signing. For details on how to perform this post-processing, see the guide for [adding Python to your project](https://docs.python.org/3/using/ios.html#adding-ios).
To help Python discover binaries in their new location, the original `.so` file on `sys.path` is replaced with a `.fwork` file. This file is a text file containing the location of the framework binary, relative to the app bundle. To allow the framework to resolve back to the original location, the framework must contain a `.origin` file that contains the location of the `.fwork` file, relative to the app bundle