Title: Decoding Bytes and Bytearray in Python
URL: https://docs.python.org/3/library/stdtypes.html
Summary: This section discusses the `decode` method for `bytes` and `bytearray` in Python. It notes that the method does not operate in place for `bytearray`, always producing a new object. The encoding defaults to 'utf-8', and an overview of error handling options is provided.
---

```

The _suffix_ may be any [bytes-like object](https://docs.python.org/3/glossary.html#term-bytes-like-object).
Note
The bytearray version of this method does _not_ operate in place - it always produces a new object, even if no changes were made.
Added in version 3.9. 

bytes.decode(_encoding ='utf-8'_, _errors ='strict'_)[¶](https://docs.python.org/3/library/stdtypes.html#bytes.decode "Link to this definition")


bytearray.decode(_encoding ='utf-8'_, _errors ='strict'_)[¶](https://docs.python.org/3/library/stdtypes.html#bytearray.decode "Link to this definition")
    
Return the bytes decoded to a [`str`](https://docs.python.org/3/library/stdtypes.html#str "str").
_encoding_ defaults to `'utf-8'`; see [Standard Encodings](https://docs.python.org/3/library/codecs.html#standard-encodings) for possible values.
_errors_ controls how decoding errors are handled. If `'strict'` (the default), a [`UnicodeError`](https://docs.python.org/3/library/exceptions.html#UnicodeError "UnicodeError") exception is raised. Other possible values are `'ignore'`, `'replace'`, and any other name registered via [`codecs.register_error()`](https://docs.python.org/3/library/codecs.html#codecs.register_error "codecs.register_error"). See [Error Handlers](https://docs.python.org/3/library/codecs.html#error-handlers) for details.
For performance reasons, the value of _errors_ is not checked for validity unless a decoding error actually occurs, [Python Development Mode](https://docs.python.org/3/library/devmode.html#devmode) is enabled or a [debug build](https://docs.python.org/3/using/configure.html#debug-build) is used.
Note
Passing the _encoding_ argument to [`str`](https://docs.python.org/3/library/stdtypes.html#str "str") allows decoding any [bytes-like object](https://docs.python.org/3/glossary.html#term-bytes-like-object) directly, without needing to make a temporary `bytes` or `bytearray` object.
Changed in version 3.1: Added support for keyword arguments.
Changed in version 3.9: The value of the _errors_ argument is now checked in [Python Development Mode](https://docs.python.org/3/library/devmode.html#devmode) and in [debug mode](https://docs.python.org/3/using/configure.html#debug-build). 

bytes.endswith(_suffix_[, _start_[, _end_]])[¶](https://docs.python.org/3/library/stdtypes.html#bytes.endswith "Link to this definition")


bytearray.endswith(_suffix_[, _start_[, _end_]])[¶](https://docs.python.org/3/library/stdtypes.html#bytearray.endswith "Link to this definition")
    
Return `True` if the binary data ends with the specified _suffix_ , otherwise return `False`. _suffix_ can also be a tuple of suffixes to look for. With optional _start_ , test beginning at that position. With optional _end_ , stop comparing at that position.
The suffix(es) to search for may be any [bytes-like object](https://docs.python.org/3/glossary.html#term-bytes-like-object). 

bytes.find(_sub_[, _start_[, _end_]])[¶](https://docs.python.org/3/library/stdtypes.html#bytes.find "Link to this definition")


bytearray.find(_sub_[, _start_[, _end_]])[¶](https://docs.python.org/3/library/stdtypes.html#bytearray.find "Link to this definition")
    
Return the lowest index in the data where the subsequence _sub_ is found, such that _sub_ is contained in the slice `s[start:end]`. Optional arguments _start_ and _end_ are interpreted as in slice notation. Return `-1` if _sub_ is not found.
The subsequence to search for may be any [bytes-like object](https://docs.python.org/3/glossary.html#term-bytes-like-object) or an integer in the range 0 to 255.
Note
The [`find()`](https://docs.python.org/3/library/stdtypes.html#bytes.find "bytes.find") method should be used only if you need to know the position of _sub_. To check if _sub_ is a substring or not, use the [`in`](https://docs.python.org/3/reference/expressions.html#in) operator:
>>>```
>>> b'Py' in b'Python'
True