Title: Tkinter Documentation Overview
URL: https://docs.python.org/3/library/tkinter.html
Summary: The section outlines where to find detailed method documentation for various Tkinter widgets in the official Tcl/Tk reference. It explains that method calls for specific widgets are located on their respective man pages, while functions involving widgets may have dedicated pages. Common options and methods are documented in the 'options' and 'ttk::widget' man pages, alongside specific widget class documentation.
---

```

In the official Tcl/Tk reference documentation, you’ll find most operations that look like method calls on the man page for a specific widget (e.g., you’ll find the `invoke()` method on the [ttk::button](https://www.tcl.tk/man/tcl8.6/TkCmd/ttk_button.htm) man page), while functions that take a widget as a parameter often have their own man page (e.g., [grid](https://www.tcl.tk/man/tcl8.6/TkCmd/grid.htm)).
You’ll find many common options and methods in the [options](https://www.tcl.tk/man/tcl8.6/TkCmd/options.htm) or [ttk::widget](https://www.tcl.tk/man/tcl8.6/TkCmd/ttk_widget.htm) man pages, while others are found in the man page for a specific widget class.
You’ll also find that many Tkinter methods have compound names, e.g., `winfo_x()`, `winfo_height()`, `winfo_viewable()`. You’d find documentation for all of these in the [winfo](https://www.tcl.tk/man/tcl8.6/TkCmd/winfo.htm) man page.
Note
Somewhat confusingly, there are also methods on all Tkinter widgets that don’t actually operate on the widget, but operate at a global scope, independent of any widget. Examples are methods for accessing the clipboard or the system bell. (They happen to be implemented as methods in the base `Widget` class that all Tkinter widgets inherit from).
## Threading model[¶](https://docs.python.org/3/library/tkinter.html#threading-model "Link to this heading")
Python and Tcl/Tk have very different threading models, which [`tkinter`](https://docs.python.org/3/library/tkinter.html#module-tkinter "tkinter: Interface to Tcl/Tk for graphical user interfaces") tries to bridge. If you use threads, you may need to be aware of this.
A Python interpreter may have many threads associated with it. In Tcl, multiple threads can be created, but each thread has a separate Tcl interpreter instance associated with it. Threads can also create more than one interpreter instance, though each interpreter instance can be used only by the one thread that created it.
Each `Tk` object created by [`tkinter`](https://docs.python.org/3/library/tkinter.html#module-tkinter "tkinter: Interface to Tcl/Tk for graphical user interfaces") contains a Tcl interpreter. It also keeps track of which thread created that interpreter. Calls to [`tkinter`](https://docs.python.org/3/library/tkinter.html#module-tkinter "tkinter: Interface to Tcl/Tk for graphical user interfaces") can be made from any Python thread. Internally, if a call comes from a thread other than the one that created the `Tk` object, an event is posted to the interpreter’s event queue, and when executed, the result is returned to the calling Python thread.
Tcl/Tk applications are normally event-driven, meaning that after initialization, the interpreter runs an event loop (i.e. `Tk.mainloop()`) and responds to events. Because it is single-threaded, event handlers must respond quickly, otherwise they will block other events from being processed. To avoid this, any long-running computations should not run in an event handler, but are either broken into smaller pieces using timers, or run in another thread. This is different from many GUI toolkits where the GUI runs in a completely separate thread from all application code including event handlers.
If the Tcl interpreter is not running the event loop and processing events, any [`tkinter`](https://docs.python.org/3/library/tkinter.html#module-tkinter "tkinter: Interface to Tcl/Tk for graphical user interfaces") calls made from threads other than the one running the Tcl interpreter will fail.
A number of special cases exist:
  * Tcl/Tk libraries can be built so they are not thread-aware. In this case, [`tkinter`](https://docs.python.org/3/library/tkinter.html#module-tkinter "tkinter: Interface to Tcl/Tk for graphical user interfaces") calls the library from the originating Python thread, even if this is different than the thread that created the Tcl interpreter. A global lock ensures only one call occurs at a time.
  * While [`tkinter`](https://docs.python.org/3/library/tkinter.html#module-tkinter "tkinter: Interface to Tcl/Tk for graphical user interfaces") allows you to create more than one instance of a `Tk` object (with its own interpreter), all interpreters that are part of the same thread share a common event queue, which gets ugly fast. In practice, don’t create more than one instance of `Tk` at a time. Otherwise, it’s best to create them in separate threads and ensure you’re running a thread-aware Tcl/Tk build.
  * Blocking event handlers are not the only way to prevent the Tcl interpreter from reentering the event loop. It is even possible to run multiple nested event loops or abandon the event loop entirely. If you’re doing anything tricky when it comes to events or threads, be aware of these possibilities.
  * There are a few select [`tkinter`](https://docs.python.org/3/library/tkinter.html#module-tkinter "tkinter: Interface to Tcl/Tk for graphical user interfaces") functions that presently work only when called from the thread that created t