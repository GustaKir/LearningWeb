Title: socket.getaddrinfo Function
URL: https://docs.python.org/3/library/socket.html
Summary: The `socket.getaddrinfo` function translates a host and port into a sequence of 5-tuples for socket creation. It accepts a domain name or IP as _host_ and a service name or port number as _port_. Optional parameters include _family_, _type_, and _proto_ to refine the results.
---

socket.getaddrinfo(_host_ , _port_ , _family =AF_UNSPEC_, _type =0_, _proto =0_, _flags =0_)[¶](https://docs.python.org/3/library/socket.html#socket.getaddrinfo "Link to this definition")
    
This function wraps the C function `getaddrinfo` of the underlying system.
Translate the _host_ /_port_ argument into a sequence of 5-tuples that contain all the necessary arguments for creating a socket connected to that service. _host_ is a domain name, a string representation of an IPv4/v6 address or `None`. _port_ is a string service name such as `'http'`, a numeric port number or `None`. By passing `None` as the value of _host_ and _port_ , you can pass `NULL` to the underlying C API.
The _family_ , _type_ and _proto_ arguments can be optionally specified in order to provide options and limit the list of addresses returned. Pass their default values ([`AF_UNSPEC`](https://docs.python.org/3/library/socket.html#socket.AF_UNSPEC "socket.AF_UNSPEC"), 0, and 0, respectively) to not limit the results. See the note below for details.
The _flags_ argument can be one or several of the `AI_*` constants, and will influence how results are computed and returned. For example, `AI_NUMERICHOST` will disable domain name resolution and will raise an error if _host_ is a domain name.
The function returns a list of 5-tuples with the following structure:
`(family, type, proto, canonname, sockaddr)`
In these tuples, _family_ , _type_ , _proto_ are all integers and are meant to be passed to the [`socket()`](https://docs.python.org/3/library/socket.html#socket.socket "socket.socket") function. _canonname_ will be a string representing the canonical name of the _host_ if `AI_CANONNAME` is part of the _flags_ argument; else _canonname_ will be empty. _sockaddr_ is a tuple describing a socket address, whose format depends on the returned _family_ (a `(address, port)` 2-tuple for [`AF_INET`](https://docs.python.org/3/library/socket.html#socket.AF_INET "socket.AF_INET"), a `(address, port, flowinfo, scope_id)` 4-tuple for [`AF_INET6`](https://docs.python.org/3/library/socket.html#socket.AF_INET6 "socket.AF_INET6")), and is meant to be passed to the [`socket.connect()`](https://docs.python.org/3/library/socket.html#socket.socket.connect "socket.socket.connect") method.
Note
If you intend to use results from `getaddrinfo()` to create a socket (rather than, for example, retrieve _canonname_), consider limiting the results by _type_ (e.g. [`SOCK_STREAM`](https://docs.python.org/3/library/socket.html#socket.SOCK_STREAM "socket.SOCK_STREAM") or [`SOCK_DGRAM`](https://docs.python.org/3/library/socket.html#socket.SOCK_DGRAM "socket.SOCK_DGRAM")) and/or _proto_ (e.g. `IPPROTO_TCP` or `IPPROTO_UDP`) that your application can handle.
The behavior with default values of _family_ , _type_ , _proto_ and _flags_ is system-specific.
Many systems (for example, most Linux configurations) will return a sorted list of all matching addresses. These addresses should generally be tried in order until a connection succeeds (possibly tried in parallel, for example, using a [Happy Eyeballs](https://en.wikipedia.org/wiki/Happy_Eyeballs) algorithm). In these cases, limiting the _type_ and/or _proto_ can help eliminate unsuccessful or unusable connection attempts.
Some systems will, however, only return a single address. (For example, this was reported on Solaris and AIX configurations.) On these systems, limiting the _type_ and/or _proto_ helps ensure that this address is usable.
Raises an [auditing event](https://docs.python.org/3/library/sys.html#auditing) `socket.getaddrinfo` with arguments `host`, `port`, `family`, `type`, `protocol`.
The following example fetches address information for a hypothetical TCP connection to `example.org` on port 80 (results may differ on your system if IPv6 isn’t enabled):
>>>```
>>> socket.getaddrinfo("example.org", 80, proto=socket.IPPROTO_TCP)
[(socket.AF_INET6, socket.SOCK_STREAM,
 6, '', ('2606:2800:220:1:248:1893:25c8:1946', 80, 0, 0)),
 (socket.AF_INET, socket.SOCK_STREAM,
 6, '', ('93.184.216.34', 80))]