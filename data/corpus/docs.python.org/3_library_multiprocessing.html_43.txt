Title: Multiprocessing Example with Pool in Python
URL: https://docs.python.org/3/library/multiprocessing.html
Summary: This section demonstrates the usage of the multiprocessing module in Python. It includes the definition of various functions for mathematical operations and a test function that creates a pool of processes to execute tasks concurrently. The tasks involve executing multiplication and addition operations with random sleep delays to simulate workload, showcasing the use of apply_async and imap methods for retrieving results.
---

```
importmultiprocessing
importtime
importrandom
importsys
#
# Functions used by test code
#
defcalculate(func, args):
  result = func(*args)
  return '%s says that %s%s = %s' % (
    multiprocessing.current_process().name,
    func.__name__, args, result
    )
defcalculatestar(args):
  return calculate(*args)
defmul(a, b):
  time.sleep(0.5 * random.random())
  return a * b
defplus(a, b):
  time.sleep(0.5 * random.random())
  return a + b
deff(x):
  return 1.0 / (x - 5.0)
defpow3(x):
  return x ** 3
defnoop(x):
  pass
#
# Test code
#
deftest():
  PROCESSES = 4
  print('Creating pool with %d processes\n' % PROCESSES)
  with multiprocessing.Pool(PROCESSES) as pool:
    #
    # Tests
    #
    TASKS = [(mul, (i, 7)) for i in range(10)] + \
        [(plus, (i, 8)) for i in range(10)]
    results = [pool.apply_async(calculate, t) for t in TASKS]
    imap_it = pool.imap(calculatestar, TASKS)
    imap_unordered_it = pool.imap_unordered(calculatestar, TASKS)
    print('Ordered results using pool.apply_async():')
    for r in results:
      print('\t', r.get())
    print()
    print('Ordered results using pool.imap():')
    for x in imap_it:
      print('\t', x)
    print()
    print('Unordered results using pool.imap_unordered():')
    for x in imap_unordered_it:
      print('\t', x)
    print()
    print('Ordered results using pool.map() --- will block till complete:')
    for x in pool.map(calculatestar, TASKS):
      print('\t', x)
    print()
    #
    # Test error handling
    #
    print('Testing error handling:')
    try:
      print(pool.apply(f, (5,)))
    except ZeroDivisionError:
      print('\tGot ZeroDivisionError as expected from pool.apply()')
    else:
      raise AssertionError('expected ZeroDivisionError')
    try:
      print(pool.map(f, list(range(10))))
    except ZeroDivisionError:
      print('\tGot ZeroDivisionError as expected from pool.map()')
    else:
      raise AssertionError('expected ZeroDivisionError')
    try:
      print(list(pool.imap(f, list(range(10)))))
    except ZeroDivisionError:
      print('\tGot ZeroDivisionError as expected from list(pool.imap())')
    else:
      raise AssertionError('expected ZeroDivisionError')
    it = pool.imap(f, list(range(10)))
    for i in range(10):
      try:
        x = next(it)
      except ZeroDivisionError:
        if i == 5:
          pass
      except StopIteration:
        break
      else:
        if i == 5:
          raise AssertionError('expected ZeroDivisionError')
    assert i == 9
    print('\tGot ZeroDivisionError as expected from IMapIterator.next()')
    print()
    #
    # Testing timeouts
    #
    print('Testing ApplyResult.get() with timeout:', end=' ')
    res = pool.apply_async(calculate, TASKS[0])
    while 1:
      sys.stdout.flush()
      try:
        sys.stdout.write('\n\t%s' % res.get(0.02))
        break
      except multiprocessing.TimeoutError:
        sys.stdout.write('.')
    print()
    print()
    print('Testing IMapIterator.next() with timeout:', end=' ')
    it = pool.imap(calculatestar, TASKS)
    while 1:
      sys.stdout.flush()
      try:
        sys.stdout.write('\n\t%s' % it.next(0.02))
      except StopIteration:
        break
      except multiprocessing.TimeoutError:
        sys.stdout.write('.')
    print()
    print()

if __name__ == '__main__':
  multiprocessing.freeze_support()
  test()

```

An example showing how to use queues to feed tasks to a collection of worker processes and collect the results:
```
importtime
importrandom
frommultiprocessingimport Process, Queue, current_process, freeze_support
#
# Function run by worker processes
#
defworker(input, output):
  for func, args in iter(input.get, 'STOP'):
    result = calculate(func, args)
    output.put(result)
#
# Function used to calculate result
#
defcalculate(func, args):
  result = func(*args)
  return '%s says that %s%s = %s' % \
    (current_process().name, func.__name__, args, result)
#
# Functions referenced by tasks
#
defmul(a, b):
  time.sleep(0.5*random.random())
  return a * b
defplus(a, b):
  time.sleep(0.5*random.random())
  return a + b
#
#
#
deftest():
  NUMBER_OF_PROCESSES = 4
  TASKS1 = [(mul, (i, 7)) for i in range(20)]
  TASKS2 = [(plus, (i, 8)) for i in range(10)]
  # Create queues
  task_queue = Queue()
  done_queue = Queue()
  # Submit tasks
  for task in TASKS1:
    task_queue.put(task)
  # Start worker processes
  for i in range(NUMBER_OF_PROCESSES):
    Process(target=worker, args=(task_queue, done_queue)).start()
  # Get and print results
  print('Unordered results:')
  for i in range(len(TASKS1)):
    print('\t', done_queue.get())
  # Add more tasks using `put()`
  for task in TASKS2:
    task_queue.put(task)
  # Get and print some more results
  for i in range(len(TASKS2)):
    print('\t', done_queue.get())
  # Tell child processes to stop
  for i in range(NUMBER_OF_PROCESSES):
    task_queue.put('STOP')

if __name__ == '__main__':
  freeze_support()
  test()