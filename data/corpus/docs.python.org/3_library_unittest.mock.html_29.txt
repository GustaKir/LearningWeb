Title: Using vars and dir with Mock Objects
URL: https://docs.python.org/3/library/unittest.mock.html
Summary: This section explains how to use `vars(my_mock)` and `dir(type(my_mock))` to access instance and type members of mock objects in Python's unittest.mock module, bypassing the filtering set by FILTER_DIR. It also introduces `unittest.mock.mock_open`, a helper function for creating a mock to replace the use of `open()`, whether called directly or as a context manager.
---

```

Alternatively you can just use `vars(my_mock)` (instance members) and `dir(type(my_mock))` (type members) to bypass the filtering irrespective of [`FILTER_DIR`](https://docs.python.org/3/library/unittest.mock.html#unittest.mock.FILTER_DIR "unittest.mock.FILTER_DIR").
### mock_open[Â¶](https://docs.python.org/3/library/unittest.mock.html#mock-open "Link to this heading") 

unittest.mock.mock_open(_mock =None_, _read_data =None_)[Â¶](https://docs.python.org/3/library/unittest.mock.html#unittest.mock.mock_open "Link to this definition")
    
A helper function to create a mock to replace the use of [`open()`](https://docs.python.org/3/library/functions.html#open "open"). It works for [`open()`](https://docs.python.org/3/library/functions.html#open "open") called directly or used as a context manager.
The _mock_ argument is the mock object to configure. If `None` (the default) then a [`MagicMock`](https://docs.python.org/3/library/unittest.mock.html#unittest.mock.MagicMock "unittest.mock.MagicMock") will be created for you, with the API limited to methods or attributes available on standard file handles.
_read_data_ is a string for the [`read()`](https://docs.python.org/3/library/io.html#io.RawIOBase.read "io.RawIOBase.read"), [`readline()`](https://docs.python.org/3/library/io.html#io.IOBase.readline "io.IOBase.readline"), and [`readlines()`](https://docs.python.org/3/library/io.html#io.IOBase.readlines "io.IOBase.readlines") methods of the file handle to return. Calls to those methods will take data from _read_data_ until it is depleted. The mock of these methods is pretty simplistic: every time the _mock_ is called, the _read_data_ is rewound to the start. If you need more control over the data that you are feeding to the tested code you will need to customize this mock for yourself. When that is insufficient, one of the in-memory filesystem packages on [PyPI](https://pypi.org) can offer a realistic filesystem for testing.
Changed in version 3.4: Added [`readline()`](https://docs.python.org/3/library/io.html#io.IOBase.readline "io.IOBase.readline") and [`readlines()`](https://docs.python.org/3/library/io.html#io.IOBase.readlines "io.IOBase.readlines") support. The mock of [`read()`](https://docs.python.org/3/library/io.html#io.RawIOBase.read "io.RawIOBase.read") changed to consume _read_data_ rather than returning it on each call.
Changed in version 3.5: _read_data_ is now reset on each call to the _mock_.
Changed in version 3.8: Added [`__iter__()`](https://docs.python.org/3/library/stdtypes.html#container.__iter__ "container.__iter__") to implementation so that iteration (such as in for loops) correctly consumes _read_data_.
Using [`open()`](https://docs.python.org/3/library/functions.html#open "open") as a context manager is a great way to ensure your file handles are closed properly and is becoming common:
```
with open('/some/path', 'w') as f:
  f.write('something')

```

The issue is that even if you mock out the call to [`open()`](https://docs.python.org/3/library/functions.html#open "open") it is the _returned object_ that is used as a context manager (and has [`__enter__()`](https://docs.python.org/3/reference/datamodel.html#object.__enter__ "object.__enter__") and [`__exit__()`](https://docs.python.org/3/reference/datamodel.html#object.__exit__ "object.__exit__") called).
Mocking context managers with a [`MagicMock`](https://docs.python.org/3/library/unittest.mock.html#unittest.mock.MagicMock "unittest.mock.MagicMock") is common enough and fiddly enough that a helper function is useful.
>>>```
>>> m = mock_open()
>>> with patch('__main__.open', m):
...   with open('foo', 'w') as h:
...     h.write('some stuff')
...
>>> m.mock_calls
[call('foo', 'w'),
 call().__enter__(),
 call().write('some stuff'),
 call().__exit__(None, None, None)]
>>> m.assert_called_once_with('foo', 'w')
>>> handle = m()
>>> handle.write.assert_called_once_with('some stuff')

```

And for reading files:
>>>```
>>> with patch('__main__.open', mock_open(read_data='bibble')) as m:
...   with open('foo') as h:
...     result = h.read()
...
>>> m.assert_called_once_with('foo')
>>> assert result == 'bibble'