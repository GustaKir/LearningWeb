Title: Using ThreadPoolExecutor for Concurrent URL Fetching
URL: https://docs.python.org/3/library/concurrent.futures.html
Summary: This code snippet demonstrates how to use Python's ThreadPoolExecutor to concurrently retrieve web pages. It defines a function to load a URL with a timeout, then utilizes the ThreadPoolExecutor to manage multiple threads, collecting results and handling exceptions as they complete.
---

```
importconcurrent.futures
importurllib.request
URLS = ['http://www.foxnews.com/',
    'http://www.cnn.com/',
    'http://europe.wsj.com/',
    'http://www.bbc.co.uk/',
    'http://nonexistent-subdomain.python.org/']
# Retrieve a single page and report the URL and contents
defload_url(url, timeout):
  with urllib.request.urlopen(url, timeout=timeout) as conn:
    return conn.read()
# We can use a with statement to ensure threads are cleaned up promptly
with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
  # Start the load operations and mark each future with its URL
  future_to_url = {executor.submit(load_url, url, 60): url for url in URLS}
  for future in concurrent.futures.as_completed(future_to_url):
    url = future_to_url[future]
    try:
      data = future.result()
    except Exception as exc:
      print('%r generated an exception: %s' % (url, exc))
    else:
      print('%r page is %d bytes' % (url, len(data)))

```

## ProcessPoolExecutor[Â¶](https://docs.python.org/3/library/concurrent.futures.html#processpoolexecutor "Link to this heading")
The [`ProcessPoolExecutor`](https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor "concurrent.futures.ProcessPoolExecutor") class is an [`Executor`](https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor "concurrent.futures.Executor") subclass that uses a pool of processes to execute calls asynchronously. [`ProcessPoolExecutor`](https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor "concurrent.futures.ProcessPoolExecutor") uses the [`multiprocessing`](https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing "multiprocessing: Process-based parallelism.") module, which allows it to side-step the [Global Interpreter Lock](https://docs.python.org/3/glossary.html#term-global-interpreter-lock) but also means that only picklable objects can be executed and returned.
The `__main__` module must be importable by worker subprocesses. This means that [`ProcessPoolExecutor`](https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor "concurrent.futures.ProcessPoolExecutor") will not work in the interactive interpreter.
Calling [`Executor`](https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor "concurrent.futures.Executor") or [`Future`](https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Future "concurrent.futures.Future") methods from a callable submitted to a [`ProcessPoolExecutor`](https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor "concurrent.futures.ProcessPoolExecutor") will result in deadlock.