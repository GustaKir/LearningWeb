Title: Typing Module: Annotated and TypeIs
URL: https://docs.python.org/3/library/typing.html
Summary: The content explains the `get_origin()` function from the typing module, which returns the `Annotated` type itself, introduced in Python 3.9 as per PEP 593. It also introduces `typing.TypeIs`, a construct for user-defined type predicate functions, and how it helps in type narrowing for static type checkers.
---

```

Note that using [`get_origin()`](https://docs.python.org/3/library/typing.html#typing.get_origin "typing.get_origin") will return `Annotated` itself:
> >>>```
>>> get_origin(Password)
typing.Annotated

```

See also 

[**PEP 593**](https://peps.python.org/pep-0593/) - Flexible function and variable annotations
    
The PEP introducing `Annotated` to the standard library.
Added in version 3.9. 

typing.TypeIs[¶](https://docs.python.org/3/library/typing.html#typing.TypeIs "Link to this definition")
    
Special typing construct for marking user-defined type predicate functions.
`TypeIs` can be used to annotate the return type of a user-defined type predicate function. `TypeIs` only accepts a single type argument. At runtime, functions marked this way should return a boolean and take at least one positional argument.
`TypeIs` aims to benefit _type narrowing_ – a technique used by static type checkers to determine a more precise type of an expression within a program’s code flow. Usually type narrowing is done by analyzing conditional code flow and applying the narrowing to a block of code. The conditional expression here is sometimes referred to as a “type predicate”:
```
defis_str(val: str | float):
  # "isinstance" type predicate
  if isinstance(val, str):
    # Type of ``val`` is narrowed to ``str``
    ...
  else:
    # Else, type of ``val`` is narrowed to ``float``.
    ...

```

Sometimes it would be convenient to use a user-defined boolean function as a type predicate. Such a function should use `TypeIs[...]` or [`TypeGuard`](https://docs.python.org/3/library/typing.html#typing.TypeGuard "typing.TypeGuard") as its return type to alert static type checkers to this intention. `TypeIs` usually has more intuitive behavior than `TypeGuard`, but it cannot be used when the input and output types are incompatible (e.g., `list[object]` to `list[int]`) or when the function does not return `True` for all instances of the narrowed type.
Using `-> TypeIs[NarrowedType]` tells the static type checker that for a given function:
  1. The return value is a boolean.
  2. If the return value is `True`, the type of its argument is the intersection of the argument’s original type and `NarrowedType`.
  3. If the return value is `False`, the type of its argument is narrowed to exclude `NarrowedType`.


For example:
```
fromtypingimport assert_type, final, TypeIs
classParent: pass
classChild(Parent): pass
@final
classUnrelated: pass
defis_parent(val: object) -> TypeIs[Parent]:
  return isinstance(val, Parent)
defrun(arg: Child | Unrelated):
  if is_parent(arg):
    # Type of ``arg`` is narrowed to the intersection
    # of ``Parent`` and ``Child``, which is equivalent to
    # ``Child``.
    assert_type(arg, Child)
  else:
    # Type of ``arg`` is narrowed to exclude ``Parent``,
    # so only ``Unrelated`` is left.
    assert_type(arg, Unrelated)

```

The type inside `TypeIs` must be consistent with the type of the function’s argument; if it is not, static type checkers will raise an error. An incorrectly written `TypeIs` function can lead to unsound behavior in the type system; it is the user’s responsibility to write such functions in a type-safe manner.
If a `TypeIs` function is a class or instance method, then the type in `TypeIs` maps to the type of the second parameter (after `cls` or `self`).
In short, the form `def foo(arg: TypeA) -> TypeIs[TypeB]: ...`, means that if `foo(arg)` returns `True`, then `arg` is an instance of `TypeB`, and if it returns `False`, it is not an instance of `TypeB`.
`TypeIs` also works with type variables. For more information, see [**PEP 742**](https://peps.python.org/pep-0742/) (Narrowing types with `TypeIs`).
Added in version 3.13. 

typing.TypeGuard[¶](https://docs.python.org/3/library/typing.html#typing.TypeGuard "Link to this definition")
    
Special typing construct for marking user-defined type predicate functions.
Type predicate functions are user-defined functions that return whether their argument is an instance of a particular type. `TypeGuard` works similarly to [`TypeIs`](https://docs.python.org/3/library/typing.html#typing.TypeIs "typing.TypeIs"), but has subtly different effects on type checking behavior (see below).
Using `-> TypeGuard` tells the static type checker that for a given function:
  1. The return value is a boolean.
  2. If the return value is `True`, the type of its argument is the type inside `TypeGuard`.


`TypeGuard` also works with type variables. See [**PEP 647**](https://peps.python.org/pep-0647/) for more details.
For example:
```
defis_str_list(val: list[object]) -> TypeGuard[list[str]]:
'''Determines whether all objects in the list are strings'''
  return all(isinstance(x, str) for x in val)
deffunc1(val: list[object]):
  if is_str_list(val):
    # Type of ``val`` is narrowed to ``list[str]``.
    print(" ".join(val))
  else:
    # Type of ``val`` remains as ``list[object]``.
    print("Not a list of strings!")