Title: Memoization in Python Functions
URL: https://docs.python.org/3/faq/programming.html
Summary: This section discusses the memoization technique in Python, which caches function parameters and results to optimize performance for time-consuming computations. An example code illustrates how to implement memoization using a default dictionary for caching results.
---

```

This feature can be useful. When you have a function that’s time-consuming to compute, a common technique is to cache the parameters and the resulting value of each call to the function, and return the cached value if the same value is requested again. This is called “memoizing”, and can be implemented like this:
```
# Callers can only provide two parameters and optionally pass _cache by keyword
defexpensive(arg1, arg2, *, _cache={}):
  if (arg1, arg2) in _cache:
    return _cache[(arg1, arg2)]
  # Calculate the value
  result = ... expensive computation ...
  _cache[(arg1, arg2)] = result      # Store result in the cache
  return result

```

You could use a global variable containing a dictionary instead of the default value; it’s a matter of taste.
### [How can I pass optional or keyword parameters from one function to another?](https://docs.python.org/3/faq/programming.html#id15)[¶](https://docs.python.org/3/faq/programming.html#how-can-i-pass-optional-or-keyword-parameters-from-one-function-to-another "Link to this heading")
Collect the arguments using the `*` and `**` specifiers in the function’s parameter list; this gives you the positional arguments as a tuple and the keyword arguments as a dictionary. You can then pass these arguments when calling another function by using `*` and `**`:
```
deff(x, *args, **kwargs):
  ...
  kwargs['width'] = '14.3c'
  ...
  g(x, *args, **kwargs)

```

### [What is the difference between arguments and parameters?](https://docs.python.org/3/faq/programming.html#id16)[¶](https://docs.python.org/3/faq/programming.html#what-is-the-difference-between-arguments-and-parameters "Link to this heading")
[Parameters](https://docs.python.org/3/glossary.html#term-parameter) are defined by the names that appear in a function definition, whereas [arguments](https://docs.python.org/3/glossary.html#term-argument) are the values actually passed to a function when calling it. Parameters define what [kind of arguments](https://docs.python.org/3/glossary.html#term-parameter) a function can accept. For example, given the function definition:
```
deffunc(foo, bar=None, **kwargs):
  pass

```

_foo_ , _bar_ and _kwargs_ are parameters of `func`. However, when calling `func`, for example:
```
func(42, bar=314, extra=somevar)

```

the values `42`, `314`, and `somevar` are arguments.
### [Why did changing list ‘y’ also change list ‘x’?](https://docs.python.org/3/faq/programming.html#id17)[¶](https://docs.python.org/3/faq/programming.html#why-did-changing-list-y-also-change-list-x "Link to this heading")
If you wrote code like:
>>>```
>>> x = []
>>> y = x
>>> y.append(10)
>>> y
[10]
>>> x
[10]

```

you might be wondering why appending an element to `y` changed `x` too.
There are two factors that produce this result:
  1. Variables are simply names that refer to objects. Doing `y = x` doesn’t create a copy of the list – it creates a new variable `y` that refers to the same object `x` refers to. This means that there is only one object (the list), and both `x` and `y` refer to it.
  2. Lists are [mutable](https://docs.python.org/3/glossary.html#term-mutable), which means that you can change their content.


After the call to `append()`, the content of the mutable object has changed from `[]` to `[10]`. Since both the variables refer to the same object, using either name accesses the modified value `[10]`.
If we instead assign an immutable object to `x`:
>>>```
>>> x = 5 # ints are immutable
>>> y = x
>>> x = x + 1 # 5 can't be mutated, we are creating a new object here
>>> x
6
>>> y
5