Title: Using Persistent IDs to Pickle External Objects in Python
URL: https://docs.python.org/3/library/pickle.html
Summary: This example demonstrates how to use persistent IDs with the pickle module to serialize external objects by reference, specifically showing how a custom Pickler and Unpickler can be implemented for a database record class, MemoRecord, to handle its serialization efficiently.
---

```
# Simple example presenting how persistent ID can be used to pickle
# external objects by reference.
importpickle
importsqlite3
fromcollectionsimport namedtuple
# Simple class representing a record in our database.
MemoRecord = namedtuple("MemoRecord", "key, task")
classDBPickler(pickle.Pickler):
  defpersistent_id(self, obj):
    # Instead of pickling MemoRecord as a regular class instance, we emit a
    # persistent ID.
    if isinstance(obj, MemoRecord):
      # Here, our persistent ID is simply a tuple, containing a tag and a
      # key, which refers to a specific record in the database.
      return ("MemoRecord", obj.key)
    else:
      # If obj does not have a persistent ID, return None. This means obj
      # needs to be pickled as usual.
      return None

classDBUnpickler(pickle.Unpickler):
  def__init__(self, file, connection):
    super().__init__(file)
    self.connection = connection
  defpersistent_load(self, pid):
    # This method is invoked whenever a persistent ID is encountered.
    # Here, pid is the tuple returned by DBPickler.
    cursor = self.connection.cursor()
    type_tag, key_id = pid
    if type_tag == "MemoRecord":
      # Fetch the referenced record from the database and return it.
      cursor.execute("SELECT * FROM memos WHERE key=?", (str(key_id),))
      key, task = cursor.fetchone()
      return MemoRecord(key, task)
    else:
      # Always raises an error if you cannot return the correct object.
      # Otherwise, the unpickler will think None is the object referenced
      # by the persistent ID.
      raise pickle.UnpicklingError("unsupported persistent object")

defmain():
  importio
  importpprint
  # Initialize and populate our database.
  conn = sqlite3.connect(":memory:")
  cursor = conn.cursor()
  cursor.execute("CREATE TABLE memos(key INTEGER PRIMARY KEY, task TEXT)")
  tasks = (
    'give food to fish',
    'prepare group meeting',
    'fight with a zebra',
    )
  for task in tasks:
    cursor.execute("INSERT INTO memos VALUES(NULL, ?)", (task,))
  # Fetch the records to be pickled.
  cursor.execute("SELECT * FROM memos")
  memos = [MemoRecord(key, task) for key, task in cursor]
  # Save the records using our custom DBPickler.
  file = io.BytesIO()
  DBPickler(file).dump(memos)
  print("Pickled records:")
  pprint.pprint(memos)
  # Update a record, just for good measure.
  cursor.execute("UPDATE memos SET task='learn italian' WHERE key=1")
  # Load the records from the pickle data stream.
  file.seek(0)
  memos = DBUnpickler(file, conn).load()
  print("Unpickled records:")
  pprint.pprint(memos)

if __name__ == '__main__':
  main()

```

### Dispatch Tables[¶](https://docs.python.org/3/library/pickle.html#dispatch-tables "Link to this heading")
If one wants to customize pickling of some classes without disturbing any other code which depends on pickling, then one can create a pickler with a private dispatch table.
The global dispatch table managed by the [`copyreg`](https://docs.python.org/3/library/copyreg.html#module-copyreg "copyreg: Register pickle support functions.") module is available as `copyreg.dispatch_table`. Therefore, one may choose to use a modified copy of `copyreg.dispatch_table` as a private dispatch table.
For example
```
f = io.BytesIO()
p = pickle.Pickler(f)
p.dispatch_table = copyreg.dispatch_table.copy()
p.dispatch_table[SomeClass] = reduce_SomeClass

```

creates an instance of [`pickle.Pickler`](https://docs.python.org/3/library/pickle.html#pickle.Pickler "pickle.Pickler") with a private dispatch table which handles the `SomeClass` class specially. Alternatively, the code
```
classMyPickler(pickle.Pickler):
  dispatch_table = copyreg.dispatch_table.copy()
  dispatch_table[SomeClass] = reduce_SomeClass
f = io.BytesIO()
p = MyPickler(f)

```

does the same but all instances of `MyPickler` will by default share the private dispatch table. On the other hand, the code
```
copyreg.pickle(SomeClass, reduce_SomeClass)
f = io.BytesIO()
p = pickle.Pickler(f)

```

modifies the global dispatch table shared by all users of the [`copyreg`](https://docs.python.org/3/library/copyreg.html#module-copyreg "copyreg: Register pickle support functions.") module.
### Handling Stateful Objects[¶](https://docs.python.org/3/library/pickle.html#handling-stateful-objects "Link to this heading")
Here’s an example that shows how to modify pickling behavior for a class. The `TextReader` class below opens a text file, and returns the line number and line contents each time its `readline()` method is called. If a `TextReader` instance is pickled, all attributes _except_ the file object member are saved. When the instance is unpickled, the file is reopened, and reading resumes from the last location. The `__setstate__()` and `__getstate__()` methods are used to implement this behavior.