Title: bytearray Methods Overview
URL: https://docs.python.org/3/library/stdtypes.html
Summary: This section details the `bytearray.rindex()` method, which functions similarly to `rfind()` but raises a `ValueError` if the specified subsequence is not found. It also notes that starting from version 3.3, integers in the range of 0 to 255 can be accepted as subsequences. Additionally, the `bytes.rpartition()` and `bytearray.rpartition()` methods are introduced, which split the sequence at the last occurrence of a specified separator and return a tuple containing parts of the sequence.
---

bytearray.rindex(_sub_[, _start_[, _end_]])[¶](https://docs.python.org/3/library/stdtypes.html#bytearray.rindex "Link to this definition")
    
Like [`rfind()`](https://docs.python.org/3/library/stdtypes.html#bytes.rfind "bytes.rfind") but raises [`ValueError`](https://docs.python.org/3/library/exceptions.html#ValueError "ValueError") when the subsequence _sub_ is not found.
The subsequence to search for may be any [bytes-like object](https://docs.python.org/3/glossary.html#term-bytes-like-object) or an integer in the range 0 to 255.
Changed in version 3.3: Also accept an integer in the range 0 to 255 as the subsequence. 

bytes.rpartition(_sep_)[¶](https://docs.python.org/3/library/stdtypes.html#bytes.rpartition "Link to this definition")


bytearray.rpartition(_sep_)[¶](https://docs.python.org/3/library/stdtypes.html#bytearray.rpartition "Link to this definition")
    
Split the sequence at the last occurrence of _sep_ , and return a 3-tuple containing the part before the separator, the separator itself or its bytearray copy, and the part after the separator. If the separator is not found, return a 3-tuple containing two empty bytes or bytearray objects, followed by a copy of the original sequence.
The separator to search for may be any [bytes-like object](https://docs.python.org/3/glossary.html#term-bytes-like-object). 

bytes.startswith(_prefix_[, _start_[, _end_]])[¶](https://docs.python.org/3/library/stdtypes.html#bytes.startswith "Link to this definition")


bytearray.startswith(_prefix_[, _start_[, _end_]])[¶](https://docs.python.org/3/library/stdtypes.html#bytearray.startswith "Link to this definition")
    
Return `True` if the binary data starts with the specified _prefix_ , otherwise return `False`. _prefix_ can also be a tuple of prefixes to look for. With optional _start_ , test beginning at that position. With optional _end_ , stop comparing at that position.
The prefix(es) to search for may be any [bytes-like object](https://docs.python.org/3/glossary.html#term-bytes-like-object). 

bytes.translate(_table_ , _/_ , _delete =b''_)[¶](https://docs.python.org/3/library/stdtypes.html#bytes.translate "Link to this definition")


bytearray.translate(_table_ , _/_ , _delete =b''_)[¶](https://docs.python.org/3/library/stdtypes.html#bytearray.translate "Link to this definition")
    
Return a copy of the bytes or bytearray object where all bytes occurring in the optional argument _delete_ are removed, and the remaining bytes have been mapped through the given translation table, which must be a bytes object of length 256.
You can use the [`bytes.maketrans()`](https://docs.python.org/3/library/stdtypes.html#bytes.maketrans "bytes.maketrans") method to create a translation table.
Set the _table_ argument to `None` for translations that only delete characters:
>>>```
>>> b'read this short text'.translate(None, b'aeiou')
b'rd ths shrt txt'