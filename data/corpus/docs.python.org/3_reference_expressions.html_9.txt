Title: Asynchronous Generator Functions in Python
URL: https://docs.python.org/3/reference/expressions.html
Summary: This section discusses asynchronous generator functions defined using 'async def', which include a yield expression. When called, these functions return an asynchronous generator object, utilized within 'async for' statements in coroutine functions.
---

```

For examples using `yield from`, see [PEP 380: Syntax for Delegating to a Subgenerator](https://docs.python.org/3/whatsnew/3.3.html#pep-380) in “What’s New in Python.”
#### 6.2.9.3. Asynchronous generator functions[¶](https://docs.python.org/3/reference/expressions.html#asynchronous-generator-functions "Link to this heading")
The presence of a yield expression in a function or method defined using [`async def`](https://docs.python.org/3/reference/compound_stmts.html#async-def) further defines the function as an [asynchronous generator](https://docs.python.org/3/glossary.html#term-asynchronous-generator) function.
When an asynchronous generator function is called, it returns an asynchronous iterator known as an asynchronous generator object. That object then controls the execution of the generator function. An asynchronous generator object is typically used in an [`async for`](https://docs.python.org/3/reference/compound_stmts.html#async-for) statement in a coroutine function analogously to how a generator object would be used in a [`for`](https://docs.python.org/3/reference/compound_stmts.html#for) statement.
Calling one of the asynchronous generator’s methods returns an [awaitable](https://docs.python.org/3/glossary.html#term-awaitable) object, and the execution starts when this object is awaited on. At that time, the execution proceeds to the first yield expression, where it is suspended again, returning the value of [`yield_list`](https://docs.python.org/3/reference/expressions.html#grammar-token-python-grammar-yield_list) to the awaiting coroutine. As with a generator, suspension means that all local state is retained, including the current bindings of local variables, the instruction pointer, the internal evaluation stack, and the state of any exception handling. When the execution is resumed by awaiting on the next object returned by the asynchronous generator’s methods, the function can proceed exactly as if the yield expression were just another external call. The value of the yield expression after resuming depends on the method which resumed the execution. If [`__anext__()`](https://docs.python.org/3/reference/expressions.html#agen.__anext__ "agen.__anext__") is used then the result is [`None`](https://docs.python.org/3/library/constants.html#None "None"). Otherwise, if [`asend()`](https://docs.python.org/3/reference/expressions.html#agen.asend "agen.asend") is used, then the result will be the value passed in to that method.
If an asynchronous generator happens to exit early by [`break`](https://docs.python.org/3/reference/simple_stmts.html#break), the caller task being cancelled, or other exceptions, the generator’s async cleanup code will run and possibly raise exceptions or access context variables in an unexpected context–perhaps after the lifetime of tasks it depends, or during the event loop shutdown when the async-generator garbage collection hook is called. To prevent this, the caller must explicitly close the async generator by calling [`aclose()`](https://docs.python.org/3/reference/expressions.html#agen.aclose "agen.aclose") method to finalize the generator and ultimately detach it from the event loop.
In an asynchronous generator function, yield expressions are allowed anywhere in a [`try`](https://docs.python.org/3/reference/compound_stmts.html#try) construct. However, if an asynchronous generator is not resumed before it is finalized (by reaching a zero reference count or by being garbage collected), then a yield expression within a `try` construct could result in a failure to execute pending [`finally`](https://docs.python.org/3/reference/compound_stmts.html#finally) clauses. In this case, it is the responsibility of the event loop or scheduler running the asynchronous generator to call the asynchronous generator-iterator’s [`aclose()`](https://docs.python.org/3/reference/expressions.html#agen.aclose "agen.aclose") method and run the resulting coroutine object, thus allowing any pending `finally` clauses to execute.
To take care of finalization upon event loop termination, an event loop should define a _finalizer_ function which takes an asynchronous generator-iterator and presumably calls [`aclose()`](https://docs.python.org/3/reference/expressions.html#agen.aclose "agen.aclose") and executes the coroutine. This _finalizer_ may be registered by calling [`sys.set_asyncgen_hooks()`](https://docs.python.org/3/library/sys.html#sys.set_asyncgen_hooks "sys.set_asyncgen_hooks"). When first iterated over, an asynchronous generator-iterator will store the registered _finalizer_ to be called upon finalization. For a reference example of a _finalizer_ method see the implementation of `asyncio.Loop.shutdown_asyncgens` in [Lib/asyncio/base_events.py](https://github.com/python/cpython/tree/3.13/Lib/asyncio/base_events.py).
The expression `yield from <expr>` is a syntax error when used in an asynchronous generator function.
#### 6.2.9.4. Asynchronous generator-iterator methods[¶](https://do