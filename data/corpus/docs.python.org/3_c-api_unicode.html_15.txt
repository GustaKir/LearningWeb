Title: PyUnicode_DecodeUTF32 Function in Python C API
URL: https://docs.python.org/3/c-api/unicode.html
Summary: The `PyUnicode_DecodeUTF32` function decodes a UTF-32 encoded buffer and returns a Unicode object. It allows specifying error handling and byte order for decoding, including handling of byte order marks (BOM) when determining byte order.
---

[PyObject](https://docs.python.org/3/c-api/structures.html#c.PyObject "PyObject")*PyUnicode_DecodeUTF32(constchar*str, [Py_ssize_t](https://docs.python.org/3/c-api/intro.html#c.Py_ssize_t "Py_ssize_t")size, constchar*errors, int*byteorder)[¶](https://docs.python.org/3/c-api/unicode.html#c.PyUnicode_DecodeUTF32 "Link to this definition")
    _Return value: New reference.__Part of the[ Stable ABI](https://docs.python.org/3/c-api/stable.html#stable)._
Decode _size_ bytes from a UTF-32 encoded buffer string and return the corresponding Unicode object. _errors_ (if non-`NULL`) defines the error handling. It defaults to “strict”.
If _byteorder_ is non-`NULL`, the decoder starts decoding using the given byte order:
```
*byteorder==-1:littleendian
*byteorder==0:nativeorder
*byteorder==1:bigendian

```

If `*byteorder` is zero, and the first four bytes of the input data are a byte order mark (BOM), the decoder switches to this byte order and the BOM is not copied into the resulting Unicode string. If `*byteorder` is `-1` or `1`, any byte order mark is copied to the output.
After completion, _*byteorder_ is set to the current byte order at the end of input data.
If _byteorder_ is `NULL`, the codec starts in native order mode.
Return `NULL` if an exception was raised by the codec. 

[PyObject](https://docs.python.org/3/c-api/structures.html#c.PyObject "PyObject")*PyUnicode_DecodeUTF32Stateful(constchar*str, [Py_ssize_t](https://docs.python.org/3/c-api/intro.html#c.Py_ssize_t "Py_ssize_t")size, constchar*errors, int*byteorder, [Py_ssize_t](https://docs.python.org/3/c-api/intro.html#c.Py_ssize_t "Py_ssize_t")*consumed)[¶](https://docs.python.org/3/c-api/unicode.html#c.PyUnicode_DecodeUTF32Stateful "Link to this definition")
    _Return value: New reference.__Part of the[ Stable ABI](https://docs.python.org/3/c-api/stable.html#stable)._
If _consumed_ is `NULL`, behave like [`PyUnicode_DecodeUTF32()`](https://docs.python.org/3/c-api/unicode.html#c.PyUnicode_DecodeUTF32 "PyUnicode_DecodeUTF32"). If _consumed_ is not `NULL`, [`PyUnicode_DecodeUTF32Stateful()`](https://docs.python.org/3/c-api/unicode.html#c.PyUnicode_DecodeUTF32Stateful "PyUnicode_DecodeUTF32Stateful") will not treat trailing incomplete UTF-32 byte sequences (such as a number of bytes not divisible by four) as an error. Those bytes will not be decoded and the number of bytes that have been decoded will be stored in _consumed_. 

[PyObject](https://docs.python.org/3/c-api/structures.html#c.PyObject "PyObject")*PyUnicode_AsUTF32String([PyObject](https://docs.python.org/3/c-api/structures.html#c.PyObject "PyObject")*unicode)[¶](https://docs.python.org/3/c-api/unicode.html#c.PyUnicode_AsUTF32String "Link to this definition")
    _Return value: New reference.__Part of the[ Stable ABI](https://docs.python.org/3/c-api/stable.html#stable)._
Return a Python byte string using the UTF-32 encoding in native byte order. The string always starts with a BOM mark. Error handling is “strict”. Return `NULL` if an exception was raised by the codec.
### UTF-16 Codecs[¶](https://docs.python.org/3/c-api/unicode.html#utf-16-codecs "Link to this heading")
These are the UTF-16 codec APIs: 

[PyObject](https://docs.python.org/3/c-api/structures.html#c.PyObject "PyObject")*PyUnicode_DecodeUTF16(constchar*str, [Py_ssize_t](https://docs.python.org/3/c-api/intro.html#c.Py_ssize_t "Py_ssize_t")size, constchar*errors, int*byteorder)[¶](https://docs.python.org/3/c-api/unicode.html#c.PyUnicode_DecodeUTF16 "Link to this definition")
    _Return value: New reference.__Part of the[ Stable ABI](https://docs.python.org/3/c-api/stable.html#stable)._
Decode _size_ bytes from a UTF-16 encoded buffer string and return the corresponding Unicode object. _errors_ (if non-`NULL`) defines the error handling. It defaults to “strict”.
If _byteorder_ is non-`NULL`, the decoder starts decoding using the given byte order:
```
*byteorder==-1:littleendian
*byteorder==0:nativeorder
*byteorder==1:bigendian