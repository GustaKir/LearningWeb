Title: Dictionary Displays and Comprehensions in Python
URL: https://docs.python.org/3/reference/expressions.html
Summary: This section explains how dictionary displays create new dictionary objects from comma-separated sequences of key-value pairs, detailing the overwrite behavior for duplicate keys. It introduces dictionary unpacking using the double asterisk `**`, which allows merging of mapping items into a new dictionary. The feature, added in Python 3.5 through PEP 448, enhances dictionary displays. Additionally, it notes that dict comprehensions require a specific syntax compared to list and set comprehensions.
---

```

A dictionary display yields a new dictionary object.
If a comma-separated sequence of dict items is given, they are evaluated from left to right to define the entries of the dictionary: each key object is used as a key into the dictionary to store the corresponding value. This means that you can specify the same key multiple times in the dict item list, and the final dictionary’s value for that key will be the last one given.
A double asterisk `**` denotes _dictionary unpacking_. Its operand must be a [mapping](https://docs.python.org/3/glossary.html#term-mapping). Each mapping item is added to the new dictionary. Later values replace values already set by earlier dict items and earlier dictionary unpackings.
Added in version 3.5: Unpacking into dictionary displays, originally proposed by [**PEP 448**](https://peps.python.org/pep-0448/).
A dict comprehension, in contrast to list and set comprehensions, needs two expressions separated with a colon followed by the usual “for” and “if” clauses. When the comprehension is run, the resulting key and value elements are inserted in the new dictionary in the order they are produced.
Restrictions on the types of the key values are listed earlier in section [The standard type hierarchy](https://docs.python.org/3/reference/datamodel.html#types). (To summarize, the key type should be [hashable](https://docs.python.org/3/glossary.html#term-hashable), which excludes all mutable objects.) Clashes between duplicate keys are not detected; the last value (textually rightmost in the display) stored for a given key value prevails.
Changed in version 3.8: Prior to Python 3.8, in dict comprehensions, the evaluation order of key and value was not well-defined. In CPython, the value was evaluated before the key. Starting with 3.8, the key is evaluated before the value, as proposed by [**PEP 572**](https://peps.python.org/pep-0572/).
### 6.2.8. Generator expressions[¶](https://docs.python.org/3/reference/expressions.html#generator-expressions "Link to this heading")
A generator expression is a compact generator notation in parentheses:
```
**generator_expression** ::= "(" [expression](https://docs.python.org/3/reference/expressions.html#grammar-token-python-grammar-expression) [comp_for](https://docs.python.org/3/reference/expressions.html#grammar-token-python-grammar-comp_for) ")"

```

A generator expression yields a new generator object. Its syntax is the same as for comprehensions, except that it is enclosed in parentheses instead of brackets or curly braces.
Variables used in the generator expression are evaluated lazily when the [`__next__()`](https://docs.python.org/3/reference/expressions.html#generator.__next__ "generator.__next__") method is called for the generator object (in the same fashion as normal generators). However, the iterable expression in the leftmost `for` clause is immediately evaluated, so that an error produced by it will be emitted at the point where the generator expression is defined, rather than at the point where the first value is retrieved. Subsequent `for` clauses and any filter condition in the leftmost `for` clause cannot be evaluated in the enclosing scope as they may depend on the values obtained from the leftmost iterable. For example: `(x*y for x in range(10) for y in range(x, x+10))`.
The parentheses can be omitted on calls with only one argument. See section [Calls](https://docs.python.org/3/reference/expressions.html#calls) for details.
To avoid interfering with the expected operation of the generator expression itself, `yield` and `yield from` expressions are prohibited in the implicitly defined generator.
If a generator expression contains either `async for` clauses or [`await`](https://docs.python.org/3/reference/expressions.html#await) expressions it is called an _asynchronous generator expression_. An asynchronous generator expression returns a new asynchronous generator object, which is an asynchronous iterator (see [Asynchronous Iterators](https://docs.python.org/3/reference/datamodel.html#async-iterators)).
Added in version 3.6: Asynchronous generator expressions were introduced.
Changed in version 3.7: Prior to Python 3.7, asynchronous generator expressions could only appear in [`async def`](https://docs.python.org/3/reference/compound_stmts.html#async-def) coroutines. Starting with 3.7, any function can use asynchronous generator expressions.
Changed in version 3.8: `yield` and `yield from` prohibited in the implicitly nested scope.
### 6.2.9. Yield expressions[¶](https://docs.python.org/3/reference/expressions.html#yield-expressions "Link to this heading")