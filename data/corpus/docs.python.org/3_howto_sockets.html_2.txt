Title: Understanding Socket Server Functionality
URL: https://docs.python.org/3/howto/sockets.html
Summary: This section explains the fundamental operations of a server socket, which generates client sockets in response to connection requests without sending or receiving data. It outlines three approaches to handle client sockets: using threads, creating processes, or employing non-blocking sockets with multiplexing. Attention is drawn to the importance of the server's role in facilitating communication between clients.
---

```

There’s actually 3 general ways in which this loop could work - dispatching a thread to handle `clientsocket`, create a new process to handle `clientsocket`, or restructure this app to use non-blocking sockets, and multiplex between our “server” socket and any active `clientsocket`s using `select`. More about that later. The important thing to understand now is this: this is _all_ a “server” socket does. It doesn’t send any data. It doesn’t receive any data. It just produces “client” sockets. Each `clientsocket` is created in response to some _other_ “client” socket doing a `connect()` to the host and port we’re bound to. As soon as we’ve created that `clientsocket`, we go back to listening for more connections. The two “clients” are free to chat it up - they are using some dynamically allocated port which will be recycled when the conversation ends.
### IPC[¶](https://docs.python.org/3/howto/sockets.html#ipc "Link to this heading")
If you need fast IPC between two processes on one machine, you should look into pipes or shared memory. If you do decide to use AF_INET sockets, bind the “server” socket to `'localhost'`. On most platforms, this will take a shortcut around a couple of layers of network code and be quite a bit faster.
See also
The [`multiprocessing`](https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing "multiprocessing: Process-based parallelism.") integrates cross-platform IPC into a higher-level API.
## Using a Socket[¶](https://docs.python.org/3/howto/sockets.html#using-a-socket "Link to this heading")
The first thing to note, is that the web browser’s “client” socket and the web server’s “client” socket are identical beasts. That is, this is a “peer to peer” conversation. Or to put it another way, _as the designer, you will have to decide what the rules of etiquette are for a conversation_. Normally, the `connect`ing socket starts the conversation, by sending in a request, or perhaps a signon. But that’s a design decision - it’s not a rule of sockets.
Now there are two sets of verbs to use for communication. You can use `send` and `recv`, or you can transform your client socket into a file-like beast and use `read` and `write`. The latter is the way Java presents its sockets. I’m not going to talk about it here, except to warn you that you need to use `flush` on sockets. These are buffered “files”, and a common mistake is to `write` something, and then `read` for a reply. Without a `flush` in there, you may wait forever for the reply, because the request may still be in your output buffer.
Now we come to the major stumbling block of sockets - `send` and `recv` operate on the network buffers. They do not necessarily handle all the bytes you hand them (or expect from them), because their major focus is handling the network buffers. In general, they return when the associated network buffers have been filled (`send`) or emptied (`recv`). They then tell you how many bytes they handled. It is _your_ responsibility to call them again until your message has been completely dealt with.
When a `recv` returns 0 bytes, it means the other side has closed (or is in the process of closing) the connection. You will not receive any more data on this connection. Ever. You may be able to send data successfully; I’ll talk more about this later.
A protocol like HTTP uses a socket for only one transfer. The client sends a request, then reads a reply. That’s it. The socket is discarded. This means that a client can detect the end of the reply by receiving 0 bytes.
But if you plan to reuse your socket for further transfers, you need to realize that _there is no_ EOT _on a socket._ I repeat: if a socket `send` or `recv` returns after handling 0 bytes, the connection has been broken. If the connection has _not_ been broken, you may wait on a `recv` forever, because the socket will _not_ tell you that there’s nothing more to read (for now). Now if you think about that a bit, you’ll come to realize a fundamental truth of sockets: _messages must either be fixed length_ (yuck), _or be delimited_ (shrug), _or indicate how long they are_ (much better), _or end by shutting down the connection_. The choice is entirely yours, (but some ways are righter than others).
Assuming you don’t want to end the connection, the simplest solution is a fixed length message: