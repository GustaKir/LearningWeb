Title: Creating Test Cases in unittest
URL: https://docs.python.org/3/library/unittest.html
Summary: To create a test case in Python's unittest framework, subclass `unittest.TestCase` and define test methods prefixed with 'test'. Use assertion methods like `assertEqual()`, `assertTrue()`, `assertFalse()`, and `assertRaises()` to verify expected outcomes and conditions.
---

```

A testcase is created by subclassing [`unittest.TestCase`](https://docs.python.org/3/library/unittest.html#unittest.TestCase "unittest.TestCase"). The three individual tests are defined with methods whose names start with the letters `test`. This naming convention informs the test runner about which methods represent tests.
The crux of each test is a call to [`assertEqual()`](https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertEqual "unittest.TestCase.assertEqual") to check for an expected result; [`assertTrue()`](https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertTrue "unittest.TestCase.assertTrue") or [`assertFalse()`](https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertFalse "unittest.TestCase.assertFalse") to verify a condition; or [`assertRaises()`](https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertRaises "unittest.TestCase.assertRaises") to verify that a specific exception gets raised. These methods are used instead of the [`assert`](https://docs.python.org/3/reference/simple_stmts.html#assert) statement so the test runner can accumulate all test results and produce a report.
The [`setUp()`](https://docs.python.org/3/library/unittest.html#unittest.TestCase.setUp "unittest.TestCase.setUp") and [`tearDown()`](https://docs.python.org/3/library/unittest.html#unittest.TestCase.tearDown "unittest.TestCase.tearDown") methods allow you to define instructions that will be executed before and after each test method. They are covered in more detail in the section [Organizing test code](https://docs.python.org/3/library/unittest.html#organizing-tests).
The final block shows a simple way to run the tests. [`unittest.main()`](https://docs.python.org/3/library/unittest.html#unittest.main "unittest.main") provides a command-line interface to the test script. When run from the command line, the above script produces an output that looks like this:
```
...
----------------------------------------------------------------------
Ran 3 tests in 0.000s
OK

```

Passing the `-v` option to your test script will instruct [`unittest.main()`](https://docs.python.org/3/library/unittest.html#unittest.main "unittest.main") to enable a higher level of verbosity, and produce the following output:
```
test_isupper (__main__.TestStringMethods.test_isupper) ... ok
test_split (__main__.TestStringMethods.test_split) ... ok
test_upper (__main__.TestStringMethods.test_upper) ... ok
----------------------------------------------------------------------
Ran 3 tests in 0.001s
OK

```

The above examples show the most commonly used [`unittest`](https://docs.python.org/3/library/unittest.html#module-unittest "unittest: Unit testing framework for Python.") features which are sufficient to meet many everyday testing needs. The remainder of the documentation explores the full feature set from first principles.
Changed in version 3.11: The behavior of returning a value from a test method (other than the default `None` value), is now deprecated.
## Command-Line Interface[¶](https://docs.python.org/3/library/unittest.html#command-line-interface "Link to this heading")
The unittest module can be used from the command line to run tests from modules, classes or even individual test methods:
```
python -m unittest test_module1 test_module2
python -m unittest test_module.TestClass
python -m unittest test_module.TestClass.test_method

```

You can pass in a list with any combination of module names, and fully qualified class or method names.
Test modules can be specified by file path as well:
```
python -m unittest tests/test_something.py

```

This allows you to use the shell filename completion to specify the test module. The file specified must still be importable as a module. The path is converted to a module name by removing the ‘.py’ and converting path separators into ‘.’. If you want to execute a test file that isn’t importable as a module you should execute the file directly instead.
You can run tests with more detail (higher verbosity) by passing in the -v flag:
```
python -m unittest -v test_module

```

When executed without arguments [Test Discovery](https://docs.python.org/3/library/unittest.html#unittest-test-discovery) is started:
```
python -m unittest

```

For a list of all the command-line options:
```
python -m unittest -h