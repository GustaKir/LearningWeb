Title: Type Variable in Python Typing
URL: https://docs.python.org/3/library/typing.html
Summary: The chunk defines the `typing.TypeVar` class, which is used to construct type variables in Python. It highlights the preferred syntax for creating type variables in generic functions, classes, and type aliases, as well as how to create bounded and constrained type variables.
---

```


_class_ typing.TypeVar(_name_ , _* constraints_, _bound =None_, _covariant =False_, _contravariant =False_, _infer_variance =False_, _default =typing.NoDefault_)[Â¶](https://docs.python.org/3/library/typing.html#typing.TypeVar "Link to this definition")
    
Type variable.
The preferred way to construct a type variable is via the dedicated syntax for [generic functions](https://docs.python.org/3/reference/compound_stmts.html#generic-functions), [generic classes](https://docs.python.org/3/reference/compound_stmts.html#generic-classes), and [generic type aliases](https://docs.python.org/3/reference/compound_stmts.html#generic-type-aliases):
```
classSequence[T]: # T is a TypeVar
  ...

```

This syntax can also be used to create bounded and constrained type variables:
```
classStrSequence[S: str]: # S is a TypeVar with a `str` upper bound;
  ...           # we can say that S is "bounded by `str`"

classStrOrBytesSequence[A: (str, bytes)]: # A is a TypeVar constrained to str or bytes
  ...

```

However, if desired, reusable type variables can also be constructed manually, like so:
```
T = TypeVar('T') # Can be anything
S = TypeVar('S', bound=str) # Can be any subtype of str
A = TypeVar('A', str, bytes) # Must be exactly str or bytes

```

Type variables exist primarily for the benefit of static type checkers. They serve as the parameters for generic types as well as for generic function and type alias definitions. See [`Generic`](https://docs.python.org/3/library/typing.html#typing.Generic "typing.Generic") for more information on generic types. Generic functions work as follows:
```
defrepeat[T](x: T, n: int) -> Sequence[T]:
"""Return a list containing n references to x."""
  return [x]*n

defprint_capitalized[S: str](x: S) -> S:
"""Print x capitalized, and return x."""
  print(x.capitalize())
  return x

defconcatenate[A: (str, bytes)](x: A, y: A) -> A:
"""Add two strings or bytes objects together."""
  return x + y

```

Note that type variables can be _bounded_ , _constrained_ , or neither, but cannot be both bounded _and_ constrained.
The variance of type variables is inferred by type checkers when they are created through the [type parameter syntax](https://docs.python.org/3/reference/compound_stmts.html#type-params) or when `infer_variance=True` is passed. Manually created type variables may be explicitly marked covariant or contravariant by passing `covariant=True` or `contravariant=True`. By default, manually created type variables are invariant. See [**PEP 484**](https://peps.python.org/pep-0484/) and [**PEP 695**](https://peps.python.org/pep-0695/) for more details.
Bounded type variables and constrained type variables have different semantics in several important ways. Using a _bounded_ type variable means that the `TypeVar` will be solved using the most specific type possible:
```
x = print_capitalized('a string')
reveal_type(x) # revealed type is str
classStringSubclass(str):
  pass
y = print_capitalized(StringSubclass('another string'))
reveal_type(y) # revealed type is StringSubclass
z = print_capitalized(45) # error: int is not a subtype of str

```

The upper bound of a type variable can be a concrete type, abstract type (ABC or Protocol), or even a union of types:
```
# Can be anything with an __abs__ method
defprint_abs[T: SupportsAbs](arg: T) -> None:
  print("Absolute value:", abs(arg))
U = TypeVar('U', bound=str|bytes) # Can be any subtype of the union str|bytes
V = TypeVar('V', bound=SupportsAbs) # Can be anything with an __abs__ method

```

Using a _constrained_ type variable, however, means that the `TypeVar` can only ever be solved as being exactly one of the constraints given:
```
a = concatenate('one', 'two')
reveal_type(a) # revealed type is str
b = concatenate(StringSubclass('one'), StringSubclass('two'))
reveal_type(b) # revealed type is str, despite StringSubclass being passed in
c = concatenate('one', b'two') # error: type variable 'A' can be either str or bytes in a function call, but not both