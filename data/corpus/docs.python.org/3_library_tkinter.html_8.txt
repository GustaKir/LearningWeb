Title: Setting Options in Tkinter Widgets
URL: https://docs.python.org/3/library/tkinter.html
Summary: This section explains how to control widget options such as color and border width in Tkinter. Options can be set during object creation using keyword arguments, modified afterward like dictionary items, or updated with the config() method. For detailed information on specific options, reference the Tk man pages.
---

he Tcl interpreter.


## Handy Reference[¶](https://docs.python.org/3/library/tkinter.html#handy-reference "Link to this heading")
### Setting Options[¶](https://docs.python.org/3/library/tkinter.html#setting-options "Link to this heading")
Options control things like the color and border width of a widget. Options can be set in three ways: 

At object creation time, using keyword arguments
    
```
fred = Button(self, fg="red", bg="blue")

```


After object creation, treating the option name like a dictionary index
    
```
fred["fg"] = "red"
fred["bg"] = "blue"

```


Use the config() method to update multiple attrs subsequent to object creation
    
```
fred.config(fg="red", bg="blue")

```

For a complete explanation of a given option and its behavior, see the Tk man pages for the widget in question.
Note that the man pages list “STANDARD OPTIONS” and “WIDGET SPECIFIC OPTIONS” for each widget. The former is a list of options that are common to many widgets, the latter are the options that are idiosyncratic to that particular widget. The Standard Options are documented on the _[options(3)](https://manpages.debian.org/options\(3\))_ man page.
No distinction between standard and widget-specific options is made in this document. Some options don’t apply to some kinds of widgets. Whether a given widget responds to a particular option depends on the class of the widget; buttons have a `command` option, labels do not.
The options supported by a given widget are listed in that widget’s man page, or can be queried at runtime by calling the `config()` method without arguments, or by calling the `keys()` method on that widget. The return value of these calls is a dictionary whose key is the name of the option as a string (for example, `'relief'`) and whose values are 5-tuples.
Some options, like `bg` are synonyms for common options with long names (`bg` is shorthand for “background”). Passing the `config()` method the name of a shorthand option will return a 2-tuple, not 5-tuple. The 2-tuple passed back will contain the name of the synonym and the “real” option (such as `('bg', 'background')`).
Index | Meaning | Example  
---|---|---  
0 | option name | `'relief'`  
1 | option name for database lookup | `'relief'`  
2 | option class for database lookup | `'Relief'`  
3 | default value | `'raised'`  
4 | current value | `'groove'`  
Example:
>>>```
>>> print(fred.config())
{'relief': ('relief', 'relief', 'Relief', 'raised', 'groove')}

```

Of course, the dictionary printed will include all the options available and their values. This is meant only as an example.
### The Packer[¶](https://docs.python.org/3/library/tkinter.html#the-packer "Link to this heading")
The packer is one of Tk’s geometry-management mechanisms. Geometry managers are used to specify the relative positioning of widgets within their container - their mutual _master_. In contrast to the more cumbersome _placer_ (which is used less commonly, and we do not cover here), the packer takes qualitative relationship specification - _above_ , _to the left of_ , _filling_ , etc - and works everything out to determine the exact placement coordinates for you.
The size of any _master_ widget is determined by the size of the “slave widgets” inside. The packer is used to control where slave widgets appear inside the master into which they are packed. You can pack widgets into frames, and frames into other frames, in order to achieve the kind of layout you desire. Additionally, the arrangement is dynamically adjusted to accommodate incremental changes to the configuration, once it is packed.
Note that widgets do not appear until they have had their geometry specified with a geometry manager. It’s a common early mistake to leave out the geometry specification, and then be surprised when the widget is created but nothing appears. A widget will appear only after it has had, for example, the packer’s `pack()` method applied to it.
The pack() method can be called with keyword-option/value pairs that control where the widget is to appear within its container, and how it is to behave when the main application window is resized. Here are some examples:
```
fred.pack()           # defaults to side = "top"
fred.pack(side="left")
fred.pack(expand=1)