Title: urllib.request Documentation: CacheFTPHandler and Error Handling
URL: https://docs.python.org/3/library/urllib.request.html
Summary: This section covers setting the maximum number of cached connections in `CacheFTPHandler`, the behavior of `UnknownHandler` which raises a `URLError`, and how `HTTPErrorProcessor` processes HTTP error responses.
---

CacheFTPHandler.setMaxConns(_m_)[¶](https://docs.python.org/3/library/urllib.request.html#urllib.request.CacheFTPHandler.setMaxConns "Link to this definition")
    
Set maximum number of cached connections to _m_.
## UnknownHandler Objects[¶](https://docs.python.org/3/library/urllib.request.html#unknownhandler-objects "Link to this heading") 

UnknownHandler.unknown_open()[¶](https://docs.python.org/3/library/urllib.request.html#urllib.request.UnknownHandler.unknown_open "Link to this definition")
    
Raise a [`URLError`](https://docs.python.org/3/library/urllib.error.html#urllib.error.URLError "urllib.error.URLError") exception.
## HTTPErrorProcessor Objects[¶](https://docs.python.org/3/library/urllib.request.html#httperrorprocessor-objects "Link to this heading") 

HTTPErrorProcessor.http_response(_request_ , _response_)[¶](https://docs.python.org/3/library/urllib.request.html#urllib.request.HTTPErrorProcessor.http_response "Link to this definition")
    
Process HTTP error responses.
For 200 error codes, the response object is returned immediately.
For non-200 error codes, this simply passes the job on to the `http_error_<type>()` handler methods, via [`OpenerDirector.error()`](https://docs.python.org/3/library/urllib.request.html#urllib.request.OpenerDirector.error "urllib.request.OpenerDirector.error"). Eventually, [`HTTPDefaultErrorHandler`](https://docs.python.org/3/library/urllib.request.html#urllib.request.HTTPDefaultErrorHandler "urllib.request.HTTPDefaultErrorHandler") will raise an [`HTTPError`](https://docs.python.org/3/library/urllib.error.html#urllib.error.HTTPError "urllib.error.HTTPError") if no other handler handles the error. 

HTTPErrorProcessor.https_response(_request_ , _response_)[¶](https://docs.python.org/3/library/urllib.request.html#urllib.request.HTTPErrorProcessor.https_response "Link to this definition")
    
Process HTTPS error responses.
The behavior is same as [`http_response()`](https://docs.python.org/3/library/urllib.request.html#urllib.request.HTTPErrorProcessor.http_response "urllib.request.HTTPErrorProcessor.http_response").
## Examples[¶](https://docs.python.org/3/library/urllib.request.html#examples "Link to this heading")
In addition to the examples below, more examples are given in [HOWTO Fetch Internet Resources Using The urllib Package](https://docs.python.org/3/howto/urllib2.html#urllib-howto).
This example gets the python.org main page and displays the first 300 bytes of it:
>>>```
>>> importurllib.request
>>> with urllib.request.urlopen('http://www.python.org/') as f:
...   print(f.read(300))
...
b'<!doctype html>\n<!--[if lt IE 7]>  <html class="no-js ie6 lt-ie7 lt-ie8 lt-ie9">  <![endif]-->\n<!--[if IE 7]>   <html class="no-js ie7 lt-ie8 lt-ie9">     <![endif]-->\n<!--[if IE 8]>   <html class="no-js ie8 lt-ie9">

```

Note that urlopen returns a bytes object. This is because there is no way for urlopen to automatically determine the encoding of the byte stream it receives from the HTTP server. In general, a program will decode the returned bytes object to string once it determines or guesses the appropriate encoding.
The following HTML spec document, <https://html.spec.whatwg.org/#charset>, lists the various ways in which an HTML or an XML document could have specified its encoding information.
For additional information, see the W3C document: <https://www.w3.org/International/questions/qa-html-encoding-declarations>.
As the python.org website uses _utf-8_ encoding as specified in its meta tag, we will use the same for decoding the bytes object:
>>>```
>>> with urllib.request.urlopen('http://www.python.org/') as f:
...   print(f.read(100).decode('utf-8'))
...
<!doctype html>
<!--[if lt IE 7]>  <html class="no-js ie6 lt-ie7 lt-ie8 lt-ie9">  <![endif]-->
<!-

```

It is also possible to achieve the same result without using the [context manager](https://docs.python.org/3/glossary.html#term-context-manager) approach:
>>>```
>>> importurllib.request
>>> f = urllib.request.urlopen('http://www.python.org/')
>>> try:
...   print(f.read(100).decode('utf-8'))
... finally:
...   f.close()
...
<!doctype html>
<!--[if lt IE 7]>  <html class="no-js ie6 lt-ie7 lt-ie8 lt-ie9">  <![endif]-->
<!--

```

In the following example, we are sending a data-stream to the stdin of a CGI and reading the data it returns to us. Note that this example will only work when the Python installation supports SSL.
>>>```
>>> importurllib.request
>>> req = urllib.request.Request(url='https://localhost/cgi-bin/test.cgi',
...            data=b'This data is passed to stdin of the CGI')
>>> with urllib.request.urlopen(req) as f:
...   print(f.read().decode('utf-8'))
...
Got Data: "This data is passed to stdin of the CGI"

```

The code for the sample CGI used in the above example is:
```
#!/usr/bin/env python
importsys
data = sys.stdin.read()
print('Content-type: text/plain\n\nGot Data: "%s"' % data)