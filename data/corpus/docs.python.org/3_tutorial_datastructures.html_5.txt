Title: Data Structures in Python: Sets and Sorting
URL: https://docs.python.org/3/tutorial/datastructures.html
Summary: This section demonstrates how to use `set()` to eliminate duplicates from a list and how to use `sorted()` in conjunction with `set()` to iterate over unique, sorted elements of a sequence. It also advises against modifying a list during iteration, suggesting instead to create a new list for safer data handling.
---

```
>>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
>>> for i in sorted(basket):
...   print(i)
...
apple
apple
banana
orange
orange
pear

```

Using [`set()`](https://docs.python.org/3/library/stdtypes.html#set "set") on a sequence eliminates duplicate elements. The use of [`sorted()`](https://docs.python.org/3/library/functions.html#sorted "sorted") in combination with [`set()`](https://docs.python.org/3/library/stdtypes.html#set "set") over a sequence is an idiomatic way to loop over unique elements of the sequence in sorted order.
>>>```
>>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
>>> for f in sorted(set(basket)):
...   print(f)
...
apple
banana
orange
pear

```

It is sometimes tempting to change a list while you are looping over it; however, it is often simpler and safer to create a new list instead.
>>>```
>>> importmath
>>> raw_data = [56.2, float('NaN'), 51.7, 55.3, 52.5, float('NaN'), 47.8]
>>> filtered_data = []
>>> for value in raw_data:
...   if not math.isnan(value):
...     filtered_data.append(value)
...
>>> filtered_data
[56.2, 51.7, 55.3, 52.5, 47.8]

```

## 5.7. More on Conditions[¶](https://docs.python.org/3/tutorial/datastructures.html#more-on-conditions "Link to this heading")
The conditions used in `while` and `if` statements can contain any operators, not just comparisons.
The comparison operators `in` and `not in` are membership tests that determine whether a value is in (or not in) a container. The operators `is` and `is not` compare whether two objects are really the same object. All comparison operators have the same priority, which is lower than that of all numerical operators.
Comparisons can be chained. For example, `a < b == c` tests whether `a` is less than `b` and moreover `b` equals `c`.
Comparisons may be combined using the Boolean operators `and` and `or`, and the outcome of a comparison (or of any other Boolean expression) may be negated with `not`. These have lower priorities than comparison operators; between them, `not` has the highest priority and `or` the lowest, so that `A and not B or C` is equivalent to `(A and (not B)) or C`. As always, parentheses can be used to express the desired composition.
The Boolean operators `and` and `or` are so-called _short-circuit_ operators: their arguments are evaluated from left to right, and evaluation stops as soon as the outcome is determined. For example, if `A` and `C` are true but `B` is false, `A and B and C` does not evaluate the expression `C`. When used as a general value and not as a Boolean, the return value of a short-circuit operator is the last evaluated argument.
It is possible to assign the result of a comparison or other Boolean expression to a variable. For example,
>>>```
>>> string1, string2, string3 = '', 'Trondheim', 'Hammer Dance'
>>> non_null = string1 or string2 or string3
>>> non_null
'Trondheim'

```

Note that in Python, unlike C, assignment inside expressions must be done explicitly with the [walrus operator](https://docs.python.org/3/faq/design.html#why-can-t-i-use-an-assignment-in-an-expression) `:=`. This avoids a common class of problems encountered in C programs: typing `=` in an expression when `==` was intended.
## 5.8. Comparing Sequences and Other Types[¶](https://docs.python.org/3/tutorial/datastructures.html#comparing-sequences-and-other-types "Link to this heading")
Sequence objects typically may be compared to other objects with the same sequence type. The comparison uses _lexicographical_ ordering: first the first two items are compared, and if they differ this determines the outcome of the comparison; if they are equal, the next two items are compared, and so on, until either sequence is exhausted. If two items to be compared are themselves sequences of the same type, the lexicographical comparison is carried out recursively. If all items of two sequences compare equal, the sequences are considered equal. If one sequence is an initial sub-sequence of the other, the shorter sequence is the smaller (lesser) one. Lexicographical ordering for strings uses the Unicode code point number to order individual characters. Some examples of comparisons between sequences of the same type:
```
(1, 2, 3)       < (1, 2, 4)
[1, 2, 3]       < [1, 2, 4]
'ABC' < 'C' < 'Pascal' < 'Python'
(1, 2, 3, 4)      < (1, 2, 4)
(1, 2)         < (1, 2, -1)
(1, 2, 3)       == (1.0, 2.0, 3.0)
(1, 2, ('aa', 'ab'))  < (1, 2, ('abc', 'a'), 4)