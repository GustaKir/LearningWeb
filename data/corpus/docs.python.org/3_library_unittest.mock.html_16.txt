Title: Mock and Magic Methods in unittest.mock
URL: https://docs.python.org/3/library/unittest.mock.html
Summary: This section explains that the Mock class in unittest.mock does not create magic methods or attributes, raising an AttributeError instead. It also introduces patch decorators, which are used to patch objects within the scope of a function and manage unpatching automatically, even during exceptions.
---

```

[[1](https://docs.python.org/3/library/unittest.mock.html#id1)]
The only exceptions are magic methods and attributes (those that have leading and trailing double underscores). Mock doesn’t create these but instead raises an [`AttributeError`](https://docs.python.org/3/library/exceptions.html#AttributeError "AttributeError"). This is because the interpreter will often implicitly request these methods, and gets _very_ confused to get a new Mock object when it expects a magic method. If you need magic method support see [magic methods](https://docs.python.org/3/library/unittest.mock.html#magic-methods).
## The patchers[¶](https://docs.python.org/3/library/unittest.mock.html#the-patchers "Link to this heading")
The patch decorators are used for patching objects only within the scope of the function they decorate. They automatically handle the unpatching for you, even if exceptions are raised. All of these functions can also be used in with statements or as class decorators.
### patch[¶](https://docs.python.org/3/library/unittest.mock.html#patch "Link to this heading")
Note
The key is to do the patching in the right namespace. See the section [where to patch](https://docs.python.org/3/library/unittest.mock.html#id6). 

unittest.mock.patch(_target_ , _new =DEFAULT_, _spec =None_, _create =False_, _spec_set =None_, _autospec =None_, _new_callable =None_, _** kwargs_)[¶](https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch "Link to this definition")
    
[`patch()`](https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch "unittest.mock.patch") acts as a function decorator, class decorator or a context manager. Inside the body of the function or with statement, the _target_ is patched with a _new_ object. When the function/with statement exits the patch is undone.
If _new_ is omitted, then the target is replaced with an [`AsyncMock`](https://docs.python.org/3/library/unittest.mock.html#unittest.mock.AsyncMock "unittest.mock.AsyncMock") if the patched object is an async function or a [`MagicMock`](https://docs.python.org/3/library/unittest.mock.html#unittest.mock.MagicMock "unittest.mock.MagicMock") otherwise. If [`patch()`](https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch "unittest.mock.patch") is used as a decorator and _new_ is omitted, the created mock is passed in as an extra argument to the decorated function. If [`patch()`](https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch "unittest.mock.patch") is used as a context manager the created mock is returned by the context manager.
_target_ should be a string in the form `'package.module.ClassName'`. The _target_ is imported and the specified object replaced with the _new_ object, so the _target_ must be importable from the environment you are calling [`patch()`](https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch "unittest.mock.patch") from. The target is imported when the decorated function is executed, not at decoration time.
The _spec_ and _spec_set_ keyword arguments are passed to the [`MagicMock`](https://docs.python.org/3/library/unittest.mock.html#unittest.mock.MagicMock "unittest.mock.MagicMock") if patch is creating one for you.
In addition you can pass `spec=True` or `spec_set=True`, which causes patch to pass in the object being mocked as the spec/spec_set object.
_new_callable_ allows you to specify a different class, or callable object, that will be called to create the _new_ object. By default [`AsyncMock`](https://docs.python.org/3/library/unittest.mock.html#unittest.mock.AsyncMock "unittest.mock.AsyncMock") is used for async functions and [`MagicMock`](https://docs.python.org/3/library/unittest.mock.html#unittest.mock.MagicMock "unittest.mock.MagicMock") for the rest.
A more powerful form of _spec_ is _autospec_. If you set `autospec=True` then the mock will be created with a spec from the object being replaced. All attributes of the mock will also have the spec of the corresponding attribute of the object being replaced. Methods and functions being mocked will have their arguments checked and will raise a [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError "TypeError") if they are called with the wrong signature. For mocks replacing a class, their return value (the ‘instance’) will have the same spec as the class. See the [`create_autospec()`](https://docs.python.org/3/library/unittest.mock.html#unittest.mock.create_autospec "unittest.mock.create_autospec") function and [Autospeccing](https://docs.python.org/3/library/unittest.mock.html#auto-speccing).
Instead of `autospec=True` you can pass `autospec=some_object` to use an arbitrary object as the spec instead of the one being replaced.
By default [`patch()`](https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch "unittest.mock.patch") will fail to replace attributes that don’t exist. If you pass in `create=True`, and the attribute doesn’t exist, patc