Title: Python Execution Model: Binding and Scope
URL: https://docs.python.org/3/reference/executionmodel.html
Summary: The `from ... import *` statement binds all names from an imported module, excluding those starting with an underscore, and is limited to module scope. Variables bound within function or class blocks are considered local, while those at the module level are global. Additionally, variable usage without definition in a block refers to the concept of free variables.
---

The `import` statement of the form `from ... import *` binds all names defined in the imported module, except those beginning with an underscore. This form may only be used at the module level.
A target occurring in a [`del`](https://docs.python.org/3/reference/simple_stmts.html#del) statement is also considered bound for this purpose (though the actual semantics are to unbind the name).
Each assignment or import statement occurs within a block defined by a class or function definition or at the module level (the top-level code block).
If a name is bound in a block, it is a local variable of that block, unless declared as [`nonlocal`](https://docs.python.org/3/reference/simple_stmts.html#nonlocal) or [`global`](https://docs.python.org/3/reference/simple_stmts.html#global). If a name is bound at the module level, it is a global variable. (The variables of the module code block are local and global.) If a variable is used in a code block but not defined there, it is a [free variable](https://docs.python.org/3/glossary.html#term-free-variable).
Each occurrence of a name in the program text refers to the _binding_ of that name established by the following name resolution rules.
### 4.2.2. Resolution of names[¶](https://docs.python.org/3/reference/executionmodel.html#resolution-of-names "Link to this heading")
A _scope_ defines the visibility of a name within a block. If a local variable is defined in a block, its scope includes that block. If the definition occurs in a function block, the scope extends to any blocks contained within the defining one, unless a contained block introduces a different binding for the name.
When a name is used in a code block, it is resolved using the nearest enclosing scope. The set of all such scopes visible to a code block is called the block’s _environment_.
When a name is not found at all, a [`NameError`](https://docs.python.org/3/library/exceptions.html#NameError "NameError") exception is raised. If the current scope is a function scope, and the name refers to a local variable that has not yet been bound to a value at the point where the name is used, an [`UnboundLocalError`](https://docs.python.org/3/library/exceptions.html#UnboundLocalError "UnboundLocalError") exception is raised. [`UnboundLocalError`](https://docs.python.org/3/library/exceptions.html#UnboundLocalError "UnboundLocalError") is a subclass of [`NameError`](https://docs.python.org/3/library/exceptions.html#NameError "NameError").
If a name binding operation occurs anywhere within a code block, all uses of the name within the block are treated as references to the current block. This can lead to errors when a name is used within a block before it is bound. This rule is subtle. Python lacks declarations and allows name binding operations to occur anywhere within a code block. The local variables of a code block can be determined by scanning the entire text of the block for name binding operations. See [the FAQ entry on UnboundLocalError](https://docs.python.org/3/faq/programming.html#faq-unboundlocalerror) for examples.
If the [`global`](https://docs.python.org/3/reference/simple_stmts.html#global) statement occurs within a block, all uses of the names specified in the statement refer to the bindings of those names in the top-level namespace. Names are resolved in the top-level namespace by searching the global namespace, i.e. the namespace of the module containing the code block, and the builtins namespace, the namespace of the module [`builtins`](https://docs.python.org/3/library/builtins.html#module-builtins "builtins: The module that provides the built-in namespace."). The global namespace is searched first. If the names are not found there, the builtins namespace is searched next. If the names are also not found in the builtins namespace, new variables are created in the global namespace. The global statement must precede all uses of the listed names.
The [`global`](https://docs.python.org/3/reference/simple_stmts.html#global) statement has the same scope as a name binding operation in the same block. If the nearest enclosing scope for a free variable contains a global statement, the free variable is treated as a global.
The [`nonlocal`](https://docs.python.org/3/reference/simple_stmts.html#nonlocal) statement causes corresponding names to refer to previously bound variables in the nearest enclosing function scope. [`SyntaxError`](https://docs.python.org/3/library/exceptions.html#SyntaxError "SyntaxError") is raised at compile time if the given name does not exist in any enclosing function scope. [Type parameters](https://docs.python.org/3/reference/compound_stmts.html#type-params) cannot be rebound with the `nonlocal` statement.
The namespace for a module is automatically created the first time a module is imported. The main module for a script is always called [`__main__`](https://docs.python.org/3/library/__main__.html#module-__main__ "__main__: The environment where top-level code is run. Covers comman