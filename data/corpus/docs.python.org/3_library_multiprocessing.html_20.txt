Title: multiprocessing.Lock
URL: https://docs.python.org/3/library/multiprocessing.html
Summary: The `multiprocessing.Lock` is a non-recursive lock object that functions similarly to `threading.Lock`. It blocks further attempts to acquire the lock from other processes or threads until it is released, allowing any process or thread to release it. Key concepts from `threading.Lock` are applied here for both processes and threads.
---

_class_ multiprocessing.Lock[¶](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Lock "Link to this definition")
    
A non-recursive lock object: a close analog of [`threading.Lock`](https://docs.python.org/3/library/threading.html#threading.Lock "threading.Lock"). Once a process or thread has acquired a lock, subsequent attempts to acquire it from any process or thread will block until it is released; any process or thread may release it. The concepts and behaviors of [`threading.Lock`](https://docs.python.org/3/library/threading.html#threading.Lock "threading.Lock") as it applies to threads are replicated here in [`multiprocessing.Lock`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Lock "multiprocessing.Lock") as it applies to either processes or threads, except as noted.
Note that [`Lock`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Lock "multiprocessing.Lock") is actually a factory function which returns an instance of `multiprocessing.synchronize.Lock` initialized with a default context.
[`Lock`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Lock "multiprocessing.Lock") supports the [context manager](https://docs.python.org/3/glossary.html#term-context-manager) protocol and thus may be used in [`with`](https://docs.python.org/3/reference/compound_stmts.html#with) statements. 

acquire(_block =True_, _timeout =None_)[¶](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Lock.acquire "Link to this definition")
    
Acquire a lock, blocking or non-blocking.
With the _block_ argument set to `True` (the default), the method call will block until the lock is in an unlocked state, then set it to locked and return `True`. Note that the name of this first argument differs from that in [`threading.Lock.acquire()`](https://docs.python.org/3/library/threading.html#threading.Lock.acquire "threading.Lock.acquire").
With the _block_ argument set to `False`, the method call does not block. If the lock is currently in a locked state, return `False`; otherwise set the lock to a locked state and return `True`.
When invoked with a positive, floating-point value for _timeout_ , block for at most the number of seconds specified by _timeout_ as long as the lock can not be acquired. Invocations with a negative value for _timeout_ are equivalent to a _timeout_ of zero. Invocations with a _timeout_ value of `None` (the default) set the timeout period to infinite. Note that the treatment of negative or `None` values for _timeout_ differs from the implemented behavior in [`threading.Lock.acquire()`](https://docs.python.org/3/library/threading.html#threading.Lock.acquire "threading.Lock.acquire"). The _timeout_ argument has no practical implications if the _block_ argument is set to `False` and is thus ignored. Returns `True` if the lock has been acquired or `False` if the timeout period has elapsed. 

release()[¶](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Lock.release "Link to this definition")
    
Release a lock. This can be called from any process or thread, not only the process or thread which originally acquired the lock.
Behavior is the same as in [`threading.Lock.release()`](https://docs.python.org/3/library/threading.html#threading.Lock.release "threading.Lock.release") except that when invoked on an unlocked lock, a [`ValueError`](https://docs.python.org/3/library/exceptions.html#ValueError "ValueError") is raised. 

_class_ multiprocessing.RLock[¶](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.RLock "Link to this definition")
    
A recursive lock object: a close analog of [`threading.RLock`](https://docs.python.org/3/library/threading.html#threading.RLock "threading.RLock"). A recursive lock must be released by the process or thread that acquired it. Once a process or thread has acquired a recursive lock, the same process or thread may acquire it again without blocking; that process or thread must release it once for each time it has been acquired.
Note that [`RLock`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.RLock "multiprocessing.RLock") is actually a factory function which returns an instance of `multiprocessing.synchronize.RLock` initialized with a default context.
[`RLock`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.RLock "multiprocessing.RLock") supports the [context manager](https://docs.python.org/3/glossary.html#term-context-manager) protocol and thus may be used in [`with`](https://docs.python.org/3/reference/compound_stmts.html#with) statements.