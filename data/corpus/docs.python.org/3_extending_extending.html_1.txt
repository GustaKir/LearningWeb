Title: Extending Python with C or C++
URL: https://docs.python.org/3/extending/extending.html
Summary: This section discusses how to add new built-in modules to Python using C or C++. It highlights the capabilities of extension modules, including the ability to implement new object types and call C library functions. The Python API provides functions, macros, and variables for interfacing with the Python run-time system and requires the inclusion of the header 'Python.h'. It is noted that this C extension interface is specific to CPython.
---

# 1. Extending Python with C or C++[¶](https://docs.python.org/3/extending/extending.html#extending-python-with-c-or-c "Link to this heading")
It is quite easy to add new built-in modules to Python, if you know how to program in C. Such _extension modules_ can do two things that can’t be done directly in Python: they can implement new built-in object types, and they can call C library functions and system calls.
To support extensions, the Python API (Application Programmers Interface) defines a set of functions, macros and variables that provide access to most aspects of the Python run-time system. The Python API is incorporated in a C source file by including the header `"Python.h"`.
The compilation of an extension module depends on its intended use as well as on your system setup; details are given in later chapters.
Note
The C extension interface is specific to CPython, and extension modules do not work on other Python implementations. In many cases, it is possible to avoid writing C extensions and preserve portability to other implementations. For example, if your use case is calling C library functions or system calls, you should consider using the [`ctypes`](https://docs.python.org/3/library/ctypes.html#module-ctypes "ctypes: A foreign function library for Python.") module or the [cffi](https://cffi.readthedocs.io/) library rather than writing custom C code. These modules let you write Python code to interface with C code and are more portable between implementations of Python than writing and compiling a C extension module.
## 1.1. A Simple Example[¶](https://docs.python.org/3/extending/extending.html#a-simple-example "Link to this heading")
Let’s create an extension module called `spam` (the favorite food of Monty Python fans…) and let’s say we want to create a Python interface to the C library function `system()` [[1]](https://docs.python.org/3/extending/extending.html#id5). This function takes a null-terminated character string as argument and returns an integer. We want this function to be callable from Python as follows:
>>>```
>>> importspam
>>> status = spam.system("ls -l")

```

Begin by creating a file `spammodule.c`. (Historically, if a module is called `spam`, the C file containing its implementation is called `spammodule.c`; if the module name is very long, like `spammify`, the module name can be just `spammify.c`.)
The first two lines of our file can be:
```
#define PY_SSIZE_T_CLEAN
#include<Python.h>

```

which pulls in the Python API (you can add a comment describing the purpose of the module and a copyright notice if you like).
Note
Since Python may define some pre-processor definitions which affect the standard headers on some systems, you _must_ include `Python.h` before any standard headers are included.
`#define PY_SSIZE_T_CLEAN` was used to indicate that `Py_ssize_t` should be used in some APIs instead of `int`. It is not necessary since Python 3.13, but we keep it here for backward compatibility. See [Strings and buffers](https://docs.python.org/3/c-api/arg.html#arg-parsing-string-and-buffers) for a description of this macro.
All user-visible symbols defined by `Python.h` have a prefix of `Py` or `PY`, except those defined in standard header files. For convenience, and since they are used extensively by the Python interpreter, `"Python.h"` includes a few standard header files: `<stdio.h>`, `<string.h>`, `<errno.h>`, and `<stdlib.h>`. If the latter header file does not exist on your system, it declares the functions `malloc()`, `free()` and `realloc()` directly.
The next thing we add to our module file is the C function that will be called when the Python expression `spam.system(string)` is evaluated (we’ll see shortly how it ends up being called):
```
staticPyObject*
spam_system(PyObject*self,PyObject*args)
{
constchar*command;
intsts;
if(!PyArg_ParseTuple(args,"s",&command))
returnNULL;
sts=system(command);
returnPyLong_FromLong(sts);
}