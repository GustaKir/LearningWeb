Title: Regular Expression Special Characters in Python
URL: https://docs.python.org/3/library/re.html
Summary: This section covers the special characters used in Python regular expressions, detailing how the dot (.) matches any character except a newline, the caret (^) matches the start of a string (or a newline in MULTILINE mode), and the dollar sign ($) matches the end of a string (or before a newline in MULTILINE mode). It also provides patterns demonstrating these matches.
---

sion `(?:a{6})*` matches any multiple of six `'a'` characters.
The special characters are: 

`.`
    
(Dot.) In the default mode, this matches any character except a newline. If the [`DOTALL`](https://docs.python.org/3/library/re.html#re.DOTALL "re.DOTALL") flag has been specified, this matches any character including a newline. `(?s:.)` matches any character regardless of flags. 

`^`
    
(Caret.) Matches the start of the string, and in [`MULTILINE`](https://docs.python.org/3/library/re.html#re.MULTILINE "re.MULTILINE") mode also matches immediately after each newline. 

`$`
    
Matches the end of the string or just before the newline at the end of the string, and in [`MULTILINE`](https://docs.python.org/3/library/re.html#re.MULTILINE "re.MULTILINE") mode also matches before a newline. `foo` matches both ‘foo’ and ‘foobar’, while the regular expression `foo$` matches only ‘foo’. More interestingly, searching for `foo.$` in `'foo1\nfoo2\n'` matches ‘foo2’ normally, but ‘foo1’ in [`MULTILINE`](https://docs.python.org/3/library/re.html#re.MULTILINE "re.MULTILINE") mode; searching for a single `$` in `'foo\n'` will find two (empty) matches: one just before the newline, and one at the end of the string. 

`*`
    
Causes the resulting RE to match 0 or more repetitions of the preceding RE, as many repetitions as are possible. `ab*` will match ‘a’, ‘ab’, or ‘a’ followed by any number of ‘b’s. 

`+`
    
Causes the resulting RE to match 1 or more repetitions of the preceding RE. `ab+` will match ‘a’ followed by any non-zero number of ‘b’s; it will not match just ‘a’. 

`?`
    
Causes the resulting RE to match 0 or 1 repetitions of the preceding RE. `ab?` will match either ‘a’ or ‘ab’. 

`*?`, `+?`, `??`
    
The `'*'`, `'+'`, and `'?'` quantifiers are all _greedy_ ; they match as much text as possible. Sometimes this behaviour isn’t desired; if the RE `<.*>` is matched against `'<a> b <c>'`, it will match the entire string, and not just `'<a>'`. Adding `?` after the quantifier makes it perform the match in _non-greedy_ or _minimal_ fashion; as _few_ characters as possible will be matched. Using the RE `<.*?>` will match only `'<a>'`. 

`*+`, `++`, `?+`
    
Like the `'*'`, `'+'`, and `'?'` quantifiers, those where `'+'` is appended also match as many times as possible. However, unlike the true greedy quantifiers, these do not allow back-tracking when the expression following it fails to match. These are known as _possessive_ quantifiers. For example, `a*a` will match `'aaaa'` because the `a*` will match all 4 `'a'`s, but, when the final `'a'` is encountered, the expression is backtracked so that in the end the `a*` ends up matching 3 `'a'`s total, and the fourth `'a'` is matched by the final `'a'`. However, when `a*+a` is used to match `'aaaa'`, the `a*+` will match all 4 `'a'`, but when the final `'a'` fails to find any more characters to match, the expression cannot be backtracked and will thus fail to match. `x*+`, `x++` and `x?+` are equivalent to `(?>x*)`, `(?>x+)` and `(?>x?)` correspondingly.
Added in version 3.11. 

`{m}`
    
Specifies that exactly _m_ copies of the previous RE should be matched; fewer matches cause the entire RE not to match. For example, `a{6}` will match exactly six `'a'` characters, but not five. 

`{m,n}`
    
Causes the resulting RE to match from _m_ to _n_ repetitions of the preceding RE, attempting to match as many repetitions as possible. For example, `a{3,5}` will match from 3 to 5 `'a'` characters. Omitting _m_ specifies a lower bound of zero, and omitting _n_ specifies an infinite upper bound. As an example, `a{4,}b` will match `'aaaab'` or a thousand `'a'` characters followed by a `'b'`, but not `'aaab'`. The comma may not be omitted or the modifier would be confused with the previously described form. 

`{m,n}?`
    
Causes the resulting RE to match from _m_ to _n_ repetitions of the preceding RE, attempting to match as _few_ repetitions as possible. This is the non-greedy version of the previous quantifier. For example, on the 6-character string `'aaaaaa'`, `a{3,5}` will match 5 `'a'` characters, while `a{3,5}?` will only match 3 characters. 

`{m,n}+`
    
Causes the resulting RE to match from _m_ to _n_ repetitions of the preceding RE, attempting to match as many repetitions as possible _without_ establishing any backtracking points. This is the possessive version of the quantifier above. For example, on the 6-character string `'aaaaaa'`, `a{3,5}+aa` attempt to match 5 `'a'` characters, then, requiring 2 more `'a'`s, will need more characters than available and thus fail, while `a{3,5}aa` will match with `a{3,5}` capturing 5, then 4 `'a'`s by backtracking and then the final 2 `'a'`s are matched by the final `aa` in the pattern. `x{m,n}+` is equivalent to `(?>x{m,n})`.
Added in version 3.11.