Title: Rich Comparison Methods in Python
URL: https://docs.python.org/3/reference/datamodel.html
Summary: This section details the rich comparison methods in Python, which allow for operator overloading. It lists the methods corresponding to comparison operators, such as `__le__` for `<=`, `__eq__` for `==`, and so on, enabling custom behavior when using these operators with class instances.
---

object.__le__(_self_ , _other_)[¶](https://docs.python.org/3/reference/datamodel.html#object.__le__ "Link to this definition")


object.__eq__(_self_ , _other_)[¶](https://docs.python.org/3/reference/datamodel.html#object.__eq__ "Link to this definition")


object.__ne__(_self_ , _other_)[¶](https://docs.python.org/3/reference/datamodel.html#object.__ne__ "Link to this definition")


object.__gt__(_self_ , _other_)[¶](https://docs.python.org/3/reference/datamodel.html#object.__gt__ "Link to this definition")


object.__ge__(_self_ , _other_)[¶](https://docs.python.org/3/reference/datamodel.html#object.__ge__ "Link to this definition")
    
These are the so-called “rich comparison” methods. The correspondence between operator symbols and method names is as follows: `x<y` calls `x.__lt__(y)`, `x<=y` calls `x.__le__(y)`, `x==y` calls `x.__eq__(y)`, `x!=y` calls `x.__ne__(y)`, `x>y` calls `x.__gt__(y)`, and `x>=y` calls `x.__ge__(y)`.
A rich comparison method may return the singleton [`NotImplemented`](https://docs.python.org/3/library/constants.html#NotImplemented "NotImplemented") if it does not implement the operation for a given pair of arguments. By convention, `False` and `True` are returned for a successful comparison. However, these methods can return any value, so if the comparison operator is used in a Boolean context (e.g., in the condition of an `if` statement), Python will call [`bool()`](https://docs.python.org/3/library/functions.html#bool "bool") on the value to determine if the result is true or false.
By default, `object` implements [`__eq__()`](https://docs.python.org/3/reference/datamodel.html#object.__eq__ "object.__eq__") by using `is`, returning [`NotImplemented`](https://docs.python.org/3/library/constants.html#NotImplemented "NotImplemented") in the case of a false comparison: `True if x is y else NotImplemented`. For [`__ne__()`](https://docs.python.org/3/reference/datamodel.html#object.__ne__ "object.__ne__"), by default it delegates to [`__eq__()`](https://docs.python.org/3/reference/datamodel.html#object.__eq__ "object.__eq__") and inverts the result unless it is `NotImplemented`. There are no other implied relationships among the comparison operators or default implementations; for example, the truth of `(x<y or x==y)` does not imply `x<=y`. To automatically generate ordering operations from a single root operation, see [`functools.total_ordering()`](https://docs.python.org/3/library/functools.html#functools.total_ordering "functools.total_ordering").
By default, the [`object`](https://docs.python.org/3/library/functions.html#object "object") class provides implementations consistent with [Value comparisons](https://docs.python.org/3/reference/expressions.html#expressions-value-comparisons): equality compares according to object identity, and order comparisons raise [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError "TypeError"). Each default method may generate these results directly, but may also return [`NotImplemented`](https://docs.python.org/3/library/constants.html#NotImplemented "NotImplemented").
See the paragraph on [`__hash__()`](https://docs.python.org/3/reference/datamodel.html#object.__hash__ "object.__hash__") for some important notes on creating [hashable](https://docs.python.org/3/glossary.html#term-hashable) objects which support custom comparison operations and are usable as dictionary keys.
There are no swapped-argument versions of these methods (to be used when the left argument does not support the operation but the right argument does); rather, [`__lt__()`](https://docs.python.org/3/reference/datamodel.html#object.__lt__ "object.__lt__") and [`__gt__()`](https://docs.python.org/3/reference/datamodel.html#object.__gt__ "object.__gt__") are each other’s reflection, [`__le__()`](https://docs.python.org/3/reference/datamodel.html#object.__le__ "object.__le__") and [`__ge__()`](https://docs.python.org/3/reference/datamodel.html#object.__ge__ "object.__ge__") are each other’s reflection, and [`__eq__()`](https://docs.python.org/3/reference/datamodel.html#object.__eq__ "object.__eq__") and [`__ne__()`](https://docs.python.org/3/reference/datamodel.html#object.__ne__ "object.__ne__") are their own reflection. If the operands are of different types, and the right operand’s type is a direct or indirect subclass of the left operand’s type, the reflected method of the right operand has priority, otherwise the left operand’s method has priority. Virtual subclassing is not considered.
When no appropriate method returns any value other than [`NotImplemented`](https://docs.python.org/3/library/constants.html#NotImplemented "NotImplemented"), the `==` and `!=` operators will fall back to `is` and `is not`, respectively.