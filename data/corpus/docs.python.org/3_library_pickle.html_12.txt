Title: Understanding __setstate__ Method in Pickling
URL: https://docs.python.org/3/library/pickle.html
Summary: __setstate__() is invoked with the unpickled state when unpickling an object. The state may not be a dictionary if this method is defined. Otherwise, the state must be a dictionary, with its items assigned to the new instance. If __reduce__() returns None during pickling, __setstate__() is not called during unpickling.
---

object.__setstate__(_state_)[¶](https://docs.python.org/3/library/pickle.html#object.__setstate__ "Link to this definition")
    
Upon unpickling, if the class defines [`__setstate__()`](https://docs.python.org/3/library/pickle.html#object.__setstate__ "object.__setstate__"), it is called with the unpickled state. In that case, there is no requirement for the state object to be a dictionary. Otherwise, the pickled state must be a dictionary and its items are assigned to the new instance’s dictionary.
Note
If [`__reduce__()`](https://docs.python.org/3/library/pickle.html#object.__reduce__ "object.__reduce__") returns a state with value `None` at pickling, the [`__setstate__()`](https://docs.python.org/3/library/pickle.html#object.__setstate__ "object.__setstate__") method will not be called upon unpickling.
Refer to the section [Handling Stateful Objects](https://docs.python.org/3/library/pickle.html#pickle-state) for more information about how to use the methods [`__getstate__()`](https://docs.python.org/3/library/pickle.html#object.__getstate__ "object.__getstate__") and [`__setstate__()`](https://docs.python.org/3/library/pickle.html#object.__setstate__ "object.__setstate__").
Note
At unpickling time, some methods like [`__getattr__()`](https://docs.python.org/3/reference/datamodel.html#object.__getattr__ "object.__getattr__"), [`__getattribute__()`](https://docs.python.org/3/reference/datamodel.html#object.__getattribute__ "object.__getattribute__"), or [`__setattr__()`](https://docs.python.org/3/reference/datamodel.html#object.__setattr__ "object.__setattr__") may be called upon the instance. In case those methods rely on some internal invariant being true, the type should implement [`__new__()`](https://docs.python.org/3/reference/datamodel.html#object.__new__ "object.__new__") to establish such an invariant, as [`__init__()`](https://docs.python.org/3/reference/datamodel.html#object.__init__ "object.__init__") is not called when unpickling an instance.
As we shall see, pickle does not use directly the methods described above. In fact, these methods are part of the copy protocol which implements the [`__reduce__()`](https://docs.python.org/3/library/pickle.html#object.__reduce__ "object.__reduce__") special method. The copy protocol provides a unified interface for retrieving the data necessary for pickling and copying objects. [[4]](https://docs.python.org/3/library/pickle.html#id10)
Although powerful, implementing [`__reduce__()`](https://docs.python.org/3/library/pickle.html#object.__reduce__ "object.__reduce__") directly in your classes is error prone. For this reason, class designers should use the high-level interface (i.e., [`__getnewargs_ex__()`](https://docs.python.org/3/library/pickle.html#object.__getnewargs_ex__ "object.__getnewargs_ex__"), [`__getstate__()`](https://docs.python.org/3/library/pickle.html#object.__getstate__ "object.__getstate__") and [`__setstate__()`](https://docs.python.org/3/library/pickle.html#object.__setstate__ "object.__setstate__")) whenever possible. We will show, however, cases where using `__reduce__()` is the only option or leads to more efficient pickling or both.