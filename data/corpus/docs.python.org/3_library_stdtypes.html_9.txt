Title: Iterator __next__ Method
URL: https://docs.python.org/3/library/stdtypes.html
Summary: The __next__() method returns the next item from an iterator and raises the StopIteration exception when no further items are available. It is an essential part of Python's iterator protocol, enabling iteration over various sequence types and dictionaries.
---

iterator.__next__()[¶](https://docs.python.org/3/library/stdtypes.html#iterator.__next__ "Link to this definition")
    
Return the next item from the [iterator](https://docs.python.org/3/glossary.html#term-iterator). If there are no further items, raise the [`StopIteration`](https://docs.python.org/3/library/exceptions.html#StopIteration "StopIteration") exception. This method corresponds to the [`tp_iternext`](https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_iternext "PyTypeObject.tp_iternext") slot of the type structure for Python objects in the Python/C API.
Python defines several iterator objects to support iteration over general and specific sequence types, dictionaries, and other more specialized forms. The specific types are not important beyond their implementation of the iterator protocol.
Once an iterator’s [`__next__()`](https://docs.python.org/3/library/stdtypes.html#iterator.__next__ "iterator.__next__") method raises [`StopIteration`](https://docs.python.org/3/library/exceptions.html#StopIteration "StopIteration"), it must continue to do so on subsequent calls. Implementations that do not obey this property are deemed broken.
### Generator Types[¶](https://docs.python.org/3/library/stdtypes.html#generator-types "Link to this heading")
Python’s [generator](https://docs.python.org/3/glossary.html#term-generator)s provide a convenient way to implement the iterator protocol. If a container object’s [`__iter__()`](https://docs.python.org/3/reference/datamodel.html#object.__iter__ "object.__iter__") method is implemented as a generator, it will automatically return an iterator object (technically, a generator object) supplying the [`__iter__()`](https://docs.python.org/3/library/stdtypes.html#iterator.__iter__ "iterator.__iter__") and [`__next__()`](https://docs.python.org/3/reference/expressions.html#generator.__next__ "generator.__next__") methods. More information about generators can be found in [the documentation for the yield expression](https://docs.python.org/3/reference/expressions.html#yieldexpr).
## Sequence Types — [`list`](https://docs.python.org/3/library/stdtypes.html#list "list"), [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "tuple"), [`range`](https://docs.python.org/3/library/stdtypes.html#range "range")[¶](https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range "Link to this heading")
There are three basic sequence types: lists, tuples, and range objects. Additional sequence types tailored for processing of [binary data](https://docs.python.org/3/library/stdtypes.html#binaryseq) and [text strings](https://docs.python.org/3/library/stdtypes.html#textseq) are described in dedicated sections.
### Common Sequence Operations[¶](https://docs.python.org/3/library/stdtypes.html#common-sequence-operations "Link to this heading")
The operations in the following table are supported by most sequence types, both mutable and immutable. The [`collections.abc.Sequence`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence "collections.abc.Sequence") ABC is provided to make it easier to correctly implement these operations on custom sequence types.
This table lists the sequence operations sorted in ascending priority. In the table, _s_ and _t_ are sequences of the same type, _n_ , _i_ , _j_ and _k_ are integers and _x_ is an arbitrary object that meets any type and value restrictions imposed by _s_.
The `in` and `not in` operations have the same priorities as the comparison operations. The `+` (concatenation) and `*` (repetition) operations have the same priority as the corresponding numeric operations. [[3]](https://docs.python.org/3/library/stdtypes.html#id14)
Operation | Result | Notes  
---|---|---  
`x in s` | `True` if an item of _s_ is equal to _x_ , else `False` | (1)  
`x not in s` | `False` if an item of _s_ is equal to _x_ , else `True` | (1)  
`s + t` | the concatenation of _s_ and _t_ | (6)(7)  
`s * n` or `n * s` | equivalent to adding _s_ to itself _n_ times | (2)(7)  
`s[i]` | _i_ th item of _s_ , origin 0 | (3)  
`s[i:j]` | slice of _s_ from _i_ to _j_ | (3)(4)  
`s[i:j:k]` | slice of _s_ from _i_ to _j_ with step _k_ | (3)(5)  
`len(s)` | length of _s_ |   
`min(s)` | smallest item of _s_ |   
`max(s)` | largest item of _s_ |   
`s.index(x[, i[, j]])` | index of the first occurrence of _x_ in _s_ (at or after index _i_ and before index _j_) | (8)  
`s.count(x)` | total number of occurrences of _x_ in _s_ |   
Sequences of the same type also support comparisons. In particular, tuples and lists are compared lexicographically by comparing corresponding elements. This means that to compare equal, every element must compare equal and the two sequences must be of the same type and have the same length. (For full details see [Comparisons](https://docs.python.org/3/reference/expressions.html#comparisons) in the language reference.)
Forward and reversed iterators over mutable sequences access values usi