Title: Accessing Functions from Loaded DLLs
URL: https://docs.python.org/3/library/ctypes.html
Summary: This section explains how to access functions from loaded dynamic link libraries (DLLs) in Python using the ctypes module. Functions are accessed as attributes of DLL objects. It notes the distinction between ANSI and UNICODE versions of functions in Windows system DLLs, which are denoted by 'A' and 'W' suffixes, respectively.
---

```
>>> cdll.LoadLibrary("libc.so.6")
<CDLL 'libc.so.6', handle ... at ...>
>>> libc = CDLL("libc.so.6")
>>> libc
<CDLL 'libc.so.6', handle ... at ...>
>>>

```

### Accessing functions from loaded dlls[¶](https://docs.python.org/3/library/ctypes.html#accessing-functions-from-loaded-dlls "Link to this heading")
Functions are accessed as attributes of dll objects:
>>>```
>>> libc.printf
<_FuncPtr object at 0x...>
>>> print(windll.kernel32.GetModuleHandleA)
<_FuncPtr object at 0x...>
>>> print(windll.kernel32.MyOwnFunction)
Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
 File "ctypes.py", line 239, in __getattr__
func = _StdcallFuncPtr(name, self)
AttributeError: function 'MyOwnFunction' not found
>>>

```

Note that win32 system dlls like `kernel32` and `user32` often export ANSI as well as UNICODE versions of a function. The UNICODE version is exported with a `W` appended to the name, while the ANSI version is exported with an `A` appended to the name. The win32 `GetModuleHandle` function, which returns a _module handle_ for a given module name, has the following C prototype, and a macro is used to expose one of them as `GetModuleHandle` depending on whether UNICODE is defined or not:
```
/* ANSI version */
HMODULE GetModuleHandleA(LPCSTR lpModuleName);
/* UNICODE version */
HMODULE GetModuleHandleW(LPCWSTR lpModuleName);

```

_windll_ does not try to select one of them by magic, you must access the version you need by specifying `GetModuleHandleA` or `GetModuleHandleW` explicitly, and then call it with bytes or string objects respectively.
Sometimes, dlls export functions with names which aren’t valid Python identifiers, like `"??2@YAPAXI@Z"`. In this case you have to use [`getattr()`](https://docs.python.org/3/library/functions.html#getattr "getattr") to retrieve the function:
>>>```
>>> getattr(cdll.msvcrt, "??2@YAPAXI@Z")
<_FuncPtr object at 0x...>
>>>

```

On Windows, some dlls export functions not by name but by ordinal. These functions can be accessed by indexing the dll object with the ordinal number:
>>>```
>>> cdll.kernel32[1]
<_FuncPtr object at 0x...>
>>> cdll.kernel32[0]
Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
 File "ctypes.py", line 310, in __getitem__
func = _StdcallFuncPtr(name, self)
AttributeError: function ordinal 0 not found
>>>

```

### Calling functions[¶](https://docs.python.org/3/library/ctypes.html#calling-functions "Link to this heading")
You can call these functions like any other Python callable. This example uses the `rand()` function, which takes no arguments and returns a pseudo-random integer:
>>>```
>>> print(libc.rand())
1804289383

```

On Windows, you can call the `GetModuleHandleA()` function, which returns a win32 module handle (passing `None` as single argument to call it with a `NULL` pointer):
>>>```
>>> print(hex(windll.kernel32.GetModuleHandleA(None)))
0x1d000000
>>>

```

[`ValueError`](https://docs.python.org/3/library/exceptions.html#ValueError "ValueError") is raised when you call an `stdcall` function with the `cdecl` calling convention, or vice versa:
>>>```
>>> cdll.kernel32.GetModuleHandleA(None)
Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
ValueError: Procedure probably called with not enough arguments (4 bytes missing)
>>>
>>> windll.msvcrt.printf(b"spam")
Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
ValueError: Procedure probably called with too many arguments (4 bytes in excess)
>>>

```

To find out the correct calling convention you have to look into the C header file or the documentation for the function you want to call.
On Windows, [`ctypes`](https://docs.python.org/3/library/ctypes.html#module-ctypes "ctypes: A foreign function library for Python.") uses win32 structured exception handling to prevent crashes from general protection faults when functions are called with invalid argument values:
>>>```
>>> windll.kernel32.GetModuleHandleA(32)
Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
OSError: exception: access violation reading 0x00000020
>>>