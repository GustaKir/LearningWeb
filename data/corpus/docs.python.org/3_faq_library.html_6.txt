Title: Effects of Operations on Reference Count and GIL in Python
URL: https://docs.python.org/3/faq/library.html
Summary: This section discusses how certain operations in Python can trigger the `__del__()` method of objects when their reference count drops to zero, especially during mass updates to dictionaries and lists. It highlights the importance of using a mutex in these situations. Additionally, it addresses the Global Interpreter Lock (GIL) and its impact on multi-threaded Python programs, noting that it restricts the use of multiple CPUs despite the acceptance of PEP 703.
---

```

Operations that replace other objects may invoke those other objects’ [`__del__()`](https://docs.python.org/3/reference/datamodel.html#object.__del__ "object.__del__") method when their reference count reaches zero, and that can affect things. This is especially true for the mass updates to dictionaries and lists. When in doubt, use a mutex!
### [Can’t we get rid of the Global Interpreter Lock?](https://docs.python.org/3/faq/library.html#id18)[¶](https://docs.python.org/3/faq/library.html#can-t-we-get-rid-of-the-global-interpreter-lock "Link to this heading")
The [global interpreter lock](https://docs.python.org/3/glossary.html#term-global-interpreter-lock) (GIL) is often seen as a hindrance to Python’s deployment on high-end multiprocessor server machines, because a multi-threaded Python program effectively only uses one CPU, due to the insistence that (almost) all Python code can only run while the GIL is held.
With the approval of [**PEP 703**](https://peps.python.org/pep-0703/) work is now underway to remove the GIL from the CPython implementation of Python. Initially it will be implemented as an optional compiler flag when building the interpreter, and so separate builds will be available with and without the GIL. Long-term, the hope is to settle on a single build, once the performance implications of removing the GIL are fully understood. Python 3.13 is likely to be the first release containing this work, although it may not be completely functional in this release.
The current work to remove the GIL is based on a [fork of Python 3.9 with the GIL removed](https://github.com/colesbury/nogil) by Sam Gross. Prior to that, in the days of Python 1.5, Greg Stein actually implemented a comprehensive patch set (the “free threading” patches) that removed the GIL and replaced it with fine-grained locking. Adam Olsen did a similar experiment in his [python-safethread](https://code.google.com/archive/p/python-safethread) project. Unfortunately, both of these earlier experiments exhibited a sharp drop in single-thread performance (at least 30% slower), due to the amount of fine-grained locking necessary to compensate for the removal of the GIL. The Python 3.9 fork is the first attempt at removing the GIL with an acceptable performance impact.
The presence of the GIL in current Python releases doesn’t mean that you can’t make good use of Python on multi-CPU machines! You just have to be creative with dividing the work up between multiple _processes_ rather than multiple _threads_. The [`ProcessPoolExecutor`](https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor "concurrent.futures.ProcessPoolExecutor") class in the new [`concurrent.futures`](https://docs.python.org/3/library/concurrent.futures.html#module-concurrent.futures "concurrent.futures: Execute computations concurrently using threads or processes.") module provides an easy way of doing so; the [`multiprocessing`](https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing "multiprocessing: Process-based parallelism.") module provides a lower-level API in case you want more control over dispatching of tasks.
Judicious use of C extensions will also help; if you use a C extension to perform a time-consuming task, the extension can release the GIL while the thread of execution is in the C code and allow other threads to get some work done. Some standard library modules such as [`zlib`](https://docs.python.org/3/library/zlib.html#module-zlib "zlib: Low-level interface to compression and decompression routines compatible with gzip.") and [`hashlib`](https://docs.python.org/3/library/hashlib.html#module-hashlib "hashlib: Secure hash and message digest algorithms.") already do this.
An alternative approach to reducing the impact of the GIL is to make the GIL a per-interpreter-state lock rather than truly global. This was [first implemented in Python 3.12](https://docs.python.org/3/whatsnew/3.12.html#whatsnew312-pep684) and is available in the C API. A Python interface to it is expected in Python 3.13. The main limitation to it at the moment is likely to be 3rd party extension modules, since these must be written with multiple interpreters in mind in order to be usable, so many older extension modules will not be usable.
## [Input and Output](https://docs.python.org/3/faq/library.html#id19)[¶](https://docs.python.org/3/faq/library.html#input-and-output "Link to this heading")
### [How do I delete a file? (And other file questions…)](https://docs.python.org/3/faq/library.html#id20)[¶](https://docs.python.org/3/faq/library.html#how-do-i-delete-a-file-and-other-file-questions "Link to this heading")
Use `os.remove(filename)` or `os.unlink(filename)`; for documentation, see the [`os`](https://docs.python.org/3/library/os.html#module-os "os: Miscellaneous operating system interfaces.") module. The two functions are identical; [`unlink()`](https://docs.python.org/3/library/os.html#os.unlink "os.unlink") is