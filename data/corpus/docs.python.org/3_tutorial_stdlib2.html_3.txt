Title: Logging in Python
URL: https://docs.python.org/3/tutorial/stdlib2.html
Summary: By default, informational and debugging messages in Python are suppressed and sent to standard error. Messages can also be routed through various outputs like email or sockets. Filters based on message priority such as DEBUG, INFO, WARNING, ERROR, and CRITICAL allow for customizable logging. The logging system can be configured directly in Python or through a user-editable configuration file.
---

```

By default, informational and debugging messages are suppressed and the output is sent to standard error. Other output options include routing messages through email, datagrams, sockets, or to an HTTP Server. New filters can select different routing based on message priority: [`DEBUG`](https://docs.python.org/3/library/logging.html#logging.DEBUG "logging.DEBUG"), [`INFO`](https://docs.python.org/3/library/logging.html#logging.INFO "logging.INFO"), [`WARNING`](https://docs.python.org/3/library/logging.html#logging.WARNING "logging.WARNING"), [`ERROR`](https://docs.python.org/3/library/logging.html#logging.ERROR "logging.ERROR"), and [`CRITICAL`](https://docs.python.org/3/library/logging.html#logging.CRITICAL "logging.CRITICAL").
The logging system can be configured directly from Python or can be loaded from a user editable configuration file for customized logging without altering the application.
## 11.6. Weak References[¶](https://docs.python.org/3/tutorial/stdlib2.html#weak-references "Link to this heading")
Python does automatic memory management (reference counting for most objects and [garbage collection](https://docs.python.org/3/glossary.html#term-garbage-collection) to eliminate cycles). The memory is freed shortly after the last reference to it has been eliminated.
This approach works fine for most applications but occasionally there is a need to track objects only as long as they are being used by something else. Unfortunately, just tracking them creates a reference that makes them permanent. The [`weakref`](https://docs.python.org/3/library/weakref.html#module-weakref "weakref: Support for weak references and weak dictionaries.") module provides tools for tracking objects without creating a reference. When the object is no longer needed, it is automatically removed from a weakref table and a callback is triggered for weakref objects. Typical applications include caching objects that are expensive to create:
>>>```
>>> importweakref,gc
>>> classA:
...   def__init__(self, value):
...     self.value = value
...   def__repr__(self):
...     return str(self.value)
...
>>> a = A(10)          # create a reference
>>> d = weakref.WeakValueDictionary()
>>> d['primary'] = a      # does not create a reference
>>> d['primary']        # fetch the object if it is still alive
10
>>> del a            # remove the one reference
>>> gc.collect()        # run garbage collection right away
0
>>> d['primary']        # entry was automatically removed
Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
d['primary']        # entry was automatically removed
 File "C:/python313/lib/weakref.py", line 46, in __getitem__
o = self.data[key]()
KeyError: 'primary'

```

## 11.7. Tools for Working with Lists[¶](https://docs.python.org/3/tutorial/stdlib2.html#tools-for-working-with-lists "Link to this heading")
Many data structure needs can be met with the built-in list type. However, sometimes there is a need for alternative implementations with different performance trade-offs.
The [`array`](https://docs.python.org/3/library/array.html#module-array "array: Space efficient arrays of uniformly typed numeric values.") module provides an [`array`](https://docs.python.org/3/library/array.html#array.array "array.array") object that is like a list that stores only homogeneous data and stores it more compactly. The following example shows an array of numbers stored as two byte unsigned binary numbers (typecode `"H"`) rather than the usual 16 bytes per entry for regular lists of Python int objects:
>>>```
>>> fromarrayimport array
>>> a = array('H', [4000, 10, 700, 22222])
>>> sum(a)
26932
>>> a[1:3]
array('H', [10, 700])

```

The [`collections`](https://docs.python.org/3/library/collections.html#module-collections "collections: Container datatypes") module provides a [`deque`](https://docs.python.org/3/library/collections.html#collections.deque "collections.deque") object that is like a list with faster appends and pops from the left side but slower lookups in the middle. These objects are well suited for implementing queues and breadth first tree searches:
>>>```
>>> fromcollectionsimport deque
>>> d = deque(["task1", "task2", "task3"])
>>> d.append("task4")
>>> print("Handling", d.popleft())
Handling task1

```

```
unsearched = deque([starting_node])
defbreadth_first_search(unsearched):
  node = unsearched.popleft()
  for m in gen_moves(node):
    if is_goal(m):
      return m
    unsearched.append(m)

```

In addition to alternative list implementations, the library also offers other tools such as the [`bisect`](https://docs.python.org/3/library/bisect.html#module-bisect "bisect: Array bisection algorithms for binary searching.") module with functions for manipulating sorted lists:
>>>