Title: Memory Alignment and Inheritance in Python C API Types
URL: https://docs.python.org/3/c-api/typeobj.html
Summary: This section discusses the importance of memory alignment for `tp_basicsize` and `tp_itemsize` in Python C API types, particularly when using structs that include `PyObject_HEAD`. It emphasizes that alignment must match the data types used, especially for variable items like doubles. Additionally, it notes that inheritance of these fields occurs separately by subtypes, with `PyType_Ready()` copying values from the base type when necessary.
---

a multiple of `_Alignof(PyObject)`. When using `sizeof` on a `struct` that includes [`PyObject_HEAD`](https://docs.python.org/3/c-api/structures.html#c.PyObject_HEAD "PyObject_HEAD"), as recommended, the compiler ensures this. When not using a C `struct`, or when using compiler extensions like `__attribute__((packed))`, it is up to you.
  * If the variable items require a particular alignment, `tp_basicsize` and `tp_itemsize` must each be a multiple of that alignment. For example, if a type’s variable part stores a `double`, it is your responsibility that both fields are a multiple of `_Alignof(double)`.


**Inheritance:**
These fields are inherited separately by subtypes. (That is, if the field is set to zero, [`PyType_Ready()`](https://docs.python.org/3/c-api/type.html#c.PyType_Ready "PyType_Ready") will copy the value from the base type, indicating that the instances do not need additional storage.)
If the base type has a non-zero [`tp_itemsize`](https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_itemsize "PyTypeObject.tp_itemsize"), it is generally not safe to set [`tp_itemsize`](https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_itemsize "PyTypeObject.tp_itemsize") to a different non-zero value in a subtype (though this depends on the implementation of the base type). 

[destructor](https://docs.python.org/3/c-api/typeobj.html#c.destructor "destructor")[PyTypeObject](https://docs.python.org/3/c-api/type.html#c.PyTypeObject "PyTypeObject").tp_dealloc[¶](https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_dealloc "Link to this definition")
    
A pointer to the instance destructor function. This function must be defined unless the type guarantees that its instances will never be deallocated (as is the case for the singletons `None` and `Ellipsis`). The function signature is:
```
voidtp_dealloc(PyObject*self);

```

The destructor function is called by the [`Py_DECREF()`](https://docs.python.org/3/c-api/refcounting.html#c.Py_DECREF "Py_DECREF") and [`Py_XDECREF()`](https://docs.python.org/3/c-api/refcounting.html#c.Py_XDECREF "Py_XDECREF") macros when the new reference count is zero. At this point, the instance is still in existence, but there are no references to it. The destructor function should free all references which the instance owns, free all memory buffers owned by the instance (using the freeing function corresponding to the allocation function used to allocate the buffer), and call the type’s [`tp_free`](https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_free "PyTypeObject.tp_free") function. If the type is not subtypable (doesn’t have the [`Py_TPFLAGS_BASETYPE`](https://docs.python.org/3/c-api/typeobj.html#c.Py_TPFLAGS_BASETYPE "Py_TPFLAGS_BASETYPE") flag bit set), it is permissible to call the object deallocator directly instead of via [`tp_free`](https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_free "PyTypeObject.tp_free"). The object deallocator should be the one used to allocate the instance; this is normally [`PyObject_Del()`](https://docs.python.org/3/c-api/allocation.html#c.PyObject_Del "PyObject_Del") if the instance was allocated using [`PyObject_New`](https://docs.python.org/3/c-api/allocation.html#c.PyObject_New "PyObject_New") or [`PyObject_NewVar`](https://docs.python.org/3/c-api/allocation.html#c.PyObject_NewVar "PyObject_NewVar"), or [`PyObject_GC_Del()`](https://docs.python.org/3/c-api/gcsupport.html#c.PyObject_GC_Del "PyObject_GC_Del") if the instance was allocated using [`PyObject_GC_New`](https://docs.python.org/3/c-api/gcsupport.html#c.PyObject_GC_New "PyObject_GC_New") or [`PyObject_GC_NewVar`](https://docs.python.org/3/c-api/gcsupport.html#c.PyObject_GC_NewVar "PyObject_GC_NewVar").
If the type supports garbage collection (has the [`Py_TPFLAGS_HAVE_GC`](https://docs.python.org/3/c-api/typeobj.html#c.Py_TPFLAGS_HAVE_GC "Py_TPFLAGS_HAVE_GC") flag bit set), the destructor should call [`PyObject_GC_UnTrack()`](https://docs.python.org/3/c-api/gcsupport.html#c.PyObject_GC_UnTrack "PyObject_GC_UnTrack") before clearing any member fields.
```
staticvoidfoo_dealloc(foo_object*self){
PyObject_GC_UnTrack(self);
Py_CLEAR(self->ref);
Py_TYPE(self)->tp_free((PyObject*)self);
}

```

Finally, if the type is heap allocated ([`Py_TPFLAGS_HEAPTYPE`](https://docs.python.org/3/c-api/typeobj.html#c.Py_TPFLAGS_HEAPTYPE "Py_TPFLAGS_HEAPTYPE")), the deallocator should release the owned reference to its type object (via [`Py_DECREF()`](https://docs.python.org/3/c-api/refcounting.html#c.Py_DECREF "Py_DECREF")) after calling the type deallocator. In order to avoid dangling pointers, the recommended way to achieve this is:
```
staticvoidfoo_dealloc(foo_object*self){
PyTypeObject*tp=Py_TYPE(self);
// free references and buffers here
tp->tp_free(self);
Py_DECREF(tp);
}