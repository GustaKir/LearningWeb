Title: Using relative_to with PurePath
URL: https://docs.python.org/3/library/pathlib.html
Summary: The `relative_to` method in `PurePath` demonstrates how to derive relative paths. It can raise a ValueError if the paths are on different drives or if one is relative and the other is absolute. The `walk_up` option, introduced in version 3.12, allows traversal up the path hierarchy, but users should ensure there are no symlinks by resolving paths first.
---

```
>>> p.relative_to('/usr', walk_up=True)
PurePosixPath('../etc/passwd')
>>> p.relative_to('foo', walk_up=True)
Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
 File "pathlib.py", line 941, in relative_to
raise ValueError(error_message.format(str(self), str(formatted)))
ValueError: '/etc/passwd' is not on the same drive as 'foo' OR one path is relative and the other is absolute.

```

Warning
This function is part of [`PurePath`](https://docs.python.org/3/library/pathlib.html#pathlib.PurePath "pathlib.PurePath") and works with strings. It does not check or access the underlying file structure. This can impact the _walk_up_ option as it assumes that no symlinks are present in the path; call [`resolve()`](https://docs.python.org/3/library/pathlib.html#pathlib.Path.resolve "pathlib.Path.resolve") first if necessary to resolve symlinks.
Changed in version 3.12: The _walk_up_ parameter was added (old behavior is the same as `walk_up=False`).
Deprecated since version 3.12, will be removed in version 3.14: Passing additional positional arguments is deprecated; if supplied, they are joined with _other_. 

PurePath.with_name(_name_)[¶](https://docs.python.org/3/library/pathlib.html#pathlib.PurePath.with_name "Link to this definition")
    
Return a new path with the [`name`](https://docs.python.org/3/library/pathlib.html#pathlib.PurePath.name "pathlib.PurePath.name") changed. If the original path doesn’t have a name, ValueError is raised:
>>>```
>>> p = PureWindowsPath('c:/Downloads/pathlib.tar.gz')
>>> p.with_name('setup.py')
PureWindowsPath('c:/Downloads/setup.py')
>>> p = PureWindowsPath('c:/')
>>> p.with_name('setup.py')
Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
 File "/home/antoine/cpython/default/Lib/pathlib.py", line 751, in with_name
raise ValueError("%r has an empty name" % (self,))
ValueError: PureWindowsPath('c:/') has an empty name

```


PurePath.with_stem(_stem_)[¶](https://docs.python.org/3/library/pathlib.html#pathlib.PurePath.with_stem "Link to this definition")
    
Return a new path with the [`stem`](https://docs.python.org/3/library/pathlib.html#pathlib.PurePath.stem "pathlib.PurePath.stem") changed. If the original path doesn’t have a name, ValueError is raised:
>>>```
>>> p = PureWindowsPath('c:/Downloads/draft.txt')
>>> p.with_stem('final')
PureWindowsPath('c:/Downloads/final.txt')
>>> p = PureWindowsPath('c:/Downloads/pathlib.tar.gz')
>>> p.with_stem('lib')
PureWindowsPath('c:/Downloads/lib.gz')
>>> p = PureWindowsPath('c:/')
>>> p.with_stem('')
Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
 File "/home/antoine/cpython/default/Lib/pathlib.py", line 861, in with_stem
return self.with_name(stem + self.suffix)
 File "/home/antoine/cpython/default/Lib/pathlib.py", line 851, in with_name
raise ValueError("%r has an empty name" % (self,))
ValueError: PureWindowsPath('c:/') has an empty name

```

Added in version 3.9. 

PurePath.with_suffix(_suffix_)[¶](https://docs.python.org/3/library/pathlib.html#pathlib.PurePath.with_suffix "Link to this definition")
    
Return a new path with the [`suffix`](https://docs.python.org/3/library/pathlib.html#pathlib.PurePath.suffix "pathlib.PurePath.suffix") changed. If the original path doesn’t have a suffix, the new _suffix_ is appended instead. If the _suffix_ is an empty string, the original suffix is removed:
>>>```
>>> p = PureWindowsPath('c:/Downloads/pathlib.tar.gz')
>>> p.with_suffix('.bz2')
PureWindowsPath('c:/Downloads/pathlib.tar.bz2')
>>> p = PureWindowsPath('README')
>>> p.with_suffix('.txt')
PureWindowsPath('README.txt')
>>> p = PureWindowsPath('README.txt')
>>> p.with_suffix('')
PureWindowsPath('README')

```


PurePath.with_segments(_* pathsegments_)[¶](https://docs.python.org/3/library/pathlib.html#pathlib.PurePath.with_segments "Link to this definition")
    
Create a new path object of the same type by combining the given _pathsegments_. This method is called whenever a derivative path is created, such as from [`parent`](https://docs.python.org/3/library/pathlib.html#pathlib.PurePath.parent "pathlib.PurePath.parent") and [`relative_to()`](https://docs.python.org/3/library/pathlib.html#pathlib.PurePath.relative_to "pathlib.PurePath.relative_to"). Subclasses may override this method to pass information to derivative paths, for example:
```
frompathlibimport PurePosixPath
classMyPath(PurePosixPath):
  def__init__(self, *pathsegments, session_id):
    super().__init__(*pathsegments)
    self.session_id = session_id
  defwith_segments(self, *pathsegments):
    return type(self)(*pathsegments, session_id=self.session_id)
etc = MyPath('/etc', session_id=42)
hosts = etc / 'hosts'
print(hosts.session_id) # 42