Title: Using __match_args__ for Pattern Matching in Python
URL: https://docs.python.org/3/reference/datamodel.html
Summary: __match_args__ is a class variable that assigns a tuple of strings, allowing positional arguments to be used as keyword arguments in class patterns. For instance, with __match_args__ set to ('left', 'center', 'right'), MyClass(x, y) translates to MyClass(left=x, center=y). This feature is available since Python 3.10 and is related to PEP 634.
---

object.__match_args__[¶](https://docs.python.org/3/reference/datamodel.html#object.__match_args__ "Link to this definition")
    
This class variable can be assigned a tuple of strings. When this class is used in a class pattern with positional arguments, each positional argument will be converted into a keyword argument, using the corresponding value in ___match_args___ as the keyword. The absence of this attribute is equivalent to setting it to `()`.
For example, if `MyClass.__match_args__` is `("left", "center", "right")` that means that `case MyClass(x, y)` is equivalent to `case MyClass(left=x, center=y)`. Note that the number of arguments in the pattern must be smaller than or equal to the number of elements in ___match_args___ ; if it is larger, the pattern match attempt will raise a [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError "TypeError").
Added in version 3.10.
See also 

[**PEP 634**](https://peps.python.org/pep-0634/) - Structural Pattern Matching
    
The specification for the Python `match` statement.
### 3.3.11. Emulating buffer types[¶](https://docs.python.org/3/reference/datamodel.html#emulating-buffer-types "Link to this heading")
The [buffer protocol](https://docs.python.org/3/c-api/buffer.html#bufferobjects) provides a way for Python objects to expose efficient access to a low-level memory array. This protocol is implemented by builtin types such as [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "bytes") and [`memoryview`](https://docs.python.org/3/library/stdtypes.html#memoryview "memoryview"), and third-party libraries may define additional buffer types.
While buffer types are usually implemented in C, it is also possible to implement the protocol in Python. 

object.__buffer__(_self_ , _flags_)[¶](https://docs.python.org/3/reference/datamodel.html#object.__buffer__ "Link to this definition")
    
Called when a buffer is requested from _self_ (for example, by the [`memoryview`](https://docs.python.org/3/library/stdtypes.html#memoryview "memoryview") constructor). The _flags_ argument is an integer representing the kind of buffer requested, affecting for example whether the returned buffer is read-only or writable. [`inspect.BufferFlags`](https://docs.python.org/3/library/inspect.html#inspect.BufferFlags "inspect.BufferFlags") provides a convenient way to interpret the flags. The method must return a [`memoryview`](https://docs.python.org/3/library/stdtypes.html#memoryview "memoryview") object. 

object.__release_buffer__(_self_ , _buffer_)[¶](https://docs.python.org/3/reference/datamodel.html#object.__release_buffer__ "Link to this definition")
    
Called when a buffer is no longer needed. The _buffer_ argument is a [`memoryview`](https://docs.python.org/3/library/stdtypes.html#memoryview "memoryview") object that was previously returned by [`__buffer__()`](https://docs.python.org/3/reference/datamodel.html#object.__buffer__ "object.__buffer__"). The method must release any resources associated with the buffer. This method should return `None`. Buffer objects that do not need to perform any cleanup are not required to implement this method.
Added in version 3.12.
See also 

[**PEP 688**](https://peps.python.org/pep-0688/) - Making the buffer protocol accessible in Python
    
Introduces the Python `__buffer__` and `__release_buffer__` methods. 

[`collections.abc.Buffer`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Buffer "collections.abc.Buffer")
    
ABC for buffer types.
### 3.3.12. Special method lookup[¶](https://docs.python.org/3/reference/datamodel.html#special-method-lookup "Link to this heading")
For custom classes, implicit invocations of special methods are only guaranteed to work correctly if defined on an object’s type, not in the object’s instance dictionary. That behaviour is the reason why the following code raises an exception:
>>>```
>>> classC:
...   pass
...
>>> c = C()
>>> c.__len__ = lambda: 5
>>> len(c)
Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
TypeError: object of type 'C' has no len()

```

The rationale behind this behaviour lies with a number of special methods such as [`__hash__()`](https://docs.python.org/3/reference/datamodel.html#object.__hash__ "object.__hash__") and [`__repr__()`](https://docs.python.org/3/reference/datamodel.html#object.__repr__ "object.__repr__") that are implemented by all objects, including type objects. If the implicit lookup of these methods used the conventional lookup process, they would fail when invoked on the type object itself:
>>>```
>>> 1 .__hash__() == hash(1)
True
>>> int.__hash__() == hash(int)
Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
TypeError: descriptor '__hash__' of 'int' object needs an argument