Title: iOS Integration for Python Modules
URL: https://docs.python.org/3/using/ios.html
Summary: This section explains how to properly distribute binary Python modules for iOS applications, detailing the required framework structure, including the use of `Info.plist` files and marker files to identify and manage module locations within the app bundle.
---

.
For example, consider the case of an import `from foo.bar import _whiz`, where `_whiz` is implemented with the binary module `sources/foo/bar/_whiz.abi3.so`, with `sources` being the location registered on `sys.path`, relative to the application bundle. This module _must_ be distributed as `Frameworks/foo.bar._whiz.framework/foo.bar._whiz` (creating the framework name from the full import path of the module), with an `Info.plist` file in the `.framework` directory identifying the binary as a framework. The `foo.bar._whiz` module would be represented in the original location with a `sources/foo/bar/_whiz.abi3.fwork` marker file, containing the path `Frameworks/foo.bar._whiz/foo.bar._whiz`. The framework would also contain `Frameworks/foo.bar._whiz.framework/foo.bar._whiz.origin`, containing the path to the `.fwork` file.
When running on iOS, the Python interpreter will install an [`AppleFrameworkLoader`](https://docs.python.org/3/library/importlib.html#importlib.machinery.AppleFrameworkLoader "importlib.machinery.AppleFrameworkLoader") that is able to read and import `.fwork` files. Once imported, the `__file__` attribute of the binary module will report as the location of the `.fwork` file. However, the [`ModuleSpec`](https://docs.python.org/3/library/importlib.html#importlib.machinery.ModuleSpec "importlib.machinery.ModuleSpec") for the loaded module will report the `origin` as the location of the binary in the framework folder.
### 7.1.5. Compiler stub binaries[¶](https://docs.python.org/3/using/ios.html#compiler-stub-binaries "Link to this heading")
Xcode doesn’t expose explicit compilers for iOS; instead, it uses an `xcrun` script that resolves to a full compiler path (e.g., `xcrun --sdk iphoneos clang` to get the `clang` for an iPhone device). However, using this script poses two problems:
  * The output of `xcrun` includes paths that are machine specific, resulting in a sysconfig module that cannot be shared between users; and
  * It results in `CC`/`CPP`/`LD`/`AR` definitions that include spaces. There is a lot of C ecosystem tooling that assumes that you can split a command line at the first space to get the path to the compiler executable; this isn’t the case when using `xcrun`.