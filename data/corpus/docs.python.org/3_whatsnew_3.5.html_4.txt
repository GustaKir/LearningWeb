Title: Introduction of await and async for in Python 3.5
URL: https://docs.python.org/3/whatsnew/3.5.html
Summary: Python 3.5 introduces the `await` expression to suspend coroutine execution until a result is available, applicable to objects that implement the awaitable protocol. Additionally, PEP 492 introduces the `async for` statement for iterating over asynchronous iterables, demonstrated with an example of a rudimentary HTTP client.
---

```

Inside a coroutine function, the new [`await`](https://docs.python.org/3/reference/expressions.html#await) expression can be used to suspend coroutine execution until the result is available. Any object can be _awaited_ , as long as it implements the [awaitable](https://docs.python.org/3/glossary.html#term-awaitable) protocol by defining the `__await__()` method.
PEP 492 also adds [`async for`](https://docs.python.org/3/reference/compound_stmts.html#async-for) statement for convenient iteration over asynchronous iterables.
An example of a rudimentary HTTP client written using the new syntax:
```
importasyncio
async defhttp_get(domain):
  reader, writer = await asyncio.open_connection(domain, 80)
  writer.write(b'\r\n'.join([
    b'GET / HTTP/1.1',
    b'Host: %b' % domain.encode('latin-1'),
    b'Connection: close',
    b'', b''
  ]))
  async for line in reader:
    print('>>>', line)
  writer.close()
loop = asyncio.get_event_loop()
try:
  loop.run_until_complete(http_get('example.com'))
finally:
  loop.close()

```

Similarly to asynchronous iteration, there is a new syntax for asynchronous context managers. The following script:
```
importasyncio
async defcoro(name, lock):
  print('coro {}: waiting for lock'.format(name))
  async with lock:
    print('coro {}: holding the lock'.format(name))
    await asyncio.sleep(1)
    print('coro {}: releasing the lock'.format(name))
loop = asyncio.get_event_loop()
lock = asyncio.Lock()
coros = asyncio.gather(coro(1, lock), coro(2, lock))
try:
  loop.run_until_complete(coros)
finally:
  loop.close()

```

will output:
```
coro 2: waiting for lock
coro 2: holding the lock
coro 1: waiting for lock
coro 2: releasing the lock
coro 1: holding the lock
coro 1: releasing the lock

```

Note that both [`async for`](https://docs.python.org/3/reference/compound_stmts.html#async-for) and [`async with`](https://docs.python.org/3/reference/compound_stmts.html#async-with) can only be used inside a coroutine function declared with [`async def`](https://docs.python.org/3/reference/compound_stmts.html#async-def).
Coroutine functions are intended to be run inside a compatible event loop, such as the [asyncio loop](https://docs.python.org/3/library/asyncio-eventloop.html#asyncio-event-loop).
Note
Changed in version 3.5.2: Starting with CPython 3.5.2, `__aiter__` can directly return [asynchronous iterators](https://docs.python.org/3/glossary.html#term-asynchronous-iterator). Returning an [awaitable](https://docs.python.org/3/glossary.html#term-awaitable) object will result in a [`PendingDeprecationWarning`](https://docs.python.org/3/library/exceptions.html#PendingDeprecationWarning "PendingDeprecationWarning").
See more details in the [Asynchronous Iterators](https://docs.python.org/3/reference/datamodel.html#async-iterators) documentation section.
See also 

[**PEP 492**](https://peps.python.org/pep-0492/) â€“ Coroutines with async and await syntax
    
PEP written and implemented by Yury Selivanov.
### PEP 465 - A dedicated infix operator for matrix multiplication[Â¶](https://docs.python.org/3/whatsnew/3.5.html#pep-465-a-dedicated-infix-operator-for-matrix-multiplication "Link to this heading")
[**PEP 465**](https://peps.python.org/pep-0465/) adds the `@` infix operator for matrix multiplication. Currently, no builtin Python types implement the new operator, however, it can be implemented by defining `__matmul__()`, `__rmatmul__()`, and `__imatmul__()` for regular, reflected, and in-place matrix multiplication. The semantics of these methods is similar to that of methods defining other infix arithmetic operators.
Matrix multiplication is a notably common operation in many fields of mathematics, science, engineering, and the addition of `@` allows writing cleaner code:
```
S = (H @ beta - r).T @ inv(H @ V @ H.T) @ (H @ beta - r)

```

instead of:
```
S = dot((dot(H, beta) - r).T,
    dot(inv(dot(dot(H, V), H.T)), dot(H, beta) - r))

```

NumPy 1.10 has support for the new operator:
>>>```
>>> importnumpy
>>> x = numpy.ones(3)
>>> x
array([ 1., 1., 1.])
>>> m = numpy.eye(3)
>>> m
array([[ 1., 0., 0.],
    [ 0., 1., 0.],
    [ 0., 0., 1.]])
>>> x @ m
array([ 1., 1., 1.])

```

See also 

[**PEP 465**](https://peps.python.org/pep-0465/) â€“ A dedicated infix operator for matrix multiplication
    
PEP written by Nathaniel J. Smith; implemented by Benjamin Peterson.
### PEP 448 - Additional Unpacking Generalizations[Â¶](https://docs.python.org/3/whatsnew/3.5.html#pep-448-additional-unpacking-generalizations "Link to this heading")
[**PEP 448**](https://peps.python.org/pep-0448/) extends the allowed uses of the `*` iterable unpacking operator and `**` dictionary unpacking operator. It is now possible to use an arbitrary number of unpackings in [function calls](https://docs.python.org/3/reference/expressions.html#calls):
>>>```
>>> print(*[1], *[2], 3, *[4, 5])
1 2 3 4 5
>>> deffn(a, b, c, d):
...   print(a, b, c, d)
...
>>> fn(**{'a': 1, 'c': 3}, **{'b': 2, 'd': 4})
1 2 3 4