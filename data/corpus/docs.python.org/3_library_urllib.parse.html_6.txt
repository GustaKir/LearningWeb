Title: Using urllib.parse.unwrap and URL Parsing Security
URL: https://docs.python.org/3/library/urllib.parse.html
Summary: The `unwrap()` function extracts URLs from various wrapped formats and returns them unchanged if not wrapped. Additionally, the `urlsplit()` and `urlparse()` APIs do not validate inputs, potentially allowing non-standard URLs to be processed without errors, prioritizing practical functionality over strict validation.
---

urllib.parse.unwrap(_url_)[¶](https://docs.python.org/3/library/urllib.parse.html#urllib.parse.unwrap "Link to this definition")
    
Extract the url from a wrapped URL (that is, a string formatted as `<URL:scheme://host/path>`, `<scheme://host/path>`, `URL:scheme://host/path` or `scheme://host/path`). If _url_ is not a wrapped URL, it is returned without changes.
## URL parsing security[¶](https://docs.python.org/3/library/urllib.parse.html#url-parsing-security "Link to this heading")
The [`urlsplit()`](https://docs.python.org/3/library/urllib.parse.html#urllib.parse.urlsplit "urllib.parse.urlsplit") and [`urlparse()`](https://docs.python.org/3/library/urllib.parse.html#urllib.parse.urlparse "urllib.parse.urlparse") APIs do not perform **validation** of inputs. They may not raise errors on inputs that other applications consider invalid. They may also succeed on some inputs that might not be considered URLs elsewhere. Their purpose is for practical functionality rather than purity.
Instead of raising an exception on unusual input, they may instead return some component parts as empty strings. Or components may contain more than perhaps they should.
We recommend that users of these APIs where the values may be used anywhere with security implications code defensively. Do some verification within your code before trusting a returned component part. Does that `scheme` make sense? Is that a sensible `path`? Is there anything strange about that `hostname`? etc.
What constitutes a URL is not universally well defined. Different applications have different needs and desired constraints. For instance the living [WHATWG spec](https://url.spec.whatwg.org/#concept-basic-url-parser) describes what user facing web clients such as a web browser require. While [**RFC 3986**](https://datatracker.ietf.org/doc/html/rfc3986.html) is more general. These functions incorporate some aspects of both, but cannot be claimed compliant with either. The APIs and existing user code with expectations on specific behaviors predate both standards leading us to be very cautious about making API behavior changes.
## Parsing ASCII Encoded Bytes[¶](https://docs.python.org/3/library/urllib.parse.html#parsing-ascii-encoded-bytes "Link to this heading")
The URL parsing functions were originally designed to operate on character strings only. In practice, it is useful to be able to manipulate properly quoted and encoded URLs as sequences of ASCII bytes. Accordingly, the URL parsing functions in this module all operate on [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "bytes") and [`bytearray`](https://docs.python.org/3/library/stdtypes.html#bytearray "bytearray") objects in addition to [`str`](https://docs.python.org/3/library/stdtypes.html#str "str") objects.
If [`str`](https://docs.python.org/3/library/stdtypes.html#str "str") data is passed in, the result will also contain only [`str`](https://docs.python.org/3/library/stdtypes.html#str "str") data. If [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "bytes") or [`bytearray`](https://docs.python.org/3/library/stdtypes.html#bytearray "bytearray") data is passed in, the result will contain only [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "bytes") data.
Attempting to mix [`str`](https://docs.python.org/3/library/stdtypes.html#str "str") data with [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "bytes") or [`bytearray`](https://docs.python.org/3/library/stdtypes.html#bytearray "bytearray") in a single function call will result in a [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError "TypeError") being raised, while attempting to pass in non-ASCII byte values will trigger [`UnicodeDecodeError`](https://docs.python.org/3/library/exceptions.html#UnicodeDecodeError "UnicodeDecodeError").
To support easier conversion of result objects between [`str`](https://docs.python.org/3/library/stdtypes.html#str "str") and [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "bytes"), all return values from URL parsing functions provide either an `encode()` method (when the result contains [`str`](https://docs.python.org/3/library/stdtypes.html#str "str") data) or a `decode()` method (when the result contains [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "bytes") data). The signatures of these methods match those of the corresponding [`str`](https://docs.python.org/3/library/stdtypes.html#str "str") and [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "bytes") methods (except that the default encoding is `'ascii'` rather than `'utf-8'`). Each produces a value of a corresponding type that contains either [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "bytes") data (for `encode()` methods) or [`str`](https://docs.python.org/3/library/stdtypes.html#str "str") data (for `decode()` methods).
Applications that need to operate on potentially improperly quoted URLs that ma