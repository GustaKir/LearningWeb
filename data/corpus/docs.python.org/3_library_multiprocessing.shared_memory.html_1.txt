Title: SharedMemory Class in Python's multiprocessing Module
URL: https://docs.python.org/3/library/multiprocessing.shared_memory.html
Summary: The `SharedMemory` class in Python's multiprocessing module allows for the creation of shared memory blocks. It provides functionality for processes to create or attach to memory blocks identified by unique names, facilitating data sharing across processes. Shared memory blocks can persist beyond the lifetime of their creator process, and proper management involves using methods like `close()` for cleanup.
---

_class_ multiprocessing.shared_memory.SharedMemory(_name =None_, _create =False_, _size =0_, _*_ , _track =True_)[¶](https://docs.python.org/3/library/multiprocessing.shared_memory.html#multiprocessing.shared_memory.SharedMemory "Link to this definition")
    
Create an instance of the `SharedMemory` class for either creating a new shared memory block or attaching to an existing shared memory block. Each shared memory block is assigned a unique name. In this way, one process can create a shared memory block with a particular name and a different process can attach to that same shared memory block using that same name.
As a resource for sharing data across processes, shared memory blocks may outlive the original process that created them. When one process no longer needs access to a shared memory block that might still be needed by other processes, the [`close()`](https://docs.python.org/3/library/multiprocessing.shared_memory.html#multiprocessing.shared_memory.SharedMemory.close "multiprocessing.shared_memory.SharedMemory.close") method should be called. When a shared memory block is no longer needed by any process, the [`unlink()`](https://docs.python.org/3/library/multiprocessing.shared_memory.html#multiprocessing.shared_memory.SharedMemory.unlink "multiprocessing.shared_memory.SharedMemory.unlink") method should be called to ensure proper cleanup. 

Parameters:
    
  * **name** ([_str_](https://docs.python.org/3/library/stdtypes.html#str "str") _|__None_) – The unique name for the requested shared memory, specified as a string. When creating a new shared memory block, if `None` (the default) is supplied for the name, a novel name will be generated.
  * **create** ([_bool_](https://docs.python.org/3/library/functions.html#bool "bool")) – Control whether a new shared memory block is created (`True`) or an existing shared memory block is attached (`False`).
  * **size** ([_int_](https://docs.python.org/3/library/functions.html#int "int")) – The requested number of bytes when creating a new shared memory block. Because some platforms choose to allocate chunks of memory based upon that platform’s memory page size, the exact size of the shared memory block may be larger or equal to the size requested. When attaching to an existing shared memory block, the _size_ parameter is ignored.
  * **track** ([_bool_](https://docs.python.org/3/library/functions.html#bool "bool")) – When `True`, register the shared memory block with a resource tracker process on platforms where the OS does not do this automatically. The resource tracker ensures proper cleanup of the shared memory even if all other processes with access to the memory exit without doing so. Python processes created from a common ancestor using [`multiprocessing`](https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing "multiprocessing: Process-based parallelism.") facilities share a single resource tracker process, and the lifetime of shared memory segments is handled automatically among these processes. Python processes created in any other way will receive their own resource tracker when accessing shared memory with _track_ enabled. This will cause the shared memory to be deleted by the resource tracker of the first process that terminates. To avoid this issue, users of [`subprocess`](https://docs.python.org/3/library/subprocess.html#module-subprocess "subprocess: Subprocess management.") or standalone Python processes should set _track_ to `False` when there is already another process in place that does the bookkeeping. _track_ is ignored on Windows, which has its own tracking and automatically deletes shared memory when all handles to it have been closed.


Changed in version 3.13: Added the _track_ parameter. 

close()[¶](https://docs.python.org/3/library/multiprocessing.shared_memory.html#multiprocessing.shared_memory.SharedMemory.close "Link to this definition")
    
Close the file descriptor/handle to the shared memory from this instance. [`close()`](https://docs.python.org/3/library/multiprocessing.shared_memory.html#multiprocessing.shared_memory.SharedMemory.close "multiprocessing.shared_memory.SharedMemory.close") should be called once access to the shared memory block from this instance is no longer needed. Depending on operating system, the underlying memory may or may not be freed even if all handles to it have been closed. To ensure proper cleanup, use the [`unlink()`](https://docs.python.org/3/library/multiprocessing.shared_memory.html#multiprocessing.shared_memory.SharedMemory.unlink "multiprocessing.shared_memory.SharedMemory.unlink") method.