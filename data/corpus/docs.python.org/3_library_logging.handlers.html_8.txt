Title: Security Considerations for Pickling in Socket Handlers
URL: https://docs.python.org/3/library/logging.handlers.html
Summary: This section discusses security risks associated with pickling in the logging.handlers module. It suggests overriding methods for enhanced security, such as signing pickles with HMAC and disabling unpickling of global objects. It also describes the 'send' method for transmitting pickled byte-strings to sockets, noting its capacity for partial sends due to network conditions.
---

```

Note that pickles aren’t completely secure. If you are concerned about security, you may want to override this method to implement a more secure mechanism. For example, you can sign pickles using HMAC and then verify them on the receiving end, or alternatively you can disable unpickling of global objects on the receiving end. 

send(_packet_)[¶](https://docs.python.org/3/library/logging.handlers.html#logging.handlers.SocketHandler.send "Link to this definition")
    
Send a pickled byte-string _packet_ to the socket. The format of the sent byte-string is as described in the documentation for [`makePickle()`](https://docs.python.org/3/library/logging.handlers.html#logging.handlers.SocketHandler.makePickle "logging.handlers.SocketHandler.makePickle").
This function allows for partial sends, which can happen when the network is busy. 

createSocket()[¶](https://docs.python.org/3/library/logging.handlers.html#logging.handlers.SocketHandler.createSocket "Link to this definition")
    
Tries to create a socket; on failure, uses an exponential back-off algorithm. On initial failure, the handler will drop the message it was trying to send. When subsequent messages are handled by the same instance, it will not try connecting until some time has passed. The default parameters are such that the initial delay is one second, and if after that delay the connection still can’t be made, the handler will double the delay each time up to a maximum of 30 seconds.
This behaviour is controlled by the following handler attributes:
  * `retryStart` (initial delay, defaulting to 1.0 seconds).
  * `retryFactor` (multiplier, defaulting to 2.0).
  * `retryMax` (maximum delay, defaulting to 30.0 seconds).


This means that if the remote listener starts up _after_ the handler has been used, you could lose messages (since the handler won’t even attempt a connection until the delay has elapsed, but just silently drop messages during the delay period).
## DatagramHandler[¶](https://docs.python.org/3/library/logging.handlers.html#datagramhandler "Link to this heading")
The [`DatagramHandler`](https://docs.python.org/3/library/logging.handlers.html#logging.handlers.DatagramHandler "logging.handlers.DatagramHandler") class, located in the [`logging.handlers`](https://docs.python.org/3/library/logging.handlers.html#module-logging.handlers "logging.handlers: Handlers for the logging module.") module, inherits from [`SocketHandler`](https://docs.python.org/3/library/logging.handlers.html#logging.handlers.SocketHandler "logging.handlers.SocketHandler") to support sending logging messages over UDP sockets. 

_class_ logging.handlers.DatagramHandler(_host_ , _port_)[¶](https://docs.python.org/3/library/logging.handlers.html#logging.handlers.DatagramHandler "Link to this definition")
    
Returns a new instance of the [`DatagramHandler`](https://docs.python.org/3/library/logging.handlers.html#logging.handlers.DatagramHandler "logging.handlers.DatagramHandler") class intended to communicate with a remote machine whose address is given by _host_ and _port_.
Note
As UDP is not a streaming protocol, there is no persistent connection between an instance of this handler and _host_. For this reason, when using a network socket, a DNS lookup might have to be made each time an event is logged, which can introduce some latency into the system. If this affects you, you can do a lookup yourself and initialize this handler using the looked-up IP address rather than the hostname.
Changed in version 3.4: If `port` is specified as `None`, a Unix domain socket is created using the value in `host` - otherwise, a UDP socket is created. 

emit()[¶](https://docs.python.org/3/library/logging.handlers.html#logging.handlers.DatagramHandler.emit "Link to this definition")
    
Pickles the record’s attribute dictionary and writes it to the socket in binary format. If there is an error with the socket, silently drops the packet. To unpickle the record at the receiving end into a [`LogRecord`](https://docs.python.org/3/library/logging.html#logging.LogRecord "logging.LogRecord"), use the [`makeLogRecord()`](https://docs.python.org/3/library/logging.html#logging.makeLogRecord "logging.makeLogRecord") function. 

makeSocket()[¶](https://docs.python.org/3/library/logging.handlers.html#logging.handlers.DatagramHandler.makeSocket "Link to this definition")
    
The factory method of [`SocketHandler`](https://docs.python.org/3/library/logging.handlers.html#logging.handlers.SocketHandler "logging.handlers.SocketHandler") is here overridden to create a UDP socket ([`socket.SOCK_DGRAM`](https://docs.python.org/3/library/socket.html#socket.SOCK_DGRAM "socket.SOCK_DGRAM")).