Title: Implementing Arithmetic Operations in Numeric Types
URL: https://docs.python.org/3/library/numbers.html
Summary: This section describes how to implement arithmetic operations for numeric types in Python, focusing on mixed-mode operations. It emphasizes the importance of defining methods like `__add__()` and `__radd__()` in subclasses of `Integral` to handle various types of operands effectively.
---

```

### Implementing the arithmetic operations[¶](https://docs.python.org/3/library/numbers.html#implementing-the-arithmetic-operations "Link to this heading")
We want to implement the arithmetic operations so that mixed-mode operations either call an implementation whose author knew about the types of both arguments, or convert both to the nearest built in type and do the operation there. For subtypes of [`Integral`](https://docs.python.org/3/library/numbers.html#numbers.Integral "numbers.Integral"), this means that [`__add__()`](https://docs.python.org/3/reference/datamodel.html#object.__add__ "object.__add__") and [`__radd__()`](https://docs.python.org/3/reference/datamodel.html#object.__radd__ "object.__radd__") should be defined as:
```
classMyIntegral(Integral):
  def__add__(self, other):
    if isinstance(other, MyIntegral):
      return do_my_adding_stuff(self, other)
    elif isinstance(other, OtherTypeIKnowAbout):
      return do_my_other_adding_stuff(self, other)
    else:
      return NotImplemented
  def__radd__(self, other):
    if isinstance(other, MyIntegral):
      return do_my_adding_stuff(other, self)
    elif isinstance(other, OtherTypeIKnowAbout):
      return do_my_other_adding_stuff(other, self)
    elif isinstance(other, Integral):
      return int(other) + int(self)
    elif isinstance(other, Real):
      return float(other) + float(self)
    elif isinstance(other, Complex):
      return complex(other) + complex(self)
    else:
      return NotImplemented

```

There are 5 different cases for a mixed-type operation on subclasses of [`Complex`](https://docs.python.org/3/library/numbers.html#numbers.Complex "numbers.Complex"). I’ll refer to all of the above code that doesn’t refer to `MyIntegral` and `OtherTypeIKnowAbout` as “boilerplate”. `a` will be an instance of `A`, which is a subtype of [`Complex`](https://docs.python.org/3/library/numbers.html#numbers.Complex "numbers.Complex") (`a : A <: Complex`), and `b : B <: Complex`. I’ll consider `a + b`:
  1. If `A` defines an [`__add__()`](https://docs.python.org/3/reference/datamodel.html#object.__add__ "object.__add__") which accepts `b`, all is well.
  2. If `A` falls back to the boilerplate code, and it were to return a value from [`__add__()`](https://docs.python.org/3/reference/datamodel.html#object.__add__ "object.__add__"), we’d miss the possibility that `B` defines a more intelligent [`__radd__()`](https://docs.python.org/3/reference/datamodel.html#object.__radd__ "object.__radd__"), so the boilerplate should return [`NotImplemented`](https://docs.python.org/3/library/constants.html#NotImplemented "NotImplemented") from `__add__()`. (Or `A` may not implement `__add__()` at all.)
  3. Then `B`’s [`__radd__()`](https://docs.python.org/3/reference/datamodel.html#object.__radd__ "object.__radd__") gets a chance. If it accepts `a`, all is well.
  4. If it falls back to the boilerplate, there are no more possible methods to try, so this is where the default implementation should live.
  5. If `B <: A`, Python tries `B.__radd__` before `A.__add__`. This is ok, because it was implemented with knowledge of `A`, so it can handle those instances before delegating to [`Complex`](https://docs.python.org/3/library/numbers.html#numbers.Complex "numbers.Complex").


If `A <: Complex` and `B <: Real` without sharing any other knowledge, then the appropriate shared operation is the one involving the built in [`complex`](https://docs.python.org/3/library/functions.html#complex "complex"), and both [`__radd__()`](https://docs.python.org/3/reference/datamodel.html#object.__radd__ "object.__radd__") s land there, so `a+b == b+a`.
Because most of the operations on any given type will be very similar, it can be useful to define a helper function which generates the forward and reverse instances of any given operator. For example, [`fractions.Fraction`](https://docs.python.org/3/library/fractions.html#fractions.Fraction "fractions.Fraction") uses: