Title: Dataclass Initialization and Class Variables
URL: https://docs.python.org/3/library/dataclasses.html
Summary: Dataclass-generated `__init__()` methods are usually automatic and handle field initialization for base classes that are also dataclasses. Users can pass parameters to `__post_init__()`, and it's important to understand how `replace()` interacts with `init=False` fields. The `@dataclass` decorator checks field types to differentiate class variables according to PEP 526.
---

```

Note, however, that in general the dataclass-generated `__init__()` methods don’t need to be called, since the derived dataclass will take care of initializing all fields of any base class that is a dataclass itself.
See the section below on init-only variables for ways to pass parameters to `__post_init__()`. Also see the warning about how [`replace()`](https://docs.python.org/3/library/dataclasses.html#dataclasses.replace "dataclasses.replace") handles `init=False` fields.
## Class variables[¶](https://docs.python.org/3/library/dataclasses.html#class-variables "Link to this heading")
One of the few places where [`@dataclass`](https://docs.python.org/3/library/dataclasses.html#dataclasses.dataclass "dataclasses.dataclass") actually inspects the type of a field is to determine if a field is a class variable as defined in [**PEP 526**](https://peps.python.org/pep-0526/). It does this by checking if the type of the field is [`typing.ClassVar`](https://docs.python.org/3/library/typing.html#typing.ClassVar "typing.ClassVar"). If a field is a `ClassVar`, it is excluded from consideration as a field and is ignored by the dataclass mechanisms. Such `ClassVar` pseudo-fields are not returned by the module-level [`fields()`](https://docs.python.org/3/library/dataclasses.html#dataclasses.fields "dataclasses.fields") function.
## Init-only variables[¶](https://docs.python.org/3/library/dataclasses.html#init-only-variables "Link to this heading")
Another place where [`@dataclass`](https://docs.python.org/3/library/dataclasses.html#dataclasses.dataclass "dataclasses.dataclass") inspects a type annotation is to determine if a field is an init-only variable. It does this by seeing if the type of a field is of type [`InitVar`](https://docs.python.org/3/library/dataclasses.html#dataclasses.InitVar "dataclasses.InitVar"). If a field is an [`InitVar`](https://docs.python.org/3/library/dataclasses.html#dataclasses.InitVar "dataclasses.InitVar"), it is considered a pseudo-field called an init-only field. As it is not a true field, it is not returned by the module-level [`fields()`](https://docs.python.org/3/library/dataclasses.html#dataclasses.fields "dataclasses.fields") function. Init-only fields are added as parameters to the generated [`__init__()`](https://docs.python.org/3/reference/datamodel.html#object.__init__ "object.__init__") method, and are passed to the optional [`__post_init__()`](https://docs.python.org/3/library/dataclasses.html#dataclasses.__post_init__ "dataclasses.__post_init__") method. They are not otherwise used by dataclasses.
For example, suppose a field will be initialized from a database, if a value is not provided when creating the class:
```
@dataclass
classC:
  i: int
  j: int | None = None
  database: InitVar[DatabaseType | None] = None
  def__post_init__(self, database):
    if self.j is None and database is not None:
      self.j = database.lookup('j')
c = C(10, database=my_database)