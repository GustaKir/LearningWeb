Title: Built-in Methods and Classes in Python Data Model
URL: https://docs.python.org/3/reference/datamodel.html
Summary: This section explains built-in methods as functions that implicitly take an object as an extra argument, illustrated by the `alist.append()` example. It also describes classes as callable objects that typically serve as factories for creating new instances, with references to class method overrides.
---

#### 3.2.8.7. Built-in methods[¶](https://docs.python.org/3/reference/datamodel.html#built-in-methods "Link to this heading")
This is really a different disguise of a built-in function, this time containing an object passed to the C function as an implicit extra argument. An example of a built-in method is `alist.append()`, assuming _alist_ is a list object. In this case, the special read-only attribute `__self__` is set to the object denoted by _alist_. (The attribute has the same semantics as it does with [`other instance methods`](https://docs.python.org/3/reference/datamodel.html#method.__self__ "method.__self__").)
#### 3.2.8.8. Classes[¶](https://docs.python.org/3/reference/datamodel.html#classes "Link to this heading")
Classes are callable. These objects normally act as factories for new instances of themselves, but variations are possible for class types that override [`__new__()`](https://docs.python.org/3/reference/datamodel.html#object.__new__ "object.__new__"). The arguments of the call are passed to `__new__()` and, in the typical case, to [`__init__()`](https://docs.python.org/3/reference/datamodel.html#object.__init__ "object.__init__") to initialize the new instance.
#### 3.2.8.9. Class Instances[¶](https://docs.python.org/3/reference/datamodel.html#class-instances "Link to this heading")
Instances of arbitrary classes can be made callable by defining a [`__call__()`](https://docs.python.org/3/reference/datamodel.html#object.__call__ "object.__call__") method in their class.
### 3.2.9. Modules[¶](https://docs.python.org/3/reference/datamodel.html#modules "Link to this heading")
Modules are a basic organizational unit of Python code, and are created by the [import system](https://docs.python.org/3/reference/import.html#importsystem) as invoked either by the [`import`](https://docs.python.org/3/reference/simple_stmts.html#import) statement, or by calling functions such as [`importlib.import_module()`](https://docs.python.org/3/library/importlib.html#importlib.import_module "importlib.import_module") and built-in [`__import__()`](https://docs.python.org/3/library/functions.html#import__ "__import__"). A module object has a namespace implemented by a [`dictionary`](https://docs.python.org/3/library/stdtypes.html#dict "dict") object (this is the dictionary referenced by the [`__globals__`](https://docs.python.org/3/reference/datamodel.html#function.__globals__ "function.__globals__") attribute of functions defined in the module). Attribute references are translated to lookups in this dictionary, e.g., `m.x` is equivalent to `m.__dict__["x"]`. A module object does not contain the code object used to initialize the module (since it isn’t needed once the initialization is done).
Attribute assignment updates the module’s namespace dictionary, e.g., `m.x = 1` is equivalent to `m.__dict__["x"] = 1`.
#### 3.2.9.1. Import-related attributes on module objects[¶](https://docs.python.org/3/reference/datamodel.html#import-related-attributes-on-module-objects "Link to this heading")
Module objects have the following attributes that relate to the [import system](https://docs.python.org/3/reference/import.html#importsystem). When a module is created using the machinery associated with the import system, these attributes are filled in based on the module’s [spec](https://docs.python.org/3/glossary.html#term-module-spec), before the [loader](https://docs.python.org/3/glossary.html#term-loader) executes and loads the module.
To create a module dynamically rather than using the import system, it’s recommended to use [`importlib.util.module_from_spec()`](https://docs.python.org/3/library/importlib.html#importlib.util.module_from_spec "importlib.util.module_from_spec"), which will set the various import-controlled attributes to appropriate values. It’s also possible to use the [`types.ModuleType`](https://docs.python.org/3/library/types.html#types.ModuleType "types.ModuleType") constructor to create modules directly, but this technique is more error-prone, as most attributes must be manually set on the module object after it has been created when using this approach.
Caution
With the exception of [`__name__`](https://docs.python.org/3/reference/datamodel.html#module.__name__ "module.__name__"), it is **strongly** recommended that you rely on [`__spec__`](https://docs.python.org/3/reference/datamodel.html#module.__spec__ "module.__spec__") and its attributes instead of any of the other individual attributes listed in this subsection. Note that updating an attribute on `__spec__` will not update the corresponding attribute on the module itself:
>>>```
>>> importtyping
>>> typing.__name__, typing.__spec__.name
('typing', 'typing')
>>> typing.__spec__.name = 'spelling'
>>> typing.__name__, typing.__spec__.name
('typing', 'spelling')
>>> typing.__name__ = 'keyboard_smashing'
>>> typing.__name__, typing.__spec__.name
('keyboard_smashing', 'spelling')