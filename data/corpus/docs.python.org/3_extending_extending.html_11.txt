Title: Reference Counting in Python C API
URL: https://docs.python.org/3/extending/extending.html
Summary: This section discusses the concept of reference counting in Python's C API, highlighting the difference between owning and borrowing references to objects. It emphasizes the importance of managing reference counts with `Py_INCREF` and `Py_DECREF` to prevent memory leaks, and explains that owners of references must dispose of them properly.
---

the object’s _type object_. For this purpose (and others), every object also contains a pointer to its type object.
The big question now remains: when to use `Py_INCREF(x)` and `Py_DECREF(x)`? Let’s first introduce some terms. Nobody “owns” an object; however, you can _own a reference_ to an object. An object’s reference count is now defined as the number of owned references to it. The owner of a reference is responsible for calling [`Py_DECREF()`](https://docs.python.org/3/c-api/refcounting.html#c.Py_DECREF "Py_DECREF") when the reference is no longer needed. Ownership of a reference can be transferred. There are three ways to dispose of an owned reference: pass it on, store it, or call [`Py_DECREF()`](https://docs.python.org/3/c-api/refcounting.html#c.Py_DECREF "Py_DECREF"). Forgetting to dispose of an owned reference creates a memory leak.
It is also possible to _borrow_ [[2]](https://docs.python.org/3/extending/extending.html#id6) a reference to an object. The borrower of a reference should not call [`Py_DECREF()`](https://docs.python.org/3/c-api/refcounting.html#c.Py_DECREF "Py_DECREF"). The borrower must not hold on to the object longer than the owner from which it was borrowed. Using a borrowed reference after the owner has disposed of it risks using freed memory and should be avoided completely [[3]](https://docs.python.org/3/extending/extending.html#id7).
The advantage of borrowing over owning a reference is that you don’t need to take care of disposing of the reference on all possible paths through the code — in other words, with a borrowed reference you don’t run the risk of leaking when a premature exit is taken. The disadvantage of borrowing over owning is that there are some subtle situations where in seemingly correct code a borrowed reference can be used after the owner from which it was borrowed has in fact disposed of it.
A borrowed reference can be changed into an owned reference by calling [`Py_INCREF()`](https://docs.python.org/3/c-api/refcounting.html#c.Py_INCREF "Py_INCREF"). This does not affect the status of the owner from which the reference was borrowed — it creates a new owned reference, and gives full owner responsibilities (the new owner must dispose of the reference properly, as well as the previous owner).
### 1.10.2. Ownership Rules[¶](https://docs.python.org/3/extending/extending.html#ownership-rules "Link to this heading")
Whenever an object reference is passed into or out of a function, it is part of the function’s interface specification whether ownership is transferred with the reference or not.
Most functions that return a reference to an object pass on ownership with the reference. In particular, all functions whose function it is to create a new object, such as [`PyLong_FromLong()`](https://docs.python.org/3/c-api/long.html#c.PyLong_FromLong "PyLong_FromLong") and [`Py_BuildValue()`](https://docs.python.org/3/c-api/arg.html#c.Py_BuildValue "Py_BuildValue"), pass ownership to the receiver. Even if the object is not actually new, you still receive ownership of a new reference to that object. For instance, [`PyLong_FromLong()`](https://docs.python.org/3/c-api/long.html#c.PyLong_FromLong "PyLong_FromLong") maintains a cache of popular values and can return a reference to a cached item.
Many functions that extract objects from other objects also transfer ownership with the reference, for instance [`PyObject_GetAttrString()`](https://docs.python.org/3/c-api/object.html#c.PyObject_GetAttrString "PyObject_GetAttrString"). The picture is less clear, here, however, since a few common routines are exceptions: [`PyTuple_GetItem()`](https://docs.python.org/3/c-api/tuple.html#c.PyTuple_GetItem "PyTuple_GetItem"), [`PyList_GetItem()`](https://docs.python.org/3/c-api/list.html#c.PyList_GetItem "PyList_GetItem"), [`PyDict_GetItem()`](https://docs.python.org/3/c-api/dict.html#c.PyDict_GetItem "PyDict_GetItem"), and [`PyDict_GetItemString()`](https://docs.python.org/3/c-api/dict.html#c.PyDict_GetItemString "PyDict_GetItemString") all return references that you borrow from the tuple, list or dictionary.
The function [`PyImport_AddModule()`](https://docs.python.org/3/c-api/import.html#c.PyImport_AddModule "PyImport_AddModule") also returns a borrowed reference, even though it may actually create the object it returns: this is possible because an owned reference to the object is stored in `sys.modules`.
When you pass an object reference into another function, in general, the function borrows the reference from you — if it needs to store it, it will use [`Py_INCREF()`](https://docs.python.org/3/c-api/refcounting.html#c.Py_INCREF "Py_INCREF") to become an independent owner. There are exactly two important exceptions to this rule: [`PyTuple_SetItem()`](https://docs.python.org/3/c-api/tuple.html#c.PyTuple_SetItem "PyTuple_SetItem") and [`PyList_SetItem()`](https://docs.python.org/3/c-api/list.html#c.PyList_SetItem "PyList_SetItem").