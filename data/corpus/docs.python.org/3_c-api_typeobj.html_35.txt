Title: PyTypeObject.tp_vectorcall Overview
URL: https://docs.python.org/3/c-api/typeobj.html
Summary: This section discusses the tp_vectorcall field of the PyTypeObject, which is inherited by subtypes and is used to implement vectorcall for type calls. Changes related to the use of Py_TPFLAGS_HAVE_FINALIZE from versions 3.4 to 3.8 are noted, alongside a reference to PEP 442 on safe object finalization.
---

```

**Inheritance:**
This field is inherited by subtypes.
Added in version 3.4.
Changed in version 3.8: Before version 3.8 it was necessary to set the [`Py_TPFLAGS_HAVE_FINALIZE`](https://docs.python.org/3/c-api/typeobj.html#c.Py_TPFLAGS_HAVE_FINALIZE "Py_TPFLAGS_HAVE_FINALIZE") flags bit in order for this field to be used. This is no longer required.
See also
“Safe object finalization” ([**PEP 442**](https://peps.python.org/pep-0442/)) 

[vectorcallfunc](https://docs.python.org/3/c-api/call.html#c.vectorcallfunc "vectorcallfunc")[PyTypeObject](https://docs.python.org/3/c-api/type.html#c.PyTypeObject "PyTypeObject").tp_vectorcall[¶](https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_vectorcall "Link to this definition")
    
Vectorcall function to use for calls of this type object. In other words, it is used to implement [vectorcall](https://docs.python.org/3/c-api/call.html#vectorcall) for `type.__call__`. If `tp_vectorcall` is `NULL`, the default call implementation using [`__new__()`](https://docs.python.org/3/reference/datamodel.html#object.__new__ "object.__new__") and [`__init__()`](https://docs.python.org/3/reference/datamodel.html#object.__init__ "object.__init__") is used.
**Inheritance:**
This field is never inherited.
Added in version 3.9: (the field exists since 3.8 but it’s only used since 3.9) 

unsignedchar[PyTypeObject](https://docs.python.org/3/c-api/type.html#c.PyTypeObject "PyTypeObject").tp_watched[¶](https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_watched "Link to this definition")
    
Internal. Do not use.
Added in version 3.12.
## Static Types[¶](https://docs.python.org/3/c-api/typeobj.html#static-types "Link to this heading")
Traditionally, types defined in C code are _static_ , that is, a static [`PyTypeObject`](https://docs.python.org/3/c-api/type.html#c.PyTypeObject "PyTypeObject") structure is defined directly in code and initialized using [`PyType_Ready()`](https://docs.python.org/3/c-api/type.html#c.PyType_Ready "PyType_Ready").
This results in types that are limited relative to types defined in Python:
  * Static types are limited to one base, i.e. they cannot use multiple inheritance.
  * Static type objects (but not necessarily their instances) are immutable. It is not possible to add or modify the type object’s attributes from Python.
  * Static type objects are shared across [sub-interpreters](https://docs.python.org/3/c-api/init.html#sub-interpreter-support), so they should not include any subinterpreter-specific state.


Also, since [`PyTypeObject`](https://docs.python.org/3/c-api/type.html#c.PyTypeObject "PyTypeObject") is only part of the [Limited API](https://docs.python.org/3/c-api/stable.html#limited-c-api) as an opaque struct, any extension modules using static types must be compiled for a specific Python minor version.
## Heap Types[¶](https://docs.python.org/3/c-api/typeobj.html#heap-types "Link to this heading")
An alternative to [static types](https://docs.python.org/3/c-api/typeobj.html#static-types) is _heap-allocated types_ , or _heap types_ for short, which correspond closely to classes created by Python’s `class` statement. Heap types have the [`Py_TPFLAGS_HEAPTYPE`](https://docs.python.org/3/c-api/typeobj.html#c.Py_TPFLAGS_HEAPTYPE "Py_TPFLAGS_HEAPTYPE") flag set.
This is done by filling a [`PyType_Spec`](https://docs.python.org/3/c-api/type.html#c.PyType_Spec "PyType_Spec") structure and calling [`PyType_FromSpec()`](https://docs.python.org/3/c-api/type.html#c.PyType_FromSpec "PyType_FromSpec"), [`PyType_FromSpecWithBases()`](https://docs.python.org/3/c-api/type.html#c.PyType_FromSpecWithBases "PyType_FromSpecWithBases"), [`PyType_FromModuleAndSpec()`](https://docs.python.org/3/c-api/type.html#c.PyType_FromModuleAndSpec "PyType_FromModuleAndSpec"), or [`PyType_FromMetaclass()`](https://docs.python.org/3/c-api/type.html#c.PyType_FromMetaclass "PyType_FromMetaclass").
## Number Object Structures[¶](https://docs.python.org/3/c-api/typeobj.html#number-object-structures "Link to this heading") 

typePyNumberMethods[¶](https://docs.python.org/3/c-api/typeobj.html#c.PyNumberMethods "Link to this definition")
    
This structure holds pointers to the functions which an object uses to implement the number protocol. Each function is used by the function of similar name documented in the [Number Protocol](https://docs.python.org/3/c-api/number.html#number) section.
Here is the structure definition: