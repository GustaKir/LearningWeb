Title: Overview of Syntax Changes in Python 3.0
URL: https://docs.python.org/3/whatsnew/3.0.html
Summary: This section summarizes the syntactic changes introduced in Python 3.0, including function argument and return value annotations (PEP 3107) and keyword-only arguments (PEP 3102), which enable more flexible function definitions.
---

## Overview Of Syntax Changes[¶](https://docs.python.org/3/whatsnew/3.0.html#overview-of-syntax-changes "Link to this heading")
This section gives a brief overview of every _syntactic_ change in Python 3.0.
### New Syntax[¶](https://docs.python.org/3/whatsnew/3.0.html#new-syntax "Link to this heading")
  * [**PEP 3107**](https://peps.python.org/pep-3107/): Function argument and return value annotations. This provides a standardized way of annotating a function’s parameters and return value. There are no semantics attached to such annotations except that they can be introspected at runtime using the `__annotations__` attribute. The intent is to encourage experimentation through metaclasses, decorators or frameworks.
  * [**PEP 3102**](https://peps.python.org/pep-3102/): Keyword-only arguments. Named parameters occurring after `*args` in the parameter list _must_ be specified using keyword syntax in the call. You can also use a bare `*` in the parameter list to indicate that you don’t accept a variable-length argument list, but you do have keyword-only arguments.
  * Keyword arguments are allowed after the list of base classes in a class definition. This is used by the new convention for specifying a metaclass (see next section), but can be used for other purposes as well, as long as the metaclass supports it.
  * [**PEP 3104**](https://peps.python.org/pep-3104/): [`nonlocal`](https://docs.python.org/3/reference/simple_stmts.html#nonlocal) statement. Using `nonlocal x` you can now assign directly to a variable in an outer (but non-global) scope. `nonlocal` is a new reserved word.
  * [**PEP 3132**](https://peps.python.org/pep-3132/): Extended Iterable Unpacking. You can now write things like `a, b, *rest = some_sequence`. And even `*rest, a = stuff`. The `rest` object is always a (possibly empty) list; the right-hand side may be any iterable. Example:
```
(a, *rest, b) = range(5)

```

This sets _a_ to `0`, _b_ to `4`, and _rest_ to `[1, 2, 3]`.
  * Dictionary comprehensions: `{k: v for k, v in stuff}` means the same thing as `dict(stuff)` but is more flexible. (This is [**PEP 274**](https://peps.python.org/pep-0274/) vindicated. :-)
  * Set literals, e.g. `{1, 2}`. Note that `{}` is an empty dictionary; use `set()` for an empty set. Set comprehensions are also supported; e.g., `{x for x in stuff}` means the same thing as `set(stuff)` but is more flexible.
  * New octal literals, e.g. `0o720` (already in 2.6). The old octal literals (`0720`) are gone.
  * New binary literals, e.g. `0b1010` (already in 2.6), and there is a new corresponding built-in function, [`bin()`](https://docs.python.org/3/library/functions.html#bin "bin").
  * Bytes literals are introduced with a leading `b` or `B`, and there is a new corresponding built-in function, [`bytes()`](https://docs.python.org/3/library/stdtypes.html#bytes "bytes").


### Changed Syntax[¶](https://docs.python.org/3/whatsnew/3.0.html#changed-syntax "Link to this heading")
  * [**PEP 3109**](https://peps.python.org/pep-3109/) and [**PEP 3134**](https://peps.python.org/pep-3134/): new [`raise`](https://docs.python.org/3/reference/simple_stmts.html#raise) statement syntax: `raise [_expr_ [from _expr_]]`. See below.
  * `as` and [`with`](https://docs.python.org/3/reference/compound_stmts.html#with) are now reserved words. (Since 2.6, actually.)
  * `True`, `False`, and `None` are reserved words. (2.6 partially enforced the restrictions on `None` already.)
  * Change from [`except`](https://docs.python.org/3/reference/compound_stmts.html#except) _exc_ , _var_ to `except` _exc_ `as` _var_. See [**PEP 3110**](https://peps.python.org/pep-3110/).
  * [**PEP 3115**](https://peps.python.org/pep-3115/): New Metaclass Syntax. Instead of:
```
classC:
  __metaclass__ = M
  ...

```

you must now use:
```
classC(metaclass=M):
  ...