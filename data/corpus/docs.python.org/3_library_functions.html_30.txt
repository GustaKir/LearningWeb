Title: Understanding super() in Python
URL: https://docs.python.org/3/library/functions.html
Summary: The `super()` function is utilized for both method and attribute lookups, particularly useful for calling descriptors in parent or sibling classes. It is integrated into the binding process for explicit attribute lookups. However, it does not apply to implicit lookups using statements or operators. Cooperatively, `super()` supports multiple inheritance through a custom `__getattribute__()` method.
---

```

In addition to method lookups, [`super()`](https://docs.python.org/3/library/functions.html#super "super") also works for attribute lookups. One possible use case for this is calling [descriptors](https://docs.python.org/3/glossary.html#term-descriptor) in a parent or sibling class.
Note that [`super()`](https://docs.python.org/3/library/functions.html#super "super") is implemented as part of the binding process for explicit dotted attribute lookups such as `super().__getitem__(name)`. It does so by implementing its own [`__getattribute__()`](https://docs.python.org/3/reference/datamodel.html#object.__getattribute__ "object.__getattribute__") method for searching classes in a predictable order that supports cooperative multiple inheritance. Accordingly, [`super()`](https://docs.python.org/3/library/functions.html#super "super") is undefined for implicit lookups using statements or operators such as `super()[name]`.
Also note that, aside from the zero argument form, [`super()`](https://docs.python.org/3/library/functions.html#super "super") is not limited to use inside methods. The two argument form specifies the arguments exactly and makes the appropriate references. The zero argument form only works inside a class definition, as the compiler fills in the necessary details to correctly retrieve the class being defined, as well as accessing the current instance for ordinary methods.
For practical suggestions on how to design cooperative classes using [`super()`](https://docs.python.org/3/library/functions.html#super "super"), see [guide to using super()](https://rhettinger.wordpress.com/2011/05/26/super-considered-super/). 

_class_ tuple


_class_ tuple(_iterable_)
    
Rather than being a function, [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "tuple") is actually an immutable sequence type, as documented in [Tuples](https://docs.python.org/3/library/stdtypes.html#typesseq-tuple) and [Sequence Types — list, tuple, range](https://docs.python.org/3/library/stdtypes.html#typesseq). 

_class_ type(_object_)[¶](https://docs.python.org/3/library/functions.html#type "Link to this definition")


_class_ type(_name_ , _bases_ , _dict_ , _** kwds_)
    
With one argument, return the type of an _object_. The return value is a type object and generally the same object as returned by [`object.__class__`](https://docs.python.org/3/reference/datamodel.html#object.__class__ "object.__class__").
The [`isinstance()`](https://docs.python.org/3/library/functions.html#isinstance "isinstance") built-in function is recommended for testing the type of an object, because it takes subclasses into account.
With three arguments, return a new type object. This is essentially a dynamic form of the [`class`](https://docs.python.org/3/reference/compound_stmts.html#class) statement. The _name_ string is the class name and becomes the [`__name__`](https://docs.python.org/3/reference/datamodel.html#type.__name__ "type.__name__") attribute. The _bases_ tuple contains the base classes and becomes the [`__bases__`](https://docs.python.org/3/reference/datamodel.html#type.__bases__ "type.__bases__") attribute; if empty, [`object`](https://docs.python.org/3/library/functions.html#object "object"), the ultimate base of all classes, is added. The _dict_ dictionary contains attribute and method definitions for the class body; it may be copied or wrapped before becoming the [`__dict__`](https://docs.python.org/3/reference/datamodel.html#type.__dict__ "type.__dict__") attribute. The following two statements create identical `type` objects:
>>>```
>>> classX:
...   a = 1
...
>>> X = type('X', (), dict(a=1))