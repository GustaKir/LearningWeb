Title: Using Functions from Modules
URL: https://docs.python.org/3/tutorial/modules.html
Summary: The chunk explains how to access functions from a module, using the `fibo` module as an example. It illustrates that while only the module name is added to the current namespace, the functions can still be accessed with the module prefix. It also demonstrates how to assign a frequently used function to a local name for easier access.
---

```

This does not add the names of the functions defined in `fibo` directly to the current [namespace](https://docs.python.org/3/glossary.html#term-namespace) (see [Python Scopes and Namespaces](https://docs.python.org/3/tutorial/classes.html#tut-scopes) for more details); it only adds the module name `fibo` there. Using the module name you can access the functions:
>>>```
>>> fibo.fib(1000)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
>>> fibo.fib2(100)
[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
>>> fibo.__name__
'fibo'

```

If you intend to use a function often you can assign it to a local name:
>>>```
>>> fib = fibo.fib
>>> fib(500)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377

```

## 6.1. More on Modules[¶](https://docs.python.org/3/tutorial/modules.html#more-on-modules "Link to this heading")
A module can contain executable statements as well as function definitions. These statements are intended to initialize the module. They are executed only the _first_ time the module name is encountered in an import statement. [[1]](https://docs.python.org/3/tutorial/modules.html#id3) (They are also run if the file is executed as a script.)
Each module has its own private namespace, which is used as the global namespace by all functions defined in the module. Thus, the author of a module can use global variables in the module without worrying about accidental clashes with a user’s global variables. On the other hand, if you know what you are doing you can touch a module’s global variables with the same notation used to refer to its functions, `modname.itemname`.
Modules can import other modules. It is customary but not required to place all [`import`](https://docs.python.org/3/reference/simple_stmts.html#import) statements at the beginning of a module (or script, for that matter). The imported module names, if placed at the top level of a module (outside any functions or classes), are added to the module’s global namespace.
There is a variant of the [`import`](https://docs.python.org/3/reference/simple_stmts.html#import) statement that imports names from a module directly into the importing module’s namespace. For example:
>>>```
>>> fromfiboimport fib, fib2
>>> fib(500)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377

```

This does not introduce the module name from which the imports are taken in the local namespace (so in the example, `fibo` is not defined).
There is even a variant to import all names that a module defines:
>>>```
>>> fromfiboimport *
>>> fib(500)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377

```

This imports all names except those beginning with an underscore (`_`). In most cases Python programmers do not use this facility since it introduces an unknown set of names into the interpreter, possibly hiding some things you have already defined.
Note that in general the practice of importing `*` from a module or package is frowned upon, since it often causes poorly readable code. However, it is okay to use it to save typing in interactive sessions.
If the module name is followed by `as`, then the name following `as` is bound directly to the imported module.
>>>```
>>> importfiboasfib
>>> fib.fib(500)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377

```

This is effectively importing the module in the same way that `import fibo` will do, with the only difference of it being available as `fib`.
It can also be used when utilising [`from`](https://docs.python.org/3/reference/simple_stmts.html#from) with similar effects:
>>>```
>>> fromfiboimport fib as fibonacci
>>> fibonacci(500)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377

```

Note
For efficiency reasons, each module is only imported once per interpreter session. Therefore, if you change your modules, you must restart the interpreter – or, if it’s just one module you want to test interactively, use [`importlib.reload()`](https://docs.python.org/3/library/importlib.html#importlib.reload "importlib.reload"), e.g. `import importlib; importlib.reload(modulename)`.
### 6.1.1. Executing modules as scripts[¶](https://docs.python.org/3/tutorial/modules.html#executing-modules-as-scripts "Link to this heading")
When you run a Python module with
```
python fibo.py <arguments>

```

the code in the module will be executed, just as if you imported it, but with the `__name__` set to `"__main__"`. That means that by adding this code at the end of your module:
```
if __name__ == "__main__":
  importsys
  fib(int(sys.argv[1]))

```

you can make the file usable as a script as well as an importable module, because the code that parses the command line only runs if the module is executed as the “main” file:
```
$ pythonfibo.py50
0 1 1 2 3 5 8 13 21 34

```

If the module is imported, the code is not run:
>>>```
>>> importfibo
>>>