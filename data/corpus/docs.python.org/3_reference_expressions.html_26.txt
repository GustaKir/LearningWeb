Title: Operator Precedence in Python
URL: https://docs.python.org/3/reference/expressions.html
Summary: This section provides a summary of operator precedence in Python, detailing the order in which operators are evaluated from highest to lowest precedence. It notes that most operators are binary, group from left to right, and highlights that comparisons, membership tests, and identity tests have the same precedence with a left-to-right chaining feature.
---

```

## 6.17. Operator precedence[¶](https://docs.python.org/3/reference/expressions.html#operator-precedence "Link to this heading")
The following table summarizes the operator precedence in Python, from highest precedence (most binding) to lowest precedence (least binding). Operators in the same box have the same precedence. Unless the syntax is explicitly given, operators are binary. Operators in the same box group left to right (except for exponentiation and conditional expressions, which group from right to left).
Note that comparisons, membership tests, and identity tests, all have the same precedence and have a left-to-right chaining feature as described in the [Comparisons](https://docs.python.org/3/reference/expressions.html#comparisons) section.
Operator | Description  
---|---  
`(expressions...)`, `[expressions...]`, `{key: value...}`, `{expressions...}` | Binding or parenthesized expression, list display, dictionary display, set display  
`x[index]`, `x[index:index]`, `x(arguments...)`, `x.attribute` | Subscription, slicing, call, attribute reference  
[`await x`](https://docs.python.org/3/reference/expressions.html#await) | Await expression  
`**` | Exponentiation [[5]](https://docs.python.org/3/reference/expressions.html#id23)  
`+x`, `-x`, `~x` | Positive, negative, bitwise NOT  
`*`, `@`, `/`, `//`, `%` | Multiplication, matrix multiplication, division, floor division, remainder [[6]](https://docs.python.org/3/reference/expressions.html#id24)  
`+`, `-` | Addition and subtraction  
`<<`, `>>` | Shifts  
`&` | Bitwise AND  
`^` | Bitwise XOR  
`|` | Bitwise OR  
[`in`](https://docs.python.org/3/reference/expressions.html#in), [`not in`](https://docs.python.org/3/reference/expressions.html#not-in), [`is`](https://docs.python.org/3/reference/expressions.html#is), [`is not`](https://docs.python.org/3/reference/expressions.html#is-not), `<`, `<=`, `>`, `>=`, `!=`, `==` | Comparisons, including membership tests and identity tests  
[`not x`](https://docs.python.org/3/reference/expressions.html#not) | Boolean NOT  
[`and`](https://docs.python.org/3/reference/expressions.html#and) | Boolean AND  
[`or`](https://docs.python.org/3/reference/expressions.html#or) | Boolean OR  
[`if`](https://docs.python.org/3/reference/expressions.html#if-expr) – `else` | Conditional expression  
[`lambda`](https://docs.python.org/3/reference/expressions.html#lambda) | Lambda expression  
`:=` | Assignment expression  
Footnotes
[[1](https://docs.python.org/3/reference/expressions.html#id10)]
While `abs(x%y) < abs(y)` is true mathematically, for floats it may not be true numerically due to roundoff. For example, and assuming a platform on which a Python float is an IEEE 754 double-precision number, in order that `-1e-100 % 1e100` have the same sign as `1e100`, the computed result is `-1e-100 + 1e100`, which is numerically exactly equal to `1e100`. The function [`math.fmod()`](https://docs.python.org/3/library/math.html#math.fmod "math.fmod") returns a result whose sign matches the sign of the first argument instead, and so returns `-1e-100` in this case. Which approach is more appropriate depends on the application.
[[2](https://docs.python.org/3/reference/expressions.html#id11)]
If x is very close to an exact integer multiple of y, it’s possible for `x//y` to be one larger than `(x-x%y)//y` due to rounding. In such cases, Python returns the latter result, in order to preserve that `divmod(x,y)[0] * y + x % y` be very close to `x`.
[[3](https://docs.python.org/3/reference/expressions.html#id13)]
The Unicode standard distinguishes between _code points_ (e.g. U+0041) and _abstract characters_ (e.g. “LATIN CAPITAL LETTER A”). While most abstract characters in Unicode are only represented using one code point, there is a number of abstract characters that can in addition be represented using a sequence of more than one code point. For example, the abstract character “LATIN CAPITAL LETTER C WITH CEDILLA” can be represented as a single _precomposed character_ at code position U+00C7, or as a sequence of a _base character_ at code position U+0043 (LATIN CAPITAL LETTER C), followed by a _combining character_ at code position U+0327 (COMBINING CEDILLA).
The comparison operators on strings compare at the level of Unicode code points. This may be counter-intuitive to humans. For example, `"\u00C7" == "\u0043\u0327"` is `False`, even though both strings represent the same abstract character “LATIN CAPITAL LETTER C WITH CEDILLA”.
To compare strings at the level of abstract characters (that is, in a way intuitive to humans), use [`unicodedata.normalize()`](https://docs.python.org/3/library/unicodedata.html#unicodedata.normalize "unicodedata.normalize").
[[4](https://docs.python.org/3/reference/expressions.html#id14)]
Due to automatic garbage-collection, free lists, and the dynamic nature of descriptors, you may notice seemingly unusual behaviour in certain uses of the [`is`](https://docs.python.org/3/reference/expressions.html#is)