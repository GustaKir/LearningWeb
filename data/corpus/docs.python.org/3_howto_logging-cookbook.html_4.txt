Title: Logging Cookbook: Custom Handling of Levels
URL: https://docs.python.org/3/howto/logging-cookbook.html
Summary: This section illustrates how to configure logging in Python using console and file handlers, highlighting that DEBUG messages are only stored in the file. It mentions the importance of the log file location, particularly for POSIX systems, and advises ensuring proper permissions when logging on different operating systems.
---

```
10-22 22:19 root     INFO   Jackdaws love my big sphinx of quartz.
10-22 22:19 myapp.area1 DEBUG  Quick zephyrs blow, vexing daft Jim.
10-22 22:19 myapp.area1 INFO   How quickly daft jumping zebras vex.
10-22 22:19 myapp.area2 WARNING Jail zesty vixen who grabbed pay from quack.
10-22 22:19 myapp.area2 ERROR  The five boxing wizards jump quickly.

```

As you can see, the DEBUG message only shows up in the file. The other messages are sent to both destinations.
This example uses console and file handlers, but you can use any number and combination of handlers you choose.
Note that the above choice of log filename `/tmp/myapp.log` implies use of a standard location for temporary files on POSIX systems. On Windows, you may need to choose a different directory name for the log - just ensure that the directory exists and that you have the permissions to create and update files in it.
## Custom handling of levels[¶](https://docs.python.org/3/howto/logging-cookbook.html#custom-handling-of-levels "Link to this heading")
Sometimes, you might want to do something slightly different from the standard handling of levels in handlers, where all levels above a threshold get processed by a handler. To do this, you need to use filters. Let’s look at a scenario where you want to arrange things as follows:
  * Send messages of severity `INFO` and `WARNING` to `sys.stdout`
  * Send messages of severity `ERROR` and above to `sys.stderr`
  * Send messages of severity `DEBUG` and above to file `app.log`


Suppose you configure logging with the following JSON:
```
{
"version":1,
"disable_existing_loggers":false,
"formatters":{
"simple":{
"format":"%(levelname)-8s - %(message)s"
}
},
"handlers":{
"stdout":{
"class":"logging.StreamHandler",
"level":"INFO",
"formatter":"simple",
"stream":"ext://sys.stdout"
},
"stderr":{
"class":"logging.StreamHandler",
"level":"ERROR",
"formatter":"simple",
"stream":"ext://sys.stderr"
},
"file":{
"class":"logging.FileHandler",
"formatter":"simple",
"filename":"app.log",
"mode":"w"
}
},
"root":{
"level":"DEBUG",
"handlers":[
"stderr",
"stdout",
"file"
]
}
}

```

This configuration does _almost_ what we want, except that `sys.stdout` would show messages of severity `ERROR` and only events of this severity and higher will be tracked as well as `INFO` and `WARNING` messages. To prevent this, we can set up a filter which excludes those messages and add it to the relevant handler. This can be configured by adding a `filters` section parallel to `formatters` and `handlers`:
```
{
"filters":{
"warnings_and_below":{
"()":"__main__.filter_maker",
"level":"WARNING"
}
}
}

```

and changing the section on the `stdout` handler to add it:
```
{
"stdout":{
"class":"logging.StreamHandler",
"level":"INFO",
"formatter":"simple",
"stream":"ext://sys.stdout",
"filters":["warnings_and_below"]
}
}

```

A filter is just a function, so we can define the `filter_maker` (a factory function) as follows:
```
deffilter_maker(level):
  level = getattr(logging, level)
  deffilter(record):
    return record.levelno <= level
  return filter

```

This converts the string argument passed in to a numeric level, and returns a function which only returns `True` if the level of the passed in record is at or below the specified level. Note that in this example I have defined the `filter_maker` in a test script `main.py` that I run from the command line, so its module will be `__main__` - hence the `__main__.filter_maker` in the filter configuration. You will need to change that if you define it in a different module.
With the filter added, we can run `main.py`, which in full is:
```
importjson
importlogging
importlogging.config
CONFIG = '''
{
  "version": 1,
  "disable_existing_loggers": false,
  "formatters": {
    "simple": {
      "format": "%(levelname)-8s - %(message)s"
    }
  },
  "filters": {
    "warnings_and_below": {
      "()" : "__main__.filter_maker",
      "level": "WARNING"
    }
  },
  "handlers": {
    "stdout": {
      "class": "logging.StreamHandler",
      "level": "INFO",
      "formatter": "simple",
      "stream": "ext://sys.stdout",
      "filters": ["warnings_and_below"]
    },
    "stderr": {
      "class": "logging.StreamHandler",
      "level": "ERROR",
      "formatter": "simple",
      "stream": "ext://sys.stderr"
    },
    "file": {
      "class": "logging.FileHandler",
      "formatter": "simple",
      "filename": "app.log",
      "mode": "w"
    }
  },
  "root": {
    "level": "DEBUG",
    "handlers": [
      "stderr",
      "stdout",
      "file"
    ]
  }
}
'''
deffilter_maker(level):
  level = getattr(logging, level)
  deffilter(record):
    return record.levelno <= level
  return filter
logging.config.dictConfig(json.loads(CONFIG))
logging.debug('A DEBUG message')
logging.info('An INFO message')
logging.warning('A WARNING message')
logging.error('An ERROR message')
logging.critical('A CRITICAL message')

```

And after running it like this:
```
pythonmain.py2>stderr.log>stdout.log