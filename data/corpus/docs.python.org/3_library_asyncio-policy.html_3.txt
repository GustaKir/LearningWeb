Title: Child Watcher Implementations in asyncio
URL: https://docs.python.org/3/library/asyncio-policy.html
Summary: This section describes the `close` method for cleaning up resources in the child watcher, now deprecated since version 3.12. It also introduces two implementations: `ThreadedChildWatcher`, which operates in its own thread for each subprocess and is the default from version 3.8, and `MultiLoopChildWatcher`, which uses a different approach for handling child processes.
---

close()[¶](https://docs.python.org/3/library/asyncio-policy.html#asyncio.AbstractChildWatcher.close "Link to this definition")
    
Close the watcher.
This method has to be called to ensure that underlying resources are cleaned-up.
Deprecated since version 3.12. 

_class_ asyncio.ThreadedChildWatcher[¶](https://docs.python.org/3/library/asyncio-policy.html#asyncio.ThreadedChildWatcher "Link to this definition")
    
This implementation starts a new waiting thread for every subprocess spawn.
It works reliably even when the asyncio event loop is run in a non-main OS thread.
There is no noticeable overhead when handling a big number of children (_O_(1) each time a child terminates), but starting a thread per process requires extra memory.
This watcher is used by default.
Added in version 3.8. 

_class_ asyncio.MultiLoopChildWatcher[¶](https://docs.python.org/3/library/asyncio-policy.html#asyncio.MultiLoopChildWatcher "Link to this definition")
    
This implementation registers a `SIGCHLD` signal handler on instantiation. That can break third-party code that installs a custom handler for `SIGCHLD` signal.
The watcher avoids disrupting other code spawning processes by polling every process explicitly on a `SIGCHLD` signal.
There is no limitation for running subprocesses from different threads once the watcher is installed.
The solution is safe but it has a significant overhead when handling a big number of processes (_O_(_n_) each time a `SIGCHLD` is received).
Added in version 3.8.
Deprecated since version 3.12. 

_class_ asyncio.SafeChildWatcher[¶](https://docs.python.org/3/library/asyncio-policy.html#asyncio.SafeChildWatcher "Link to this definition")
    
This implementation uses active event loop from the main thread to handle `SIGCHLD` signal. If the main thread has no running event loop another thread cannot spawn a subprocess ([`RuntimeError`](https://docs.python.org/3/library/exceptions.html#RuntimeError "RuntimeError") is raised).
The watcher avoids disrupting other code spawning processes by polling every process explicitly on a `SIGCHLD` signal.
This solution is as safe as [`MultiLoopChildWatcher`](https://docs.python.org/3/library/asyncio-policy.html#asyncio.MultiLoopChildWatcher "asyncio.MultiLoopChildWatcher") and has the same _O_(_n_) complexity but requires a running event loop in the main thread to work.
Deprecated since version 3.12. 

_class_ asyncio.FastChildWatcher[¶](https://docs.python.org/3/library/asyncio-policy.html#asyncio.FastChildWatcher "Link to this definition")
    
This implementation reaps every terminated processes by calling `os.waitpid(-1)` directly, possibly breaking other code spawning processes and waiting for their termination.
There is no noticeable overhead when handling a big number of children (_O_(1) each time a child terminates).
This solution requires a running event loop in the main thread to work, as [`SafeChildWatcher`](https://docs.python.org/3/library/asyncio-policy.html#asyncio.SafeChildWatcher "asyncio.SafeChildWatcher").
Deprecated since version 3.12. 

_class_ asyncio.PidfdChildWatcher[¶](https://docs.python.org/3/library/asyncio-policy.html#asyncio.PidfdChildWatcher "Link to this definition")
    
This implementation polls process file descriptors (pidfds) to await child process termination. In some respects, [`PidfdChildWatcher`](https://docs.python.org/3/library/asyncio-policy.html#asyncio.PidfdChildWatcher "asyncio.PidfdChildWatcher") is a “Goldilocks” child watcher implementation. It doesn’t require signals or threads, doesn’t interfere with any processes launched outside the event loop, and scales linearly with the number of subprocesses launched by the event loop. The main disadvantage is that pidfds are specific to Linux, and only work on recent (5.3+) kernels.
Added in version 3.9.
## Custom Policies[¶](https://docs.python.org/3/library/asyncio-policy.html#custom-policies "Link to this heading")
To implement a new event loop policy, it is recommended to subclass [`DefaultEventLoopPolicy`](https://docs.python.org/3/library/asyncio-policy.html#asyncio.DefaultEventLoopPolicy "asyncio.DefaultEventLoopPolicy") and override the methods for which custom behavior is wanted, e.g.:
```
classMyEventLoopPolicy(asyncio.DefaultEventLoopPolicy):
  defget_event_loop(self):
"""Get the event loop.
    This may be None or an instance of EventLoop.
    """
    loop = super().get_event_loop()
    # Do something with loop ...
    return loop
asyncio.set_event_loop_policy(MyEventLoopPolicy())