Title: Decimal Power Function
URL: https://docs.python.org/3/library/decimal.html
Summary: The `power(x, y, modulo=None)` function computes `x` raised to the power of `y`, with optional modulo reduction. For negative `x`, `y` must be an integer. The result is exact only if `y` is integral and the result is finite. The function uses the rounding mode of the context, and special handling for `Decimal(0) ** Decimal(0)` results in `InvalidOperation`.
---

power(_x_ , _y_ , _modulo =None_)[¶](https://docs.python.org/3/library/decimal.html#decimal.Context.power "Link to this definition")
    
Return `x` to the power of `y`, reduced modulo `modulo` if given.
With two arguments, compute `x**y`. If `x` is negative then `y` must be integral. The result will be inexact unless `y` is integral and the result is finite and can be expressed exactly in ‘precision’ digits. The rounding mode of the context is used. Results are always correctly rounded in the Python version.
`Decimal(0) ** Decimal(0)` results in `InvalidOperation`, and if `InvalidOperation` is not trapped, then results in `Decimal('NaN')`.
Changed in version 3.3: The C module computes [`power()`](https://docs.python.org/3/library/decimal.html#decimal.Context.power "decimal.Context.power") in terms of the correctly rounded [`exp()`](https://docs.python.org/3/library/decimal.html#decimal.Context.exp "decimal.Context.exp") and [`ln()`](https://docs.python.org/3/library/decimal.html#decimal.Context.ln "decimal.Context.ln") functions. The result is well-defined but only “almost always correctly rounded”.
With three arguments, compute `(x**y) % modulo`. For the three argument form, the following restrictions on the arguments hold:
  * all three arguments must be integral
  * `y` must be nonnegative
  * at least one of `x` or `y` must be nonzero
  * `modulo` must be nonzero and have at most ‘precision’ digits


The value resulting from `Context.power(x, y, modulo)` is equal to the value that would be obtained by computing `(x**y) % modulo` with unbounded precision, but is computed more efficiently. The exponent of the result is zero, regardless of the exponents of `x`, `y` and `modulo`. The result is always exact. 

quantize(_x_ , _y_)[¶](https://docs.python.org/3/library/decimal.html#decimal.Context.quantize "Link to this definition")
    
Returns a value equal to _x_ (rounded), having the exponent of _y_. 

radix()[¶](https://docs.python.org/3/library/decimal.html#decimal.Context.radix "Link to this definition")
    
Just returns 10, as this is Decimal, :) 

remainder(_x_ , _y_)[¶](https://docs.python.org/3/library/decimal.html#decimal.Context.remainder "Link to this definition")
    
Returns the remainder from integer division.
The sign of the result, if non-zero, is the same as that of the original dividend. 

remainder_near(_x_ , _y_)[¶](https://docs.python.org/3/library/decimal.html#decimal.Context.remainder_near "Link to this definition")
    
Returns `x - y * n`, where _n_ is the integer nearest the exact value of `x / y` (if the result is 0 then its sign will be the sign of _x_). 

rotate(_x_ , _y_)[¶](https://docs.python.org/3/library/decimal.html#decimal.Context.rotate "Link to this definition")
    
Returns a rotated copy of _x_ , _y_ times. 

same_quantum(_x_ , _y_)[¶](https://docs.python.org/3/library/decimal.html#decimal.Context.same_quantum "Link to this definition")
    
Returns `True` if the two operands have the same exponent. 

scaleb(_x_ , _y_)[¶](https://docs.python.org/3/library/decimal.html#decimal.Context.scaleb "Link to this definition")
    
Returns the first operand after adding the second value its exp. 

shift(_x_ , _y_)[¶](https://docs.python.org/3/library/decimal.html#decimal.Context.shift "Link to this definition")
    
Returns a shifted copy of _x_ , _y_ times. 

sqrt(_x_)[¶](https://docs.python.org/3/library/decimal.html#decimal.Context.sqrt "Link to this definition")
    
Square root of a non-negative number to context precision. 

subtract(_x_ , _y_)[¶](https://docs.python.org/3/library/decimal.html#decimal.Context.subtract "Link to this definition")
    
Return the difference between _x_ and _y_. 

to_eng_string(_x_)[¶](https://docs.python.org/3/library/decimal.html#decimal.Context.to_eng_string "Link to this definition")
    
Convert to a string, using engineering notation if an exponent is needed.
Engineering notation has an exponent which is a multiple of 3. This can leave up to 3 digits to the left of the decimal place and may require the addition of either one or two trailing zeros. 

to_integral_exact(_x_)[¶](https://docs.python.org/3/library/decimal.html#decimal.Context.to_integral_exact "Link to this definition")
    
Rounds to an integer. 

to_sci_string(_x_)[¶](https://docs.python.org/3/library/decimal.html#decimal.Context.to_sci_string "Link to this definition")
    
Converts a number to a string using scientific notation.
## Constants[¶](https://docs.python.org/3/library/decimal.html#constants "Link to this heading")
The constants in this section are only relevant for the C module. They are also included in the pure Python version for compatibility.
| 32-bit | 64-bit  
---|---|--- 

decimal.MAX_PREC[¶](https://docs.python.org/3/library/decimal.html#decimal.MAX_PREC "Link to this definition")
| `425000000` | `999999999999999999`