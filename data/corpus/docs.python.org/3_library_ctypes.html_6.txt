Title: Using the strchr Function with ctypes
URL: https://docs.python.org/3/library/ctypes.html
Summary: This example demonstrates how to use the `strchr()` function in Python's `ctypes` library. It shows how to retrieve a string pointer and how to set the function's `restype` and `argtypes` for better argument handling. The example highlights the conversion of Python bytes objects into C character types.
---

```

Here is a more advanced example, it uses the `strchr()` function, which expects a string pointer and a char, and returns a pointer to a string:
>>>```
>>> strchr = libc.strchr
>>> strchr(b"abcdef", ord("d"))
8059983
>>> strchr.restype = c_char_p  # c_char_p is a pointer to a string
>>> strchr(b"abcdef", ord("d"))
b'def'
>>> print(strchr(b"abcdef", ord("x")))
None
>>>

```

If you want to avoid the [`ord("x")`](https://docs.python.org/3/library/functions.html#ord "ord") calls above, you can set the [`argtypes`](https://docs.python.org/3/library/ctypes.html#ctypes._CFuncPtr.argtypes "ctypes._CFuncPtr.argtypes") attribute, and the second argument will be converted from a single character Python bytes object into a C char:
>>>```
>>> strchr.restype = c_char_p
>>> strchr.argtypes = [c_char_p, c_char]
>>> strchr(b"abcdef", b"d")
b'def'
>>> strchr(b"abcdef", b"def")
Traceback (most recent call last):
ctypes.ArgumentError: argument 2: TypeError: one character bytes, bytearray or integer expected
>>> print(strchr(b"abcdef", b"x"))
None
>>> strchr(b"abcdef", b"d")
b'def'
>>>

```

You can also use a callable Python object (a function or a class for example) as the [`restype`](https://docs.python.org/3/library/ctypes.html#ctypes._CFuncPtr.restype "ctypes._CFuncPtr.restype") attribute, if the foreign function returns an integer. The callable will be called with the _integer_ the C function returns, and the result of this call will be used as the result of your function call. This is useful to check for error return values and automatically raise an exception:
>>>```
>>> GetModuleHandle = windll.kernel32.GetModuleHandleA
>>> defValidHandle(value):
...   if value == 0:
...     raise WinError()
...   return value
...
>>>
>>> GetModuleHandle.restype = ValidHandle
>>> GetModuleHandle(None)
486539264
>>> GetModuleHandle("something silly")
Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
 File "<stdin>", line 3, in ValidHandle
OSError: [Errno 126] The specified module could not be found.
>>>

```

`WinError` is a function which will call Windows `FormatMessage()` api to get the string representation of an error code, and _returns_ an exception. `WinError` takes an optional error code parameter, if no one is used, it calls [`GetLastError()`](https://docs.python.org/3/library/ctypes.html#ctypes.GetLastError "ctypes.GetLastError") to retrieve it.
Please note that a much more powerful error checking mechanism is available through the [`errcheck`](https://docs.python.org/3/library/ctypes.html#ctypes._CFuncPtr.errcheck "ctypes._CFuncPtr.errcheck") attribute; see the reference manual for details.
### Passing pointers (or: passing parameters by reference)[¶](https://docs.python.org/3/library/ctypes.html#passing-pointers-or-passing-parameters-by-reference "Link to this heading")
Sometimes a C api function expects a _pointer_ to a data type as parameter, probably to write into the corresponding location, or if the data is too large to be passed by value. This is also known as _passing parameters by reference_.
[`ctypes`](https://docs.python.org/3/library/ctypes.html#module-ctypes "ctypes: A foreign function library for Python.") exports the [`byref()`](https://docs.python.org/3/library/ctypes.html#ctypes.byref "ctypes.byref") function which is used to pass parameters by reference. The same effect can be achieved with the [`pointer()`](https://docs.python.org/3/library/ctypes.html#ctypes.pointer "ctypes.pointer") function, although [`pointer()`](https://docs.python.org/3/library/ctypes.html#ctypes.pointer "ctypes.pointer") does a lot more work since it constructs a real pointer object, so it is faster to use [`byref()`](https://docs.python.org/3/library/ctypes.html#ctypes.byref "ctypes.byref") if you don’t need the pointer object in Python itself:
>>>```
>>> i = c_int()
>>> f = c_float()
>>> s = create_string_buffer(b'\000' * 32)
>>> print(i.value, f.value, repr(s.value))
0 0.0 b''
>>> libc.sscanf(b"1 3.14 Hello", b"%d%f%s",
...       byref(i), byref(f), s)
3
>>> print(i.value, f.value, repr(s.value))
1 3.1400001049 b'Hello'
>>>