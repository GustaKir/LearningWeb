Title: Streaming Logging with LogRecordStreamHandler
URL: https://docs.python.org/3/howto/logging-cookbook.html
Summary: This section describes the implementation of a streaming logging handler using Python's socketserver. It details the LogRecordStreamHandler class, which processes incoming log records in a specific format, handling multiple requests and utilizing pickle for serialization. The class methods include unPickle for deserialization and handleLogRecord for logging the received records.
---

```
importpickle
importlogging
importlogging.handlers
importsocketserver
importstruct

classLogRecordStreamHandler(socketserver.StreamRequestHandler):
"""Handler for a streaming logging request.
  This basically logs the record using whatever logging policy is
  configured locally.
  """
  defhandle(self):
"""
    Handle multiple requests - each expected to be a 4-byte length,
    followed by the LogRecord in pickle format. Logs the record
    according to whatever policy is configured locally.
    """
    while True:
      chunk = self.connection.recv(4)
      if len(chunk) < 4:
        break
      slen = struct.unpack('>L', chunk)[0]
      chunk = self.connection.recv(slen)
      while len(chunk) < slen:
        chunk = chunk + self.connection.recv(slen - len(chunk))
      obj = self.unPickle(chunk)
      record = logging.makeLogRecord(obj)
      self.handleLogRecord(record)
  defunPickle(self, data):
    return pickle.loads(data)
  defhandleLogRecord(self, record):
    # if a name is specified, we use the named logger rather than the one
    # implied by the record.
    if self.server.logname is not None:
      name = self.server.logname
    else:
      name = record.name
    logger = logging.getLogger(name)
    # N.B. EVERY record gets logged. This is because Logger.handle
    # is normally called AFTER logger-level filtering. If you want
    # to do filtering, do it at the client end to save wasting
    # cycles and network bandwidth!
    logger.handle(record)
classLogRecordSocketReceiver(socketserver.ThreadingTCPServer):
"""
  Simple TCP socket-based logging receiver suitable for testing.
  """
  allow_reuse_address = True
  def__init__(self, host='localhost',
         port=logging.handlers.DEFAULT_TCP_LOGGING_PORT,
         handler=LogRecordStreamHandler):
    socketserver.ThreadingTCPServer.__init__(self, (host, port), handler)
    self.abort = 0
    self.timeout = 1
    self.logname = None
  defserve_until_stopped(self):
    importselect
    abort = 0
    while not abort:
      rd, wr, ex = select.select([self.socket.fileno()],
                    [], [],
                    self.timeout)
      if rd:
        self.handle_request()
      abort = self.abort
defmain():
  logging.basicConfig(
    format='%(relativeCreated)5d%(name)-15s%(levelname)-8s%(message)s')
  tcpserver = LogRecordSocketReceiver()
  print('About to start TCP server...')
  tcpserver.serve_until_stopped()
if __name__ == '__main__':
  main()

```

First run the server, and then the client. On the client side, nothing is printed on the console; on the server side, you should see something like:
```
About to start TCP server...
  59 root      INFO   Jackdaws love my big sphinx of quartz.
  59 myapp.area1   DEBUG  Quick zephyrs blow, vexing daft Jim.
  69 myapp.area1   INFO   How quickly daft jumping zebras vex.
  69 myapp.area2   WARNING Jail zesty vixen who grabbed pay from quack.
  69 myapp.area2   ERROR  The five boxing wizards jump quickly.