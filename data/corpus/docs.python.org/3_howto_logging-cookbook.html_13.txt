Title: Logging Cookbook: Simulating HTTP Requests
URL: https://docs.python.org/3/howto/logging-cookbook.html
Summary: This section of the Python logging cookbook introduces a basic setup for logging with a simple dummy Request class and a list of sample HTTP requests for simulation purposes, demonstrating how to effectively log different types of requests.
---

```
# main.py
importargparse
fromcontextvarsimport ContextVar
importlogging
importos
fromrandomimport choice
importthreading
importwebapplib
logger = logging.getLogger(__name__)
root = logging.getLogger()
root.setLevel(logging.DEBUG)
classRequest:
"""
  A simple dummy request class which just holds dummy HTTP request method,
  client IP address and client username
  """
  def__init__(self, method, ip, user):
    self.method = method
    self.ip = ip
    self.user = user
# A dummy set of requests which will be used in the simulation - we'll just pick
# from this list randomly. Note that all GET requests are from 192.168.2.XXX
# addresses, whereas POST requests are from 192.16.3.XXX addresses. Three users
# are represented in the sample requests.
REQUESTS = [
  Request('GET', '192.168.2.20', 'jim'),
  Request('POST', '192.168.3.20', 'fred'),
  Request('GET', '192.168.2.21', 'sheila'),
  Request('POST', '192.168.3.21', 'jim'),
  Request('GET', '192.168.2.22', 'fred'),
  Request('POST', '192.168.3.22', 'sheila'),
]
# Note that the format string includes references to request context information
# such as HTTP method, client IP and username
formatter = logging.Formatter('%(threadName)-11s%(appName)s%(name)-9s%(user)-6s%(ip)s%(method)-4s%(message)s')
# Create our context variables. These will be filled at the start of request
# processing, and used in the logging that happens during that processing
ctx_request = ContextVar('request')
ctx_appname = ContextVar('appname')
classInjectingFilter(logging.Filter):
"""
  A filter which injects context-specific information into logs and ensures
  that only information for a specific webapp is included in its log
  """
  def__init__(self, app):
    self.app = app
  deffilter(self, record):
    request = ctx_request.get()
    record.method = request.method
    record.ip = request.ip
    record.user = request.user
    record.appName = appName = ctx_appname.get()
    return appName == self.app.name
classWebApp:
"""
  A dummy web application class which has its own handler and filter for a
  webapp-specific log.
  """
  def__init__(self, name):
    self.name = name
    handler = logging.FileHandler(name + '.log', 'w')
    f = InjectingFilter(self)
    handler.setFormatter(formatter)
    handler.addFilter(f)
    root.addHandler(handler)
    self.num_requests = 0
  defprocess_request(self, request):
"""
    This is the dummy method for processing a request. It's called on a
    different thread for every request. We store the context information into
    the context vars before doing anything else.
    """
    ctx_request.set(request)
    ctx_appname.set(self.name)
    self.num_requests += 1
    logger.debug('Request processing started')
    webapplib.useful()
    logger.debug('Request processing finished')
defmain():
  fn = os.path.splitext(os.path.basename(__file__))[0]
  adhf = argparse.ArgumentDefaultsHelpFormatter
  ap = argparse.ArgumentParser(formatter_class=adhf, prog=fn,
                 description='Simulate a couple of web '
                       'applications handling some '
                       'requests, showing how request '
                       'context can be used to '
                       'populate logs')
  aa = ap.add_argument
  aa('--count', '-c', type=int, default=100, help='How many requests to simulate')
  options = ap.parse_args()
  # Create the dummy webapps and put them in a list which we can use to select
  # from randomly
  app1 = WebApp('app1')
  app2 = WebApp('app2')
  apps = [app1, app2]
  threads = []
  # Add a common handler which will capture all events
  handler = logging.FileHandler('app.log', 'w')
  handler.setFormatter(formatter)
  root.addHandler(handler)
  # Generate calls to process requests
  for i in range(options.count):
    try:
      # Pick an app at random and a request for it to process
      app = choice(apps)
      request = choice(REQUESTS)
      # Process the request in its own thread
      t = threading.Thread(target=app.process_request, args=(request,))
      threads.append(t)
      t.start()
    except KeyboardInterrupt:
      break
  # Wait for the threads to terminate
  for t in threads:
    t.join()
  for app in apps:
    print('%s processed %s requests' % (app.name, app.num_requests))
if __name__ == '__main__':
  main()

```

If you run the above, you should find that roughly half the requests go into `app1.log` and the rest into `app2.log`, and the all the requests are logged to `app.log`. Each webapp-specific log will contain only log entries for only that webapp, and the request information will be displayed consistently in the log (i.e. the information in each dummy request will always appear together in a log line). This is illustrated by the following shell output: