Title: Built-in Functions - issubclass and iter
URL: https://docs.python.org/3/library/functions.html
Summary: The section describes the built-in functions 'issubclass' and 'iter'. The 'issubclass' function checks if a class is a subclass of another class or classes, including support for Union Types as of version 3.10. The 'iter' function is introduced but details are not complete in this chunk.
---

issubclass(_class_ , _classinfo_)[¶](https://docs.python.org/3/library/functions.html#issubclass "Link to this definition")
    
Return `True` if _class_ is a subclass (direct, indirect, or [virtual](https://docs.python.org/3/glossary.html#term-abstract-base-class)) of _classinfo_. A class is considered a subclass of itself. _classinfo_ may be a tuple of class objects (or recursively, other such tuples) or a [Union Type](https://docs.python.org/3/library/stdtypes.html#types-union), in which case return `True` if _class_ is a subclass of any entry in _classinfo_. In any other case, a [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError "TypeError") exception is raised.
Changed in version 3.10: _classinfo_ can be a [Union Type](https://docs.python.org/3/library/stdtypes.html#types-union). 

iter(_object_)[¶](https://docs.python.org/3/library/functions.html#iter "Link to this definition")


iter(_object_ , _sentinel_)
    
Return an [iterator](https://docs.python.org/3/glossary.html#term-iterator) object. The first argument is interpreted very differently depending on the presence of the second argument. Without a second argument, _object_ must be a collection object which supports the [iterable](https://docs.python.org/3/glossary.html#term-iterable) protocol (the [`__iter__()`](https://docs.python.org/3/reference/datamodel.html#object.__iter__ "object.__iter__") method), or it must support the sequence protocol (the [`__getitem__()`](https://docs.python.org/3/reference/datamodel.html#object.__getitem__ "object.__getitem__") method with integer arguments starting at `0`). If it does not support either of those protocols, [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError "TypeError") is raised. If the second argument, _sentinel_ , is given, then _object_ must be a callable object. The iterator created in this case will call _object_ with no arguments for each call to its [`__next__()`](https://docs.python.org/3/library/stdtypes.html#iterator.__next__ "iterator.__next__") method; if the value returned is equal to _sentinel_ , [`StopIteration`](https://docs.python.org/3/library/exceptions.html#StopIteration "StopIteration") will be raised, otherwise the value will be returned.
See also [Iterator Types](https://docs.python.org/3/library/stdtypes.html#typeiter).
One useful application of the second form of [`iter()`](https://docs.python.org/3/library/functions.html#iter "iter") is to build a block-reader. For example, reading fixed-width blocks from a binary database file until the end of file is reached:
```
fromfunctoolsimport partial
with open('mydata.db', 'rb') as f:
  for block in iter(partial(f.read, 64), b''):
    process_block(block)