Title: Mutability in Python: Understanding Object Assignment
URL: https://docs.python.org/3/faq/programming.html
Summary: This section explains the concept of mutability in Python, highlighting how integers are immutable. It describes how operations on mutable versus immutable objects differ, particularly focusing on variable assignments and method behaviors, including the distinction between mutating and creating new objects.
---

```

we can see that in this case `x` and `y` are not equal anymore. This is because integers are [immutable](https://docs.python.org/3/glossary.html#term-immutable), and when we do `x = x + 1` we are not mutating the int `5` by incrementing its value; instead, we are creating a new object (the int `6`) and assigning it to `x` (that is, changing which object `x` refers to). After this assignment we have two objects (the ints `6` and `5`) and two variables that refer to them (`x` now refers to `6` but `y` still refers to `5`).
Some operations (for example `y.append(10)` and `y.sort()`) mutate the object, whereas superficially similar operations (for example `y = y + [10]` and [`sorted(y)`](https://docs.python.org/3/library/functions.html#sorted "sorted")) create a new object. In general in Python (and in all cases in the standard library) a method that mutates an object will return `None` to help avoid getting the two types of operations confused. So if you mistakenly write `y.sort()` thinking it will give you a sorted copy of `y`, you’ll instead end up with `None`, which will likely cause your program to generate an easily diagnosed error.
However, there is one class of operations where the same operation sometimes has different behaviors with different types: the augmented assignment operators. For example, `+=` mutates lists but not tuples or ints (`a_list += [1, 2, 3]` is equivalent to `a_list.extend([1, 2, 3])` and mutates `a_list`, whereas `some_tuple += (1, 2, 3)` and `some_int += 1` create new objects).
In other words:
  * If we have a mutable object ([`list`](https://docs.python.org/3/library/stdtypes.html#list "list"), [`dict`](https://docs.python.org/3/library/stdtypes.html#dict "dict"), [`set`](https://docs.python.org/3/library/stdtypes.html#set "set"), etc.), we can use some specific operations to mutate it and all the variables that refer to it will see the change.
  * If we have an immutable object ([`str`](https://docs.python.org/3/library/stdtypes.html#str "str"), [`int`](https://docs.python.org/3/library/functions.html#int "int"), [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "tuple"), etc.), all the variables that refer to it will always see the same value, but operations that transform that value into a new value always return a new object.


If you want to know if two variables refer to the same object or not, you can use the [`is`](https://docs.python.org/3/reference/expressions.html#is) operator, or the built-in function [`id()`](https://docs.python.org/3/library/functions.html#id "id").
### [How do I write a function with output parameters (call by reference)?](https://docs.python.org/3/faq/programming.html#id18)[¶](https://docs.python.org/3/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference "Link to this heading")
Remember that arguments are passed by assignment in Python. Since assignment just creates references to objects, there’s no alias between an argument name in the caller and callee, and so no call-by-reference per se. You can achieve the desired effect in a number of ways.
  1. By returning a tuple of the results:
>>>```
>>> deffunc1(a, b):
...   a = 'new-value'    # a and b are local names
...   b = b + 1       # assigned to new objects
...   return a, b      # return new values
...
>>> x, y = 'old-value', 99
>>> func1(x, y)
('new-value', 100)

```

This is almost always the clearest solution.
  2. By using global variables. This isn’t thread-safe, and is not recommended.
  3. By passing a mutable (changeable in-place) object:
>>>```
>>> deffunc2(a):
...   a[0] = 'new-value'   # 'a' references a mutable list
...   a[1] = a[1] + 1    # changes a shared object
...
>>> args = ['old-value', 99]
>>> func2(args)
>>> args
['new-value', 100]

```

  4. By passing in a dictionary that gets mutated:
>>>```
>>> deffunc3(args):
...   args['a'] = 'new-value'   # args is a mutable dictionary
...   args['b'] = args['b'] + 1  # change it in-place
...
>>> args = {'a': 'old-value', 'b': 99}
>>> func3(args)
>>> args
{'a': 'new-value', 'b': 100}

```

  5. Or bundle up values in a class instance:
>>>```
>>> classNamespace:
...   def__init__(self, /, **args):
...     for key, value in args.items():
...       setattr(self, key, value)
...
>>> deffunc4(args):
...   args.a = 'new-value'    # args is a mutable Namespace
...   args.b = args.b + 1     # change object in-place
...
>>> args = Namespace(a='old-value', b=99)
>>> func4(args)
>>> vars(args)
{'a': 'new-value', 'b': 100}