Title: Inspect Module - Closure Variable Mapping
URL: https://docs.python.org/3/library/inspect.html
Summary: This section discusses the `inspect.getclosurevars()` function introduced in Python 3.2 and deprecated in 3.5, recommending the use of `Signature.bind()` and `Signature.bind_partial()` instead. It describes how `getclosurevars()` retrieves a mapping of external name references in a function to their current values, returning a named tuple containing non-locals, globals, builtins, and unbound names.
---

```

Added in version 3.2.
Deprecated since version 3.5: Use [`Signature.bind()`](https://docs.python.org/3/library/inspect.html#inspect.Signature.bind "inspect.Signature.bind") and [`Signature.bind_partial()`](https://docs.python.org/3/library/inspect.html#inspect.Signature.bind_partial "inspect.Signature.bind_partial") instead. 

inspect.getclosurevars(_func_)[¶](https://docs.python.org/3/library/inspect.html#inspect.getclosurevars "Link to this definition")
    
Get the mapping of external name references in a Python function or method _func_ to their current values. A [named tuple](https://docs.python.org/3/glossary.html#term-named-tuple) `ClosureVars(nonlocals, globals, builtins, unbound)` is returned. _nonlocals_ maps referenced names to lexical closure variables, _globals_ to the function’s module globals and _builtins_ to the builtins visible from the function body. _unbound_ is the set of names referenced in the function that could not be resolved at all given the current module globals and builtins.
[`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError "TypeError") is raised if _func_ is not a Python function or method.
Added in version 3.3. 

inspect.unwrap(_func_ , _*_ , _stop =None_)[¶](https://docs.python.org/3/library/inspect.html#inspect.unwrap "Link to this definition")
    
Get the object wrapped by _func_. It follows the chain of `__wrapped__` attributes returning the last object in the chain.
_stop_ is an optional callback accepting an object in the wrapper chain as its sole argument that allows the unwrapping to be terminated early if the callback returns a true value. If the callback never returns a true value, the last object in the chain is returned as usual. For example, [`signature()`](https://docs.python.org/3/library/inspect.html#inspect.signature "inspect.signature") uses this to stop unwrapping if any object in the chain has a `__signature__` attribute defined.
[`ValueError`](https://docs.python.org/3/library/exceptions.html#ValueError "ValueError") is raised if a cycle is encountered.
Added in version 3.4. 

inspect.get_annotations(_obj_ , _*_ , _globals =None_, _locals =None_, _eval_str =False_)[¶](https://docs.python.org/3/library/inspect.html#inspect.get_annotations "Link to this definition")
    
Compute the annotations dict for an object.
`obj` may be a callable, class, or module. Passing in an object of any other type raises [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError "TypeError").
Returns a dict. `get_annotations()` returns a new dict every time it’s called; calling it twice on the same object will return two different but equivalent dicts.
This function handles several details for you:
  * If `eval_str` is true, values of type `str` will be un-stringized using [`eval()`](https://docs.python.org/3/library/functions.html#eval "eval"). This is intended for use with stringized annotations (`from __future__ import annotations`).
  * If `obj` doesn’t have an annotations dict, returns an empty dict. (Functions and methods always have an annotations dict; classes, modules, and other types of callables may not.)
  * Ignores inherited annotations on classes. If a class doesn’t have its own annotations dict, returns an empty dict.
  * All accesses to object members and dict values are done using `getattr()` and `dict.get()` for safety.
  * Always, always, always returns a freshly created dict.


`eval_str` controls whether or not values of type `str` are replaced with the result of calling [`eval()`](https://docs.python.org/3/library/functions.html#eval "eval") on those values:
  * If eval_str is true, [`eval()`](https://docs.python.org/3/library/functions.html#eval "eval") is called on values of type `str`. (Note that `get_annotations` doesn’t catch exceptions; if [`eval()`](https://docs.python.org/3/library/functions.html#eval "eval") raises an exception, it will unwind the stack past the `get_annotations` call.)
  * If eval_str is false (the default), values of type `str` are unchanged.


`globals` and `locals` are passed in to [`eval()`](https://docs.python.org/3/library/functions.html#eval "eval"); see the documentation for [`eval()`](https://docs.python.org/3/library/functions.html#eval "eval") for more information. If `globals` or `locals` is `None`, this function may replace that value with a context-specific default, contingent on `type(obj)`:
  * If `obj` is a module, `globals` defaults to `obj.__dict__`.
  * If `obj` is a class, `globals` defaults to `sys.modules[obj.__module__].__dict__` and `locals` defaults to the `obj` class namespace.
  * If `obj` is a callable, `globals` defaults to [`obj.__globals__`](https://docs.python.org/3/reference/datamodel.html#function.__globals__ "function.__globals__"), although if `obj` is a wrapped function (using [`functools.update_wrapper()`](https://docs.python.org/3/library/functools.html#functools.update_wrapper "functools.update_wrapper")) it is first unwrapped.