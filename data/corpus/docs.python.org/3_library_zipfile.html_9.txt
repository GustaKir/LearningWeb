Title: ZipFile Module - Path Suffixes and Read Text
URL: https://docs.python.org/3/library/zipfile.html
Summary: The ZipFile module introduces the `Path.suffixes` property, which provides a list of file extensions for paths, added in version 3.11. Additionally, the `Path.read_text()` method allows reading files as Unicode text, with changes in version 3.11.2 enabling the `encoding` parameter to be passed as a positional argument without resulting in a TypeError.
---

Path.suffixes[¶](https://docs.python.org/3/library/zipfile.html#zipfile.Path.suffixes "Link to this definition")
    
A list of the path’s suffixes, commonly called file extensions.
Added in version 3.11: Added [`Path.suffixes`](https://docs.python.org/3/library/zipfile.html#zipfile.Path.suffixes "zipfile.Path.suffixes") property. 

Path.read_text(_*_ , _**_)[¶](https://docs.python.org/3/library/zipfile.html#zipfile.Path.read_text "Link to this definition")
    
Read the current file as unicode text. Positional and keyword arguments are passed through to [`io.TextIOWrapper`](https://docs.python.org/3/library/io.html#io.TextIOWrapper "io.TextIOWrapper") (except `buffer`, which is implied by the context).
Changed in version 3.11.2: The `encoding` parameter can be supplied as a positional argument without causing a [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError "TypeError"). As it could in 3.9. Code needing to be compatible with unpatched 3.10 and 3.11 versions must pass all [`io.TextIOWrapper`](https://docs.python.org/3/library/io.html#io.TextIOWrapper "io.TextIOWrapper") arguments, `encoding` included, as keywords. 

Path.read_bytes()[¶](https://docs.python.org/3/library/zipfile.html#zipfile.Path.read_bytes "Link to this definition")
    
Read the current file as bytes. 

Path.joinpath(_* other_)[¶](https://docs.python.org/3/library/zipfile.html#zipfile.Path.joinpath "Link to this definition")
    
Return a new Path object with each of the _other_ arguments joined. The following are equivalent:
>>>```
>>> Path(...).joinpath('child').joinpath('grandchild')
>>> Path(...).joinpath('child', 'grandchild')
>>> Path(...) / 'child' / 'grandchild'

```

Changed in version 3.10: Prior to 3.10, `joinpath` was undocumented and accepted exactly one parameter.
The [zipp](https://pypi.org/project/zipp/) project provides backports of the latest path object functionality to older Pythons. Use `zipp.Path` in place of `zipfile.Path` for early access to changes.
## PyZipFile Objects[¶](https://docs.python.org/3/library/zipfile.html#pyzipfile-objects "Link to this heading")
The [`PyZipFile`](https://docs.python.org/3/library/zipfile.html#zipfile.PyZipFile "zipfile.PyZipFile") constructor takes the same parameters as the [`ZipFile`](https://docs.python.org/3/library/zipfile.html#zipfile.ZipFile "zipfile.ZipFile") constructor, and one additional parameter, _optimize_. 

_class_ zipfile.PyZipFile(_file_ , _mode ='r'_, _compression =ZIP_STORED_, _allowZip64 =True_, _optimize =-1_)[¶](https://docs.python.org/3/library/zipfile.html#zipfile.PyZipFile "Link to this definition")
    
Changed in version 3.2: Added the _optimize_ parameter.
Changed in version 3.4: ZIP64 extensions are enabled by default.
Instances have one method in addition to those of [`ZipFile`](https://docs.python.org/3/library/zipfile.html#zipfile.ZipFile "zipfile.ZipFile") objects: 

writepy(_pathname_ , _basename =''_, _filterfunc =None_)[¶](https://docs.python.org/3/library/zipfile.html#zipfile.PyZipFile.writepy "Link to this definition")
    
Search for files `*.py` and add the corresponding file to the archive.
If the _optimize_ parameter to [`PyZipFile`](https://docs.python.org/3/library/zipfile.html#zipfile.PyZipFile "zipfile.PyZipFile") was not given or `-1`, the corresponding file is a `*.pyc` file, compiling if necessary.
If the _optimize_ parameter to [`PyZipFile`](https://docs.python.org/3/library/zipfile.html#zipfile.PyZipFile "zipfile.PyZipFile") was `0`, `1` or `2`, only files with that optimization level (see [`compile()`](https://docs.python.org/3/library/functions.html#compile "compile")) are added to the archive, compiling if necessary.
If _pathname_ is a file, the filename must end with `.py`, and just the (corresponding `*.pyc`) file is added at the top level (no path information). If _pathname_ is a file that does not end with `.py`, a [`RuntimeError`](https://docs.python.org/3/library/exceptions.html#RuntimeError "RuntimeError") will be raised. If it is a directory, and the directory is not a package directory, then all the files `*.pyc` are added at the top level. If the directory is a package directory, then all `*.pyc` are added under the package name as a file path, and if any subdirectories are package directories, all of these are added recursively in sorted order.
_basename_ is intended for internal use only.
_filterfunc_ , if given, must be a function taking a single string argument. It will be passed each path (including each individual full file path) before it is added to the archive. If _filterfunc_ returns a false value, the path will not be added, and if it is a directory its contents will be ignored. For example, if our test files are all either in `test` directories or start with the string `test_`, we can use a _filterfunc_ to exclude them:
>>>