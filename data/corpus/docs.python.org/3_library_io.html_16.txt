Title: IncrementalNewlineDecoder and I/O Performance
URL: https://docs.python.org/3/library/io.html
Summary: This section introduces the `io.IncrementalNewlineDecoder`, a codec for decoding newlines in universal newline mode, and discusses the performance of I/O implementations, particularly highlighting the efficiency of buffered binary I/O compared to unbuffered routines.
---

```


_class_ io.IncrementalNewlineDecoder[¶](https://docs.python.org/3/library/io.html#io.IncrementalNewlineDecoder "Link to this definition")
    
A helper codec that decodes newlines for [universal newlines](https://docs.python.org/3/glossary.html#term-universal-newlines) mode. It inherits from [`codecs.IncrementalDecoder`](https://docs.python.org/3/library/codecs.html#codecs.IncrementalDecoder "codecs.IncrementalDecoder").
## Performance[¶](https://docs.python.org/3/library/io.html#performance "Link to this heading")
This section discusses the performance of the provided concrete I/O implementations.
### Binary I/O[¶](https://docs.python.org/3/library/io.html#id2 "Link to this heading")
By reading and writing only large chunks of data even when the user asks for a single byte, buffered I/O hides any inefficiency in calling and executing the operating system’s unbuffered I/O routines. The gain depends on the OS and the kind of I/O which is performed. For example, on some modern OSes such as Linux, unbuffered disk I/O can be as fast as buffered I/O. The bottom line, however, is that buffered I/O offers predictable performance regardless of the platform and the backing device. Therefore, it is almost always preferable to use buffered I/O rather than unbuffered I/O for binary data.
### Text I/O[¶](https://docs.python.org/3/library/io.html#id3 "Link to this heading")
Text I/O over a binary storage (such as a file) is significantly slower than binary I/O over the same storage, because it requires conversions between unicode and binary data using a character codec. This can become noticeable handling huge amounts of text data like large log files. Also, [`tell()`](https://docs.python.org/3/library/io.html#io.TextIOBase.tell "io.TextIOBase.tell") and [`seek()`](https://docs.python.org/3/library/io.html#io.TextIOBase.seek "io.TextIOBase.seek") are both quite slow due to the reconstruction algorithm used.
[`StringIO`](https://docs.python.org/3/library/io.html#io.StringIO "io.StringIO"), however, is a native in-memory unicode container and will exhibit similar speed to [`BytesIO`](https://docs.python.org/3/library/io.html#io.BytesIO "io.BytesIO").
### Multi-threading[¶](https://docs.python.org/3/library/io.html#multi-threading "Link to this heading")
[`FileIO`](https://docs.python.org/3/library/io.html#io.FileIO "io.FileIO") objects are thread-safe to the extent that the operating system calls (such as _[read(2)](https://manpages.debian.org/read\(2\))_ under Unix) they wrap are thread-safe too.
Binary buffered objects (instances of [`BufferedReader`](https://docs.python.org/3/library/io.html#io.BufferedReader "io.BufferedReader"), [`BufferedWriter`](https://docs.python.org/3/library/io.html#io.BufferedWriter "io.BufferedWriter"), [`BufferedRandom`](https://docs.python.org/3/library/io.html#io.BufferedRandom "io.BufferedRandom") and [`BufferedRWPair`](https://docs.python.org/3/library/io.html#io.BufferedRWPair "io.BufferedRWPair")) protect their internal structures using a lock; it is therefore safe to call them from multiple threads at once.
[`TextIOWrapper`](https://docs.python.org/3/library/io.html#io.TextIOWrapper "io.TextIOWrapper") objects are not thread-safe.
### Reentrancy[¶](https://docs.python.org/3/library/io.html#reentrancy "Link to this heading")
Binary buffered objects (instances of [`BufferedReader`](https://docs.python.org/3/library/io.html#io.BufferedReader "io.BufferedReader"), [`BufferedWriter`](https://docs.python.org/3/library/io.html#io.BufferedWriter "io.BufferedWriter"), [`BufferedRandom`](https://docs.python.org/3/library/io.html#io.BufferedRandom "io.BufferedRandom") and [`BufferedRWPair`](https://docs.python.org/3/library/io.html#io.BufferedRWPair "io.BufferedRWPair")) are not reentrant. While reentrant calls will not happen in normal situations, they can arise from doing I/O in a [`signal`](https://docs.python.org/3/library/signal.html#module-signal "signal: Set handlers for asynchronous events.") handler. If a thread tries to re-enter a buffered object which it is already accessing, a [`RuntimeError`](https://docs.python.org/3/library/exceptions.html#RuntimeError "RuntimeError") is raised. Note this doesn’t prohibit a different thread from entering the buffered object.
The above implicitly extends to text files, since the [`open()`](https://docs.python.org/3/library/functions.html#open "open") function will wrap a buffered object inside a [`TextIOWrapper`](https://docs.python.org/3/library/io.html#io.TextIOWrapper "io.TextIOWrapper"). This includes standard streams and therefore affects the built-in [`print()`](https://docs.python.org/3/library/functions.html#print "print") function as well.
### [Table of Contents](https://docs.python.org/3/contents.html)
  * [`io` — Core tools for working with streams](https://docs.python.org/3/library/io.html)
    * [Overview](https://docs.python.org/3/library/io.html#overview)
      * [Text I/O](https://docs.python.org/3/library/io.html#text-i-o)