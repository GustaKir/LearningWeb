Title: Bisect Module Function Definitions
URL: https://docs.python.org/3/library/bisect.html
Summary: This section provides definitions for functions in the bisect module, including 'findindex', 'find_lt', 'find_le', 'find_gt', and 'find_ge'. Each function is designed to locate values in a sorted list based on various criteria, such as finding the leftmost or rightmost value relative to a specified value.
---

```
defindex(a, x):
  'Locate the leftmost value exactly equal to x'
  i = bisect_left(a, x)
  if i != len(a) and a[i] == x:
    return i
  raise ValueError
deffind_lt(a, x):
  'Find rightmost value less than x'
  i = bisect_left(a, x)
  if i:
    return a[i-1]
  raise ValueError
deffind_le(a, x):
  'Find rightmost value less than or equal to x'
  i = bisect_right(a, x)
  if i:
    return a[i-1]
  raise ValueError
deffind_gt(a, x):
  'Find leftmost value greater than x'
  i = bisect_right(a, x)
  if i != len(a):
    return a[i]
  raise ValueError
deffind_ge(a, x):
  'Find leftmost item greater than or equal to x'
  i = bisect_left(a, x)
  if i != len(a):
    return a[i]
  raise ValueError

```

## Examples[¶](https://docs.python.org/3/library/bisect.html#examples "Link to this heading")
The [`bisect()`](https://docs.python.org/3/library/bisect.html#bisect.bisect "bisect.bisect") function can be useful for numeric table lookups. This example uses [`bisect()`](https://docs.python.org/3/library/bisect.html#bisect.bisect "bisect.bisect") to look up a letter grade for an exam score (say) based on a set of ordered numeric breakpoints: 90 and up is an ‘A’, 80 to 89 is a ‘B’, and so on:
>>>```
>>> defgrade(score, breakpoints=[60, 70, 80, 90], grades='FDCBA'):
...   i = bisect(breakpoints, score)
...   return grades[i]
...
>>> [grade(score) for score in [33, 99, 77, 70, 89, 90, 100]]
['F', 'A', 'C', 'C', 'B', 'A', 'A']

```

The [`bisect()`](https://docs.python.org/3/library/bisect.html#bisect.bisect "bisect.bisect") and [`insort()`](https://docs.python.org/3/library/bisect.html#bisect.insort "bisect.insort") functions also work with lists of tuples. The _key_ argument can serve to extract the field used for ordering records in a table:
>>>```
>>> fromcollectionsimport namedtuple
>>> fromoperatorimport attrgetter
>>> frombisectimport bisect, insort
>>> frompprintimport pprint
>>> Movie = namedtuple('Movie', ('name', 'released', 'director'))
>>> movies = [
...   Movie('Jaws', 1975, 'Spielberg'),
...   Movie('Titanic', 1997, 'Cameron'),
...   Movie('The Birds', 1963, 'Hitchcock'),
...   Movie('Aliens', 1986, 'Cameron')
... ]
>>> # Find the first movie released after 1960
>>> by_year = attrgetter('released')
>>> movies.sort(key=by_year)
>>> movies[bisect(movies, 1960, key=by_year)]
Movie(name='The Birds', released=1963, director='Hitchcock')
>>> # Insert a movie while maintaining sort order
>>> romance = Movie('Love Story', 1970, 'Hiller')
>>> insort(movies, romance, key=by_year)
>>> pprint(movies)
[Movie(name='The Birds', released=1963, director='Hitchcock'),
 Movie(name='Love Story', released=1970, director='Hiller'),
 Movie(name='Jaws', released=1975, director='Spielberg'),
 Movie(name='Aliens', released=1986, director='Cameron'),
 Movie(name='Titanic', released=1997, director='Cameron')]

```

If the key function is expensive, it is possible to avoid repeated function calls by searching a list of precomputed keys to find the index of a record:
>>>```
>>> data = [('red', 5), ('blue', 1), ('yellow', 8), ('black', 0)]
>>> data.sort(key=lambda r: r[1])    # Or use operator.itemgetter(1).
>>> keys = [r[1] for r in data]     # Precompute a list of keys.
>>> data[bisect_left(keys, 0)]
('black', 0)
>>> data[bisect_left(keys, 1)]
('blue', 1)
>>> data[bisect_left(keys, 5)]
('red', 5)
>>> data[bisect_left(keys, 8)]
('yellow', 8)