Title: GenericAlias and Type Parameters in Python
URL: https://docs.python.org/3/library/stdtypes.html
Summary: This section discusses the behavior of `GenericAlias` objects, highlighting issues with `__parameters__` when using `typing.ParamSpec`. It also explains the `__unpacked__` attribute, which indicates if the alias has been unpacked using the `*` operator, a feature introduced in Python 3.11. Additionally, it references PEPs related to type hints and generics in standard collections.
---

```

Note
A `GenericAlias` object with [`typing.ParamSpec`](https://docs.python.org/3/library/typing.html#typing.ParamSpec "typing.ParamSpec") parameters may not have correct `__parameters__` after substitution because [`typing.ParamSpec`](https://docs.python.org/3/library/typing.html#typing.ParamSpec "typing.ParamSpec") is intended primarily for static type checking. 

genericalias.__unpacked__[¶](https://docs.python.org/3/library/stdtypes.html#genericalias.__unpacked__ "Link to this definition")
    
A boolean that is true if the alias has been unpacked using the `*` operator (see [`TypeVarTuple`](https://docs.python.org/3/library/typing.html#typing.TypeVarTuple "typing.TypeVarTuple")).
Added in version 3.11.
See also 

[**PEP 484**](https://peps.python.org/pep-0484/) - Type Hints
    
Introducing Python’s framework for type annotations. 

[**PEP 585**](https://peps.python.org/pep-0585/) - Type Hinting Generics In Standard Collections
    
Introducing the ability to natively parameterize standard-library classes, provided they implement the special class method [`__class_getitem__()`](https://docs.python.org/3/reference/datamodel.html#object.__class_getitem__ "object.__class_getitem__"). 

[Generics](https://docs.python.org/3/library/typing.html#generics), [user-defined generics](https://docs.python.org/3/library/typing.html#user-defined-generics) and [`typing.Generic`](https://docs.python.org/3/library/typing.html#typing.Generic "typing.Generic")
    
Documentation on how to implement generic classes that can be parameterized at runtime and understood by static type-checkers.
Added in version 3.9.
### Union Type[¶](https://docs.python.org/3/library/stdtypes.html#union-type "Link to this heading")
A union object holds the value of the `|` (bitwise or) operation on multiple [type objects](https://docs.python.org/3/library/stdtypes.html#bltin-type-objects). These types are intended primarily for [type annotations](https://docs.python.org/3/glossary.html#term-annotation). The union type expression enables cleaner type hinting syntax compared to [`typing.Union`](https://docs.python.org/3/library/typing.html#typing.Union "typing.Union"). 

X | Y | ...
    
Defines a union object which holds types _X_ , _Y_ , and so forth. `X | Y` means either X or Y. It is equivalent to `typing.Union[X, Y]`. For example, the following function expects an argument of type [`int`](https://docs.python.org/3/library/functions.html#int "int") or [`float`](https://docs.python.org/3/library/functions.html#float "float"):
```
defsquare(number: int | float) -> int | float:
  return number ** 2

```

Note
The `|` operand cannot be used at runtime to define unions where one or more members is a forward reference. For example, `int | "Foo"`, where `"Foo"` is a reference to a class not yet defined, will fail at runtime. For unions which include forward references, present the whole expression as a string, e.g. `"int | Foo"`. 

union_object == other
    
Union objects can be tested for equality with other union objects. Details:
  * Unions of unions are flattened:
```
(int | str) | float == int | str | float

```

  * Redundant types are removed:
```
int | str | int == int | str

```

  * When comparing unions, the order is ignored:
```
int | str == str | int

```

  * It is compatible with [`typing.Union`](https://docs.python.org/3/library/typing.html#typing.Union "typing.Union"):
```
int | str == typing.Union[int, str]

```

  * Optional types can be spelled as a union with `None`:
```
str | None == typing.Optional[str]

```




isinstance(obj, union_object)


issubclass(obj, union_object)
    
Calls to [`isinstance()`](https://docs.python.org/3/library/functions.html#isinstance "isinstance") and [`issubclass()`](https://docs.python.org/3/library/functions.html#issubclass "issubclass") are also supported with a union object:
>>>```
>>> isinstance("", int | str)
True

```

However, [parameterized generics](https://docs.python.org/3/library/stdtypes.html#types-genericalias) in union objects cannot be checked:
>>>```
>>> isinstance(1, int | list[int]) # short-circuit evaluation
True
>>> isinstance([1], int | list[int])
Traceback (most recent call last):
...
TypeError: isinstance() argument 2 cannot be a parameterized generic

```

The user-exposed type for the union object can be accessed from [`types.UnionType`](https://docs.python.org/3/library/types.html#types.UnionType "types.UnionType") and used for [`isinstance()`](https://docs.python.org/3/library/functions.html#isinstance "isinstance") checks. An object cannot be instantiated from the type:
>>>```
>>> importtypes
>>> isinstance(int | str, types.UnionType)
True
>>> types.UnionType()
Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
TypeError: cannot create 'types.UnionType' instances

```

Note
The `__or__()` method for type objects was added to support the syntax `X | Y`. If a metaclass implements `__or__()`, the Union may override it:
>>>