Title: ParamSpec.has_default Method
URL: https://docs.python.org/3/library/typing.html
Summary: The `has_default()` method determines if a parameter specification has a default value, mirroring the check against `__default__` without evaluating any lazily computed defaults. Introduced in version 3.13, it is part of defining covariant or contravariant generic types using `ParamSpec`.
---

has_default()[¶](https://docs.python.org/3/library/typing.html#typing.ParamSpec.has_default "Link to this definition")
    
Return whether or not the parameter specification has a default value. This is equivalent to checking whether [`__default__`](https://docs.python.org/3/library/typing.html#typing.ParamSpec.__default__ "typing.ParamSpec.__default__") is not the [`typing.NoDefault`](https://docs.python.org/3/library/typing.html#typing.NoDefault "typing.NoDefault") singleton, except that it does not force evaluation of the [lazily evaluated](https://docs.python.org/3/reference/executionmodel.html#lazy-evaluation) default value.
Added in version 3.13.
Parameter specification variables created with `covariant=True` or `contravariant=True` can be used to declare covariant or contravariant generic types. The `bound` argument is also accepted, similar to [`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "typing.TypeVar"). However the actual semantics of these keywords are yet to be decided.
Added in version 3.10.
Changed in version 3.12: Parameter specifications can now be declared using the [type parameter](https://docs.python.org/3/reference/compound_stmts.html#type-params) syntax introduced by [**PEP 695**](https://peps.python.org/pep-0695/).
Changed in version 3.13: Support for default values was added.
Note
Only parameter specification variables defined in global scope can be pickled.
See also
  * [**PEP 612**](https://peps.python.org/pep-0612/) – Parameter Specification Variables (the PEP which introduced `ParamSpec` and `Concatenate`)
  * [`Concatenate`](https://docs.python.org/3/library/typing.html#typing.Concatenate "typing.Concatenate")
  * [Annotating callable objects](https://docs.python.org/3/library/typing.html#annotating-callables)



typing.ParamSpecArgs[¶](https://docs.python.org/3/library/typing.html#typing.ParamSpecArgs "Link to this definition")


typing.ParamSpecKwargs[¶](https://docs.python.org/3/library/typing.html#typing.ParamSpecKwargs "Link to this definition")
    
Arguments and keyword arguments attributes of a [`ParamSpec`](https://docs.python.org/3/library/typing.html#typing.ParamSpec "typing.ParamSpec"). The `P.args` attribute of a `ParamSpec` is an instance of `ParamSpecArgs`, and `P.kwargs` is an instance of `ParamSpecKwargs`. They are intended for runtime introspection and have no special meaning to static type checkers.
Calling [`get_origin()`](https://docs.python.org/3/library/typing.html#typing.get_origin "typing.get_origin") on either of these objects will return the original `ParamSpec`:
>>>```
>>> fromtypingimport ParamSpec, get_origin
>>> P = ParamSpec("P")
>>> get_origin(P.args) is P
True
>>> get_origin(P.kwargs) is P
True

```

Added in version 3.10. 

_class_ typing.TypeAliasType(_name_ , _value_ , _*_ , _type_params =()_)[¶](https://docs.python.org/3/library/typing.html#typing.TypeAliasType "Link to this definition")
    
The type of type aliases created through the [`type`](https://docs.python.org/3/reference/simple_stmts.html#type) statement.
Example:
>>>```
>>> type Alias = int
>>> type(Alias)
<class 'typing.TypeAliasType'>

```

Added in version 3.12. 

__name__[¶](https://docs.python.org/3/library/typing.html#typing.TypeAliasType.__name__ "Link to this definition")
    
The name of the type alias:
>>>```
>>> type Alias = int
>>> Alias.__name__
'Alias'

```


__module__[¶](https://docs.python.org/3/library/typing.html#typing.TypeAliasType.__module__ "Link to this definition")
    
The module in which the type alias was defined:
>>>```
>>> type Alias = int
>>> Alias.__module__
'__main__'

```


__type_params__[¶](https://docs.python.org/3/library/typing.html#typing.TypeAliasType.__type_params__ "Link to this definition")
    
The type parameters of the type alias, or an empty tuple if the alias is not generic:
>>>```
>>> type ListOrSet[T] = list[T] | set[T]
>>> ListOrSet.__type_params__
(T,)
>>> type NotGeneric = int
>>> NotGeneric.__type_params__
()

```


__value__[¶](https://docs.python.org/3/library/typing.html#typing.TypeAliasType.__value__ "Link to this definition")
    
The type alias’s value. This is [lazily evaluated](https://docs.python.org/3/reference/executionmodel.html#lazy-evaluation), so names used in the definition of the alias are not resolved until the `__value__` attribute is accessed:
>>>```
>>> type Mutually = Recursive
>>> type Recursive = Mutually
>>> Mutually
Mutually
>>> Recursive
Recursive
>>> Mutually.__value__
Recursive
>>> Recursive.__value__
Mutually