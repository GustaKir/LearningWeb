Title: BaseProtocol.resume_writing Method
URL: https://docs.python.org/3/library/asyncio-protocol.html
Summary: The `resume_writing()` method in the BaseProtocol is called when the transport's buffer size falls at or below the low watermark. This ensures that writing can resume only after the buffer is sufficiently drained, avoiding premature writing when the buffer is still full.
---

BaseProtocol.resume_writing()[¶](https://docs.python.org/3/library/asyncio-protocol.html#asyncio.BaseProtocol.resume_writing "Link to this definition")
    
Called when the transport’s buffer drains below the low watermark.
If the buffer size equals the high watermark, [`pause_writing()`](https://docs.python.org/3/library/asyncio-protocol.html#asyncio.BaseProtocol.pause_writing "asyncio.BaseProtocol.pause_writing") is not called: the buffer size must go strictly over.
Conversely, [`resume_writing()`](https://docs.python.org/3/library/asyncio-protocol.html#asyncio.BaseProtocol.resume_writing "asyncio.BaseProtocol.resume_writing") is called when the buffer size is equal or lower than the low watermark. These end conditions are important to ensure that things go as expected when either mark is zero.
### Streaming Protocols[¶](https://docs.python.org/3/library/asyncio-protocol.html#streaming-protocols "Link to this heading")
Event methods, such as [`loop.create_server()`](https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.create_server "asyncio.loop.create_server"), [`loop.create_unix_server()`](https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.create_unix_server "asyncio.loop.create_unix_server"), [`loop.create_connection()`](https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.create_connection "asyncio.loop.create_connection"), [`loop.create_unix_connection()`](https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.create_unix_connection "asyncio.loop.create_unix_connection"), [`loop.connect_accepted_socket()`](https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.connect_accepted_socket "asyncio.loop.connect_accepted_socket"), [`loop.connect_read_pipe()`](https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.connect_read_pipe "asyncio.loop.connect_read_pipe"), and [`loop.connect_write_pipe()`](https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.connect_write_pipe "asyncio.loop.connect_write_pipe") accept factories that return streaming protocols. 

Protocol.data_received(_data_)[¶](https://docs.python.org/3/library/asyncio-protocol.html#asyncio.Protocol.data_received "Link to this definition")
    
Called when some data is received. _data_ is a non-empty bytes object containing the incoming data.
Whether the data is buffered, chunked or reassembled depends on the transport. In general, you shouldn’t rely on specific semantics and instead make your parsing generic and flexible. However, data is always received in the correct order.
The method can be called an arbitrary number of times while a connection is open.
However, [`protocol.eof_received()`](https://docs.python.org/3/library/asyncio-protocol.html#asyncio.Protocol.eof_received "asyncio.Protocol.eof_received") is called at most once. Once `eof_received()` is called, `data_received()` is not called anymore. 

Protocol.eof_received()[¶](https://docs.python.org/3/library/asyncio-protocol.html#asyncio.Protocol.eof_received "Link to this definition")
    
Called when the other end signals it won’t send any more data (for example by calling [`transport.write_eof()`](https://docs.python.org/3/library/asyncio-protocol.html#asyncio.WriteTransport.write_eof "asyncio.WriteTransport.write_eof"), if the other end also uses asyncio).
This method may return a false value (including `None`), in which case the transport will close itself. Conversely, if this method returns a true value, the protocol used determines whether to close the transport. Since the default implementation returns `None`, it implicitly closes the connection.
Some transports, including SSL, don’t support half-closed connections, in which case returning true from this method will result in the connection being closed.
State machine:
```
start -> connection_made
  [-> data_received]*
  [-> eof_received]?
-> connection_lost -> end