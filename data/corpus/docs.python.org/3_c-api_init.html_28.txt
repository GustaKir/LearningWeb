Title: Py_EndInterpreter Function
URL: https://docs.python.org/3/c-api/init.html
Summary: The `Py_EndInterpreter` function destroys a sub-interpreter associated with the given thread state, which must be the current state. It ensures that the global interpreter lock is held before invocation, and once executed, the current thread state becomes NULL, alongside all associated thread states being destroyed. The function is part of the Stable ABI, and `Py_FinalizeEx()` will handle any remaining sub-interpreters.
---

voidPy_EndInterpreter([PyThreadState](https://docs.python.org/3/c-api/init.html#c.PyThreadState "PyThreadState")*tstate)[¶](https://docs.python.org/3/c-api/init.html#c.Py_EndInterpreter "Link to this definition")
    _Part of the[ Stable ABI](https://docs.python.org/3/c-api/stable.html#stable)._
Destroy the (sub-)interpreter represented by the given thread state. The given thread state must be the current thread state. See the discussion of thread states below. When the call returns, the current thread state is `NULL`. All thread states associated with this interpreter are destroyed. The global interpreter lock used by the target interpreter must be held before calling this function. No GIL is held when it returns.
[`Py_FinalizeEx()`](https://docs.python.org/3/c-api/init.html#c.Py_FinalizeEx "Py_FinalizeEx") will destroy all sub-interpreters that haven’t been explicitly destroyed at that point.
### A Per-Interpreter GIL[¶](https://docs.python.org/3/c-api/init.html#a-per-interpreter-gil "Link to this heading")
Using [`Py_NewInterpreterFromConfig()`](https://docs.python.org/3/c-api/init.html#c.Py_NewInterpreterFromConfig "Py_NewInterpreterFromConfig") you can create a sub-interpreter that is completely isolated from other interpreters, including having its own GIL. The most important benefit of this isolation is that such an interpreter can execute Python code without being blocked by other interpreters or blocking any others. Thus a single Python process can truly take advantage of multiple CPU cores when running Python code. The isolation also encourages a different approach to concurrency than that of just using threads. (See [**PEP 554**](https://peps.python.org/pep-0554/).)
Using an isolated interpreter requires vigilance in preserving that isolation. That especially means not sharing any objects or mutable state without guarantees about thread-safety. Even objects that are otherwise immutable (e.g. `None`, `(1, 5)`) can’t normally be shared because of the refcount. One simple but less-efficient approach around this is to use a global lock around all use of some state (or object). Alternately, effectively immutable objects (like integers or strings) can be made safe in spite of their refcounts by making them [immortal](https://docs.python.org/3/glossary.html#term-immortal). In fact, this has been done for the builtin singletons, small integers, and a number of other builtin objects.
If you preserve isolation then you will have access to proper multi-core computing without the complications that come with free-threading. Failure to preserve isolation will expose you to the full consequences of free-threading, including races and hard-to-debug crashes.
Aside from that, one of the main challenges of using multiple isolated interpreters is how to communicate between them safely (not break isolation) and efficiently. The runtime and stdlib do not provide any standard approach to this yet. A future stdlib module would help mitigate the effort of preserving isolation and expose effective tools for communicating (and sharing) data between interpreters.
Added in version 3.12.
### Bugs and caveats[¶](https://docs.python.org/3/c-api/init.html#bugs-and-caveats "Link to this heading")
Because sub-interpreters (and the main interpreter) are part of the same process, the insulation between them isn’t perfect — for example, using low-level file operations like [`os.close()`](https://docs.python.org/3/library/os.html#os.close "os.close") they can (accidentally or maliciously) affect each other’s open files. Because of the way extensions are shared between (sub-)interpreters, some extensions may not work properly; this is especially likely when using single-phase initialization or (static) global variables. It is possible to insert objects created in one sub-interpreter into a namespace of another (sub-)interpreter; this should be avoided if possible.
Special care should be taken to avoid sharing user-defined functions, methods, instances or classes between sub-interpreters, since import operations executed by such objects may affect the wrong (sub-)interpreter’s dictionary of loaded modules. It is equally important to avoid sharing objects from which the above are reachable.
Also note that combining this functionality with `PyGILState_*` APIs is delicate, because these APIs assume a bijection between Python thread states and OS-level threads, an assumption broken by the presence of sub-interpreters. It is highly recommended that you don’t switch sub-interpreters between a pair of matching [`PyGILState_Ensure()`](https://docs.python.org/3/c-api/init.html#c.PyGILState_Ensure "PyGILState_Ensure") and [`PyGILState_Release()`](https://docs.python.org/3/c-api/init.html#c.PyGILState_Release "PyGILState_Release") calls. Furthermore, extensions (such as [`ctypes`](https://docs.python.org/3/library/ctypes.html#module-ctypes "ctypes: A foreign function library for Python.")) using these APIs to allow calling of Python code from n