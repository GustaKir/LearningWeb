Title: Boolean Type and Real Numbers in Python
URL: https://docs.python.org/3/reference/datamodel.html
Summary: This section describes the Boolean type in Python, which has two values: `False` and `True`. It notes that Booleans are a subtype of integers and behave like 0 and 1 in most contexts, except when converted to strings. Additionally, it introduces the `numbers.Real` type, representing machine-level double precision floating-point numbers, with handling dependent on the underlying machine architecture.
---

Booleans ([`bool`](https://docs.python.org/3/library/functions.html#bool "bool"))
    
These represent the truth values False and True. The two objects representing the values `False` and `True` are the only Boolean objects. The Boolean type is a subtype of the integer type, and Boolean values behave like the values 0 and 1, respectively, in almost all contexts, the exception being that when converted to a string, the strings `"False"` or `"True"` are returned, respectively.
#### 3.2.4.2. [`numbers.Real`](https://docs.python.org/3/library/numbers.html#numbers.Real "numbers.Real") ([`float`](https://docs.python.org/3/library/functions.html#float "float"))[¶](https://docs.python.org/3/reference/datamodel.html#numbers-real-float "Link to this heading")
These represent machine-level double precision floating-point numbers. You are at the mercy of the underlying machine architecture (and C or Java implementation) for the accepted range and handling of overflow. Python does not support single-precision floating-point numbers; the savings in processor and memory usage that are usually the reason for using these are dwarfed by the overhead of using objects in Python, so there is no reason to complicate the language with two kinds of floating-point numbers.
#### 3.2.4.3. [`numbers.Complex`](https://docs.python.org/3/library/numbers.html#numbers.Complex "numbers.Complex") ([`complex`](https://docs.python.org/3/library/functions.html#complex "complex"))[¶](https://docs.python.org/3/reference/datamodel.html#numbers-complex-complex "Link to this heading")
These represent complex numbers as a pair of machine-level double precision floating-point numbers. The same caveats apply as for floating-point numbers. The real and imaginary parts of a complex number `z` can be retrieved through the read-only attributes `z.real` and `z.imag`.
### 3.2.5. Sequences[¶](https://docs.python.org/3/reference/datamodel.html#sequences "Link to this heading")
These represent finite ordered sets indexed by non-negative numbers. The built-in function [`len()`](https://docs.python.org/3/library/functions.html#len "len") returns the number of items of a sequence. When the length of a sequence is _n_ , the index set contains the numbers 0, 1, …, _n_ -1. Item _i_ of sequence _a_ is selected by `a[i]`. Some sequences, including built-in sequences, interpret negative subscripts by adding the sequence length. For example, `a[-2]` equals `a[n-2]`, the second to last item of sequence a with length `n`.
Sequences also support slicing: `a[i:j]` selects all items with index _k_ such that _i_ `<=` _k_ `<` _j_. When used as an expression, a slice is a sequence of the same type. The comment above about negative indexes also applies to negative slice positions.
Some sequences also support “extended slicing” with a third “step” parameter: `a[i:j:k]` selects all items of _a_ with index _x_ where `x = i + n*k`, _n_ `>=` `0` and _i_ `<=` _x_ `<` _j_.
Sequences are distinguished according to their mutability:
#### 3.2.5.1. Immutable sequences[¶](https://docs.python.org/3/reference/datamodel.html#immutable-sequences "Link to this heading")
An object of an immutable sequence type cannot change once it is created. (If the object contains references to other objects, these other objects may be mutable and may be changed; however, the collection of objects directly referenced by an immutable object cannot change.)
The following types are immutable sequences: 

Strings
    
A string is a sequence of values that represent Unicode code points. All the code points in the range `U+0000 - U+10FFFF` can be represented in a string. Python doesn’t have a char type; instead, every code point in the string is represented as a string object with length `1`. The built-in function [`ord()`](https://docs.python.org/3/library/functions.html#ord "ord") converts a code point from its string form to an integer in the range `0 - 10FFFF`; [`chr()`](https://docs.python.org/3/library/functions.html#chr "chr") converts an integer in the range `0 - 10FFFF` to the corresponding length `1` string object. [`str.encode()`](https://docs.python.org/3/library/stdtypes.html#str.encode "str.encode") can be used to convert a [`str`](https://docs.python.org/3/library/stdtypes.html#str "str") to [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "bytes") using the given text encoding, and [`bytes.decode()`](https://docs.python.org/3/library/stdtypes.html#bytes.decode "bytes.decode") can be used to achieve the opposite. 

Tuples
    
The items of a tuple are arbitrary Python objects. Tuples of two or more items are formed by comma-separated lists of expressions. A tuple of one item (a ‘singleton’) can be formed by affixing a comma to an expression (an expression by itself does not create a tuple, since parentheses must be usable for grouping of expressions). An empty tuple can be formed by an empty pair of parentheses.