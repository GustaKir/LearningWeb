Title: Decimal Module - Fixed-Point and Floating-Point Arithmetic
URL: https://docs.python.org/3/library/decimal.html
Summary: The `decimal` module in Python supports fast, correctly rounded decimal arithmetic, offering advantages over the float datatype, including precise representation of decimal numbers and adherence to human-centric arithmetic principles.
---

# `decimal` — Decimal fixed-point and floating-point arithmetic[¶](https://docs.python.org/3/library/decimal.html#module-decimal "Link to this heading")
**Source code:** [Lib/decimal.py](https://github.com/python/cpython/tree/3.13/Lib/decimal.py)
The [`decimal`](https://docs.python.org/3/library/decimal.html#module-decimal "decimal: Implementation of the General Decimal Arithmetic Specification.") module provides support for fast correctly rounded decimal floating-point arithmetic. It offers several advantages over the [`float`](https://docs.python.org/3/library/functions.html#float "float") datatype:
  * Decimal “is based on a floating-point model which was designed with people in mind, and necessarily has a paramount guiding principle – computers must provide an arithmetic that works in the same way as the arithmetic that people learn at school.” – excerpt from the decimal arithmetic specification.
  * Decimal numbers can be represented exactly. In contrast, numbers like `1.1` and `2.2` do not have exact representations in binary floating point. End users typically would not expect `1.1 + 2.2` to display as `3.3000000000000003` as it does with binary floating point.
  * The exactness carries over into arithmetic. In decimal floating point, `0.1 + 0.1 + 0.1 - 0.3` is exactly equal to zero. In binary floating point, the result is `5.5511151231257827e-017`. While near to zero, the differences prevent reliable equality testing and differences can accumulate. For this reason, decimal is preferred in accounting applications which have strict equality invariants.
  * The decimal module incorporates a notion of significant places so that `1.30 + 1.20` is `2.50`. The trailing zero is kept to indicate significance. This is the customary presentation for monetary applications. For multiplication, the “schoolbook” approach uses all the figures in the multiplicands. For instance, `1.3 * 1.2` gives `1.56` while `1.30 * 1.20` gives `1.5600`.
  * Unlike hardware based binary floating point, the decimal module has a user alterable precision (defaulting to 28 places) which can be as large as needed for a given problem:
>>>```
>>> fromdecimalimport *
>>> getcontext().prec = 6
>>> Decimal(1) / Decimal(7)
Decimal('0.142857')
>>> getcontext().prec = 28
>>> Decimal(1) / Decimal(7)
Decimal('0.1428571428571428571428571429')