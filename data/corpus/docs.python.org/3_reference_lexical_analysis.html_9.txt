Title: Changes in f-strings and Expression Evaluation in Python
URL: https://docs.python.org/3/reference/lexical_analysis.html
Summary: This document section outlines changes in Python related to formatted string literals, specifically noting changes in versions 3.7 and 3.12. It explains that in Python 3.7, certain expressions became legal in f-strings, while 3.12 introduced the allowance of comments inside f-string replacement fields. Additionally, it describes how the equal sign '=' can be used to output the expression text along with its evaluated value, preserving spaces in the output.
---

```

Changed in version 3.7: Prior to Python 3.7, an [`await`](https://docs.python.org/3/reference/expressions.html#await) expression and comprehensions containing an [`async for`](https://docs.python.org/3/reference/compound_stmts.html#async-for) clause were illegal in the expressions in formatted string literals due to a problem with the implementation.
Changed in version 3.12: Prior to Python 3.12, comments were not allowed inside f-string replacement fields.
When the equal sign `'='` is provided, the output will have the expression text, the `'='` and the evaluated value. Spaces after the opening brace `'{'`, within the expression and after the `'='` are all retained in the output. By default, the `'='` causes the [`repr()`](https://docs.python.org/3/library/functions.html#repr "repr") of the expression to be provided, unless there is a format specified. When a format is specified it defaults to the [`str()`](https://docs.python.org/3/library/stdtypes.html#str "str") of the expression unless a conversion `'!r'` is declared.
Added in version 3.8: The equal sign `'='`.
If a conversion is specified, the result of evaluating the expression is converted before formatting. Conversion `'!s'` calls [`str()`](https://docs.python.org/3/library/stdtypes.html#str "str") on the result, `'!r'` calls [`repr()`](https://docs.python.org/3/library/functions.html#repr "repr"), and `'!a'` calls [`ascii()`](https://docs.python.org/3/library/functions.html#ascii "ascii").
The result is then formatted using the [`format()`](https://docs.python.org/3/library/functions.html#format "format") protocol. The format specifier is passed to the [`__format__()`](https://docs.python.org/3/reference/datamodel.html#object.__format__ "object.__format__") method of the expression or conversion result. An empty string is passed when the format specifier is omitted. The formatted result is then included in the final value of the whole string.
Top-level format specifiers may include nested replacement fields. These nested fields may include their own conversion fields and [format specifiers](https://docs.python.org/3/library/string.html#formatspec), but may not include more deeply nested replacement fields. The [format specifier mini-language](https://docs.python.org/3/library/string.html#formatspec) is the same as that used by the [`str.format()`](https://docs.python.org/3/library/stdtypes.html#str.format "str.format") method.
Formatted string literals may be concatenated, but replacement fields cannot be split across literals.
Some examples of formatted string literals:
>>>```
>>> name = "Fred"
>>> f"He said his name is {name!r}."
"He said his name is 'Fred'."
>>> f"He said his name is {repr(name)}." # repr() is equivalent to !r
"He said his name is 'Fred'."
>>> width = 10
>>> precision = 4
>>> value = decimal.Decimal("12.34567")
>>> f"result: {value:{width}.{precision}}" # nested fields
'result:   12.35'
>>> today = datetime(year=2017, month=1, day=27)
>>> f"{today:%B %d, %Y}" # using date format specifier
'January 27, 2017'
>>> f"{today=:%B %d, %Y}" # using date format specifier and debugging
'today=January 27, 2017'
>>> number = 1024
>>> f"{number:#0x}" # using integer format specifier
'0x400'
>>> foo = "bar"
>>> f"{foo= }" # preserves whitespace
" foo = 'bar'"
>>> line = "The mill's closed"
>>> f"{line= }"
'line = "The mill\'s closed"'
>>> f"{line= :20}"
"line = The mill's closed  "
>>> f"{line= !r:20}"
'line = "The mill\'s closed" '

```

Reusing the outer f-string quoting type inside a replacement field is permitted:
>>>```
>>> a = dict(x=2)
>>> f"abc {a["x"]} def"
'abc 2 def'

```

Changed in version 3.12: Prior to Python 3.12, reuse of the same quoting type of the outer f-string inside a replacement field was not possible.
Backslashes are also allowed in replacement fields and are evaluated the same way as in any other context:
>>>```
>>> a = ["a", "b", "c"]
>>> print(f"List a contains:\n{"\n".join(a)}")
List a contains:
a
b
c

```

Changed in version 3.12: Prior to Python 3.12, backslashes were not permitted inside an f-string replacement field.
Formatted string literals cannot be used as docstrings, even if they do not include expressions.
>>>```
>>> deffoo():
...   f"Not a docstring"
...
>>> foo.__doc__ is None
True