Title: Custom Class Operators and Other Built-in Types
URL: https://docs.python.org/3/library/stdtypes.html
Summary: This section demonstrates the use of custom classes with operator overloading in Python, showcasing how the `|` operator can be defined for a class using a metaclass. It also references PEP 604, which introduces the `X | Y` syntax for unions. Additionally, it touches upon the basic operations supported by other built-in types, particularly modules, which primarily support attribute access.
---

```
>>> classM(type):
...   def__or__(self, other):
...     return "Hello"
...
>>> classC(metaclass=M):
...   pass
...
>>> C | int
'Hello'
>>> int | C
int | C

```

See also
[**PEP 604**](https://peps.python.org/pep-0604/) – PEP proposing the `X | Y` syntax and the Union type.
Added in version 3.10.
## Other Built-in Types[¶](https://docs.python.org/3/library/stdtypes.html#other-built-in-types "Link to this heading")
The interpreter supports several other kinds of objects. Most of these support only one or two operations.
### Modules[¶](https://docs.python.org/3/library/stdtypes.html#modules "Link to this heading")
The only special operation on a module is attribute access: `m.name`, where _m_ is a module and _name_ accesses a name defined in _m_ ’s symbol table. Module attributes can be assigned to. (Note that the [`import`](https://docs.python.org/3/reference/simple_stmts.html#import) statement is not, strictly speaking, an operation on a module object; `import foo` does not require a module object named _foo_ to exist, rather it requires an (external) _definition_ for a module named _foo_ somewhere.)
A special attribute of every module is [`__dict__`](https://docs.python.org/3/reference/datamodel.html#object.__dict__ "object.__dict__"). This is the dictionary containing the module’s symbol table. Modifying this dictionary will actually change the module’s symbol table, but direct assignment to the [`__dict__`](https://docs.python.org/3/reference/datamodel.html#object.__dict__ "object.__dict__") attribute is not possible (you can write `m.__dict__['a'] = 1`, which defines `m.a` to be `1`, but you can’t write `m.__dict__ = {}`). Modifying [`__dict__`](https://docs.python.org/3/reference/datamodel.html#object.__dict__ "object.__dict__") directly is not recommended.
Modules built into the interpreter are written like this: `<module 'sys' (built-in)>`. If loaded from a file, they are written as `<module 'os' from '/usr/local/lib/pythonX.Y/os.pyc'>`.
### Classes and Class Instances[¶](https://docs.python.org/3/library/stdtypes.html#classes-and-class-instances "Link to this heading")
See [Objects, values and types](https://docs.python.org/3/reference/datamodel.html#objects) and [Class definitions](https://docs.python.org/3/reference/compound_stmts.html#class) for these.
### Functions[¶](https://docs.python.org/3/library/stdtypes.html#functions "Link to this heading")
Function objects are created by function definitions. The only operation on a function object is to call it: `func(argument-list)`.
There are really two flavors of function objects: built-in functions and user-defined functions. Both support the same operation (to call the function), but the implementation is different, hence the different object types.
See [Function definitions](https://docs.python.org/3/reference/compound_stmts.html#function) for more information.
### Methods[¶](https://docs.python.org/3/library/stdtypes.html#methods "Link to this heading")
Methods are functions that are called using the attribute notation. There are two flavors: [built-in methods](https://docs.python.org/3/reference/datamodel.html#builtin-methods) (such as `append()` on lists) and [class instance method](https://docs.python.org/3/reference/datamodel.html#instance-methods). Built-in methods are described with the types that support them.
If you access a method (a function defined in a class namespace) through an instance, you get a special object: a _bound method_ (also called [instance method](https://docs.python.org/3/reference/datamodel.html#instance-methods)) object. When called, it will add the `self` argument to the argument list. Bound methods have two special read-only attributes: [`m.__self__`](https://docs.python.org/3/reference/datamodel.html#method.__self__ "method.__self__") is the object on which the method operates, and [`m.__func__`](https://docs.python.org/3/reference/datamodel.html#method.__func__ "method.__func__") is the function implementing the method. Calling `m(arg-1, arg-2, ..., arg-n)` is completely equivalent to calling `m.__func__(m.__self__, arg-1, arg-2, ..., arg-n)`.
Like [function objects](https://docs.python.org/3/reference/datamodel.html#user-defined-funcs), bound method objects support getting arbitrary attributes. However, since method attributes are actually stored on the underlying function object ([`method.__func__`](https://docs.python.org/3/reference/datamodel.html#method.__func__ "method.__func__")), setting method attributes on bound methods is disallowed. Attempting to set an attribute on a method results in an [`AttributeError`](https://docs.python.org/3/library/exceptions.html#AttributeError "AttributeError") being raised. In order to set a method attribute, you need to explicitly set it on the underlying function object:
>>>