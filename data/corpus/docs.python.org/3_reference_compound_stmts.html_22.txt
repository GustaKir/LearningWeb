Title: Annotation Scopes in Python Functions
URL: https://docs.python.org/3/reference/compound_stmts.html
Summary: This section discusses the concept of annotation scopes in Python, explaining how annotations for generic functions are evaluated, along with scoping rules for defaults and decorators. It highlights the exception of using `typing.TypeVar` directly and provides an illustrative example of these rules.
---

```

Here `annotation-def` indicates an [annotation scope](https://docs.python.org/3/reference/executionmodel.html#annotation-scopes), which is not actually bound to any name at runtime. (One other liberty is taken in the translation: the syntax does not go through attribute access on the [`typing`](https://docs.python.org/3/library/typing.html#module-typing "typing: Support for type hints \(see :pep:`484`\).") module, but creates an instance of [`typing.TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "typing.TypeVar") directly.)
The annotations of generic functions are evaluated within the annotation scope used for declaring the type parameters, but the function’s defaults and decorators are not.
The following example illustrates the scoping rules for these cases, as well as for additional flavors of type parameters:
```
@decorator
deffunc[T: int, *Ts, **P](*args: *Ts, arg: Callable[P, T] = some_default):
  ...

```

Except for the [lazy evaluation](https://docs.python.org/3/reference/executionmodel.html#lazy-evaluation) of the [`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar "typing.TypeVar") bound, this is equivalent to:
```
DEFAULT_OF_arg = some_default
annotation-defTYPE_PARAMS_OF_func():
  annotation-defBOUND_OF_T():
    return int
  # In reality, BOUND_OF_T() is evaluated only on demand.
  T = typing.TypeVar("T", bound=BOUND_OF_T())
  Ts = typing.TypeVarTuple("Ts")
  P = typing.ParamSpec("P")
  deffunc(*args: *Ts, arg: Callable[P, T] = DEFAULT_OF_arg):
    ...
  func.__type_params__ = (T, Ts, P)
  return func
func = decorator(TYPE_PARAMS_OF_func())

```

The capitalized names like `DEFAULT_OF_arg` are not actually bound at runtime.
### 8.10.2. Generic classes[¶](https://docs.python.org/3/reference/compound_stmts.html#generic-classes "Link to this heading")
Generic classes are declared as follows:
```
classBag[T]: ...

```

This syntax is equivalent to:
```
annotation-defTYPE_PARAMS_OF_Bag():
  T = typing.TypeVar("T")
  classBag(typing.Generic[T]):
    __type_params__ = (T,)
    ...
  return Bag
Bag = TYPE_PARAMS_OF_Bag()

```

Here again `annotation-def` (not a real keyword) indicates an [annotation scope](https://docs.python.org/3/reference/executionmodel.html#annotation-scopes), and the name `TYPE_PARAMS_OF_Bag` is not actually bound at runtime.
Generic classes implicitly inherit from [`typing.Generic`](https://docs.python.org/3/library/typing.html#typing.Generic "typing.Generic"). The base classes and keyword arguments of generic classes are evaluated within the type scope for the type parameters, and decorators are evaluated outside that scope. This is illustrated by this example:
```
@decorator
classBag(Base[T], arg=T): ...

```

This is equivalent to:
```
annotation-defTYPE_PARAMS_OF_Bag():
  T = typing.TypeVar("T")
  classBag(Base[T], typing.Generic[T], arg=T):
    __type_params__ = (T,)
    ...
  return Bag
Bag = decorator(TYPE_PARAMS_OF_Bag())

```

### 8.10.3. Generic type aliases[¶](https://docs.python.org/3/reference/compound_stmts.html#generic-type-aliases "Link to this heading")
The [`type`](https://docs.python.org/3/reference/simple_stmts.html#type) statement can also be used to create a generic type alias:
```
type ListOrSet[T] = list[T] | set[T]

```

Except for the [lazy evaluation](https://docs.python.org/3/reference/executionmodel.html#lazy-evaluation) of the value, this is equivalent to:
```
annotation-defTYPE_PARAMS_OF_ListOrSet():
  T = typing.TypeVar("T")
  annotation-defVALUE_OF_ListOrSet():
    return list[T] | set[T]
  # In reality, the value is lazily evaluated
  return typing.TypeAliasType("ListOrSet", VALUE_OF_ListOrSet(), type_params=(T,))
ListOrSet = TYPE_PARAMS_OF_ListOrSet()