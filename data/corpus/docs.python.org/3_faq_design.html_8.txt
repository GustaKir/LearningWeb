Title: Dictionary Implementation in CPython
URL: https://docs.python.org/3/faq/design.html
Summary: CPython uses resizable hash tables for dictionaries, optimizing lookup performance compared to B-trees. Each key's hash code, generated by the `hash()` function, determines its storage location in an internal array. Small variations in the key can lead to significantly different hash codes.
---

tual resize.
## [How are dictionaries implemented in CPython?](https://docs.python.org/3/faq/design.html#id21)[¶](https://docs.python.org/3/faq/design.html#how-are-dictionaries-implemented-in-cpython "Link to this heading")
CPython’s dictionaries are implemented as resizable hash tables. Compared to B-trees, this gives better performance for lookup (the most common operation by far) under most circumstances, and the implementation is simpler.
Dictionaries work by computing a hash code for each key stored in the dictionary using the [`hash()`](https://docs.python.org/3/library/functions.html#hash "hash") built-in function. The hash code varies widely depending on the key and a per-process seed; for example, `'Python'` could hash to `-539294296` while `'python'`, a string that differs by a single bit, could hash to `1142331976`. The hash code is then used to calculate a location in an internal array where the value will be stored. Assuming that you’re storing keys that all have different hash values, this means that dictionaries take constant time – _O_(1), in Big-O notation – to retrieve a key.
## [Why must dictionary keys be immutable?](https://docs.python.org/3/faq/design.html#id22)[¶](https://docs.python.org/3/faq/design.html#why-must-dictionary-keys-be-immutable "Link to this heading")
The hash table implementation of dictionaries uses a hash value calculated from the key value to find the key. If the key were a mutable object, its value could change, and thus its hash could also change. But since whoever changes the key object can’t tell that it was being used as a dictionary key, it can’t move the entry around in the dictionary. Then, when you try to look up the same object in the dictionary it won’t be found because its hash value is different. If you tried to look up the old value it wouldn’t be found either, because the value of the object found in that hash bin would be different.
If you want a dictionary indexed with a list, simply convert the list to a tuple first; the function `tuple(L)` creates a tuple with the same entries as the list `L`. Tuples are immutable and can therefore be used as dictionary keys.
Some unacceptable solutions that have been proposed:
  * Hash lists by their address (object ID). This doesn’t work because if you construct a new list with the same value it won’t be found; e.g.:
```
mydict = {[1, 2]: '12'}
print(mydict[[1, 2]])

```

would raise a [`KeyError`](https://docs.python.org/3/library/exceptions.html#KeyError "KeyError") exception because the id of the `[1, 2]` used in the second line differs from that in the first line. In other words, dictionary keys should be compared using `==`, not using [`is`](https://docs.python.org/3/reference/expressions.html#is).
  * Make a copy when using a list as a key. This doesn’t work because the list, being a mutable object, could contain a reference to itself, and then the copying code would run into an infinite loop.
  * Allow lists as keys but tell the user not to modify them. This would allow a class of hard-to-track bugs in programs when you forgot or modified a list by accident. It also invalidates an important invariant of dictionaries: every value in `d.keys()` is usable as a key of the dictionary.
  * Mark lists as read-only once they are used as a dictionary key. The problem is that it’s not just the top-level object that could change its value; you could use a tuple containing a list as a key. Entering anything as a key into a dictionary would require marking all objects reachable from there as read-only – and again, self-referential objects could cause an infinite loop.


There is a trick to get around this if you need to, but use it at your own risk: You can wrap a mutable structure inside a class instance which has both a [`__eq__()`](https://docs.python.org/3/reference/datamodel.html#object.__eq__ "object.__eq__") and a [`__hash__()`](https://docs.python.org/3/reference/datamodel.html#object.__hash__ "object.__hash__") method. You must then make sure that the hash value for all such wrapper objects that reside in a dictionary (or other hash based structure), remain fixed while the object is in the dictionary (or other structure).
```
classListWrapper:
  def__init__(self, the_list):
    self.the_list = the_list
  def__eq__(self, other):
    return self.the_list == other.the_list
  def__hash__(self):
    l = self.the_list
    result = 98767 - len(l)*555
    for i, el in enumerate(l):
      try:
        result = result + (hash(el) % 9999999) * 1001 + i
      except Exception:
        result = (result % 7777777) + i * 333
    return result