Title: Additional Responses in OpenAPI
URL: https://fastapi.tiangolo.com/advanced/additional-responses/
Summary: This section covers how to declare additional responses in FastAPI, including various status codes and media types. These responses are included in the OpenAPI schema and API documentation. It emphasizes that when implementing additional responses, one must return a `Response`, such as `JSONResponse`, with the appropriate status code and content.
---

1. [ FastAPI  ](https://fastapi.tiangolo.com/)
  2. [ Learn  ](https://fastapi.tiangolo.com/learn/)
  3. [ Advanced User Guide  ](https://fastapi.tiangolo.com/advanced/)


# Additional Responses in OpenAPI[¶](https://fastapi.tiangolo.com/advanced/additional-responses/#additional-responses-in-openapi "Permanent link")
Warning
This is a rather advanced topic.
If you are starting with **FastAPI** , you might not need this.
You can declare additional responses, with additional status codes, media types, descriptions, etc.
Those additional responses will be included in the OpenAPI schema, so they will also appear in the API docs.
But for those additional responses you have to make sure you return a `Response` like `JSONResponse` directly, with your status code and content.
## Additional Response with `model`[¶](https://fastapi.tiangolo.com/advanced/additional-responses/#additional-response-with-model "Permanent link")
You can pass to your _path operation decorators_ a parameter `responses`.
It receives a `dict`: the keys are status codes for each response (like `200`), and the values are other `dict`s with the information for each of them.
Each of those response `dict`s can have a key `model`, containing a Pydantic model, just like `response_model`.
**FastAPI** will take that model, generate its JSON Schema and include it in the correct place in OpenAPI.
For example, to declare another response with a status code `404` and a Pydantic model `Message`, you can write:
[Python 3.8+](https://fastapi.tiangolo.com/advanced/additional-responses/#__tabbed_1_1)
```
fromfastapiimport FastAPI
fromfastapi.responsesimport JSONResponse
frompydanticimport BaseModel
classItem(BaseModel):
  id: str
  value: str
classMessage(BaseModel):
  message: str
app = FastAPI()
@app.get("/items/{item_id}", response_model=Item, responses={404: {"model": Message}})
async defread_item(item_id: str):
  if item_id == "foo":
    return {"id": "foo", "value": "there goes my hero"}
  return JSONResponse(status_code=404, content={"message": "Item not found"})

```

Note
Keep in mind that you have to return the `JSONResponse` directly.
Info
The `model` key is not part of OpenAPI.
**FastAPI** will take the Pydantic model from there, generate the JSON Schema, and put it in the correct place.
The correct place is:
  * In the key `content`, that has as value another JSON object (`dict`) that contains:
    * A key with the media type, e.g. `application/json`, that contains as value another JSON object, that contains:
      * A key `schema`, that has as the value the JSON Schema from the model, here's the correct place.
        * **FastAPI** adds a reference here to the global JSON Schemas in another place in your OpenAPI instead of including it directly. This way, other applications and clients can use those JSON Schemas directly, provide better code generation tools, etc.


The generated responses in the OpenAPI for this _path operation_ will be:
```
{
"responses":{
"404":{
"description":"Additional Response",
"content":{
"application/json":{
"schema":{
"$ref":"#/components/schemas/Message"
}
}
}
},
"200":{
"description":"Successful Response",
"content":{
"application/json":{
"schema":{
"$ref":"#/components/schemas/Item"
}
}
}
},
"422":{
"description":"Validation Error",
"content":{
"application/json":{
"schema":{
"$ref":"#/components/schemas/HTTPValidationError"
}
}
}
}
}
}

```

The schemas are referenced to another place inside the OpenAPI schema:
```
{
"components":{
"schemas":{
"Message":{
"title":"Message",
"required":[
"message"
],
"type":"object",
"properties":{
"message":{
"title":"Message",
"type":"string"
}
}
},
"Item":{
"title":"Item",
"required":[
"id",
"value"
],
"type":"object",
"properties":{
"id":{
"title":"Id",
"type":"string"
},
"value":{
"title":"Value",
"type":"string"
}
}
},
"ValidationError":{
"title":"ValidationError",
"required":[
"loc",
"msg",
"type"
],
"type":"object",
"properties":{
"loc":{
"title":"Location",
"type":"array",
"items":{
"type":"string"
}
},
"msg":{
"title":"Message",
"type":"string"
},
"type":{
"title":"Error Type",
"type":"string"
}
}
},
"HTTPValidationError":{
"title":"HTTPValidationError",
"type":"object",
"properties":{
"detail":{
"title":"Detail",
"type":"array",
"items":{
"$ref":"#/components/schemas/ValidationError"
}
}
}
}
}
}
}

```

## Additional media types for the main response[¶](https://fastapi.tiangolo.com/advanced/additional-responses/#additional-media-types-for-the-main-response "Permanent link")
You can use this same `responses` parameter to add different media types for the same main response.
For example, you can add an additional media type of `image/png`, declaring that your _path operation_ can return a JSON object (with media type `application/json`) or a PNG image:
[Python 3.8+](https://fastapi.tiangolo.com/advanced/additional-responses/#__tabbed_2_1)