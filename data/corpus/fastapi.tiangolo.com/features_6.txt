Title: Features of FastAPI Based on Starlette
URL: https://fastapi.tiangolo.com/features/
Summary: FastAPI is built on Starlette and is fully compatible with it, offering enhanced features such as high performance, WebSocket support, background tasks, and comprehensive testing capabilities. It also includes support for CORS, GZip, static files, and a fully type-annotated codebase.
---

## Starlette features[¶](https://fastapi.tiangolo.com/features/#starlette-features "Permanent link")
**FastAPI** is fully compatible with (and based on) [**Starlette**](https://www.starlette.io/). So, any additional Starlette code you have, will also work.
`FastAPI` is actually a sub-class of `Starlette`. So, if you already know or use Starlette, most of the functionality will work the same way.
With **FastAPI** you get all of **Starlette** 's features (as FastAPI is just Starlette on steroids):
  * Seriously impressive performance. It is [one of the fastest Python frameworks available, on par with **NodeJS** and **Go**](https://github.com/encode/starlette#performance).
  * **WebSocket** support.
  * In-process background tasks.
  * Startup and shutdown events.
  * Test client built on HTTPX.
  * **CORS** , GZip, Static Files, Streaming responses.
  * **Session and Cookie** support.
  * 100% test coverage.
  * 100% type annotated codebase.


## Pydantic features[¶](https://fastapi.tiangolo.com/features/#pydantic-features "Permanent link")
**FastAPI** is fully compatible with (and based on) [**Pydantic**](https://docs.pydantic.dev/). So, any additional Pydantic code you have, will also work.
Including external libraries also based on Pydantic, as ORMs, ODMs for databases.
This also means that in many cases you can pass the same object you get from a request **directly to the database** , as everything is validated automatically.
The same applies the other way around, in many cases you can just pass the object you get from the database **directly to the client**.
With **FastAPI** you get all of **Pydantic** 's features (as FastAPI is based on Pydantic for all the data handling):
  * **No brainfuck** :
    * No new schema definition micro-language to learn.
    * If you know Python types you know how to use Pydantic.
  * Plays nicely with your **IDE /linter/brain**:
    * Because pydantic data structures are just instances of classes you define; auto-completion, linting, mypy and your intuition should all work properly with your validated data.
  * Validate **complex structures** :
    * Use of hierarchical Pydantic models, Python `typing`’s `List` and `Dict`, etc.
    * And validators allow complex data schemas to be clearly and easily defined, checked and documented as JSON Schema.
    * You can have deeply **nested JSON** objects and have them all validated and annotated.
  * **Extensible** :
    * Pydantic allows custom data types to be defined or you can extend validation with methods on a model decorated with the validator decorator.
  * 100% test coverage.

Was this page helpful? 
Thanks for your feedback! 
Thanks for your feedback! 
Back to top  [ Previous  FastAPI  ](https://fastapi.tiangolo.com/) [ Next  Learn  ](https://fastapi.tiangolo.com/learn/)
The FastAPI trademark is owned by [@tiangolo](https://tiangolo.com) and is registered in the US and across other regions 
Made with [ Material for MkDocs ](https://squidfunk.github.io/mkdocs-material/)
[ ](https://github.com/fastapi/fastapi "github.com") [ ](https://discord.gg/VQjSZaeJmf "discord.gg") [ ](https://twitter.com/fastapi "twitter.com") [ ](https://www.linkedin.com/in/tiangolo "www.linkedin.com") [ ](https://dev.to/tiangolo "dev.to") [ ](https://medium.com/@tiangolo "medium.com") [ ](https://tiangolo.com "tiangolo.com")
  *[path]: also known as: endpoints, routes
  *[operations]: also known as HTTP methods, as POST, GET, PUT, DELETE
  *[**Dependency Injection**]: also known as "components", "resources", "services", "providers"
  *[test coverage]: The amount of code that is automatically tested
  *[type annotated]: Python type annotations, with this your editor and external tools can give you better support
  *[ORM]: Object-Relational Mapper
  *[ODM]: Object-Document Mapper
  *[IDE]: Integrated Development Environment, similar to a code editor
  *[linter]: A program that checks for code errors