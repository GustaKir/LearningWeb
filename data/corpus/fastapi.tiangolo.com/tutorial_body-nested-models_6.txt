Title: Using Sets for Unique Tags in FastAPI Models
URL: https://fastapi.tiangolo.com/tutorial/body-nested-models/
Summary: This section demonstrates how to define a set of unique strings for tags in a FastAPI model using Python's set data type. The example includes a FastAPI app configuration and a Pydantic model that utilizes a set for the 'tags' attribute, ensuring that tags do not repeat. It also provides an endpoint to update an item with these attributes.
---

```

## Set types[Â¶](https://fastapi.tiangolo.com/tutorial/body-nested-models/#set-types "Permanent link")
But then we think about it, and realize that tags shouldn't repeat, they would probably be unique strings.
And Python has a special data type for sets of unique items, the `set`.
Then we can declare `tags` as a set of strings:
[Python 3.10+](https://fastapi.tiangolo.com/tutorial/body-nested-models/#__tabbed_7_1)
```
fromfastapiimport FastAPI
frompydanticimport BaseModel
app = FastAPI()
classItem(BaseModel):
  name: str
  description: str | None = None
  price: float
  tax: float | None = None
  tags: set[str] = set()
@app.put("/items/{item_id}")
async defupdate_item(item_id: int, item: Item):
  results = {"item_id": item_id, "item": item}
  return results

```

ðŸ¤“ Other versions and variants
[Python 3.9+](https://fastapi.tiangolo.com/tutorial/body-nested-models/#__tabbed_8_1)[Python 3.8+](https://fastapi.tiangolo.com/tutorial/body-nested-models/#__tabbed_8_2)
```
fromtypingimport Union
fromfastapiimport FastAPI
frompydanticimport BaseModel
app = FastAPI()
classItem(BaseModel):
  name: str
  description: Union[str, None] = None
  price: float
  tax: Union[float, None] = None
  tags: set[str] = set()
@app.put("/items/{item_id}")
async defupdate_item(item_id: int, item: Item):
  results = {"item_id": item_id, "item": item}
  return results

```

```
fromtypingimport Set, Union
fromfastapiimport FastAPI
frompydanticimport BaseModel
app = FastAPI()
classItem(BaseModel):
  name: str
  description: Union[str, None] = None
  price: float
  tax: Union[float, None] = None
  tags: Set[str] = set()
@app.put("/items/{item_id}")
async defupdate_item(item_id: int, item: Item):
  results = {"item_id": item_id, "item": item}
  return results

```

With this, even if you receive a request with duplicate data, it will be converted to a set of unique items.
And whenever you output that data, even if the source had duplicates, it will be output as a set of unique items.
And it will be annotated / documented accordingly too.
## Nested Models[Â¶](https://fastapi.tiangolo.com/tutorial/body-nested-models/#nested-models "Permanent link")
Each attribute of a Pydantic model has a type.
But that type can itself be another Pydantic model.
So, you can declare deeply nested JSON "objects" with specific attribute names, types and validations.
All that, arbitrarily nested.
### Define a submodel[Â¶](https://fastapi.tiangolo.com/tutorial/body-nested-models/#define-a-submodel "Permanent link")
For example, we can define an `Image` model:
[Python 3.10+](https://fastapi.tiangolo.com/tutorial/body-nested-models/#__tabbed_9_1)
```
fromfastapiimport FastAPI
frompydanticimport BaseModel
app = FastAPI()
classImage(BaseModel):
  url: str
  name: str
classItem(BaseModel):
  name: str
  description: str | None = None
  price: float
  tax: float | None = None
  tags: set[str] = set()
  image: Image | None = None
@app.put("/items/{item_id}")
async defupdate_item(item_id: int, item: Item):
  results = {"item_id": item_id, "item": item}
  return results

```

ðŸ¤“ Other versions and variants
[Python 3.9+](https://fastapi.tiangolo.com/tutorial/body-nested-models/#__tabbed_10_1)[Python 3.8+](https://fastapi.tiangolo.com/tutorial/body-nested-models/#__tabbed_10_2)
```
fromtypingimport Union
fromfastapiimport FastAPI
frompydanticimport BaseModel
app = FastAPI()
classImage(BaseModel):
  url: str
  name: str
classItem(BaseModel):
  name: str
  description: Union[str, None] = None
  price: float
  tax: Union[float, None] = None
  tags: set[str] = set()
  image: Union[Image, None] = None
@app.put("/items/{item_id}")
async defupdate_item(item_id: int, item: Item):
  results = {"item_id": item_id, "item": item}
  return results

```

```
fromtypingimport Set, Union
fromfastapiimport FastAPI
frompydanticimport BaseModel
app = FastAPI()
classImage(BaseModel):
  url: str
  name: str
classItem(BaseModel):
  name: str
  description: Union[str, None] = None
  price: float
  tax: Union[float, None] = None
  tags: Set[str] = set()
  image: Union[Image, None] = None
@app.put("/items/{item_id}")
async defupdate_item(item_id: int, item: Item):
  results = {"item_id": item_id, "item": item}
  return results

```

### Use the submodel as a type[Â¶](https://fastapi.tiangolo.com/tutorial/body-nested-models/#use-the-submodel-as-a-type "Permanent link")
And then we can use it as the type of an attribute:
[Python 3.10+](https://fastapi.tiangolo.com/tutorial/body-nested-models/#__tabbed_11_1)
```
fromfastapiimport FastAPI
frompydanticimport BaseModel
app = FastAPI()
classImage(BaseModel):
  url: str
  name: str
classItem(BaseModel):
  name: str
  description: str | None = None
  price: float
  tax: float | None = None
  tags: set[str] = set()
  image: Image | None = None
@app.put("/items/{item_id}")
async defupdate_item(item_id: int, item: Item):
  results = {"item_id": item_id, "item": item}
  return results