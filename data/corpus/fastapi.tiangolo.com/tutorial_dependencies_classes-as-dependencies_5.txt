Title: Using Classes as Dependencies in FastAPI
URL: https://fastapi.tiangolo.com/tutorial/dependencies/classes-as-dependencies/
Summary: This section discusses the limitations of using dictionaries as parameters in FastAPI path operation functions and introduces the concept of dependencies as callables. It explains that dependencies can be declared as classes, which improve editor support and allow for more structured dependency management.
---

```

But then we get a `dict` in the parameter `commons` of the _path operation function_.
And we know that editors can't provide a lot of support (like completion) for `dict`s, because they can't know their keys and value types.
We can do better...
## What makes a dependency[Â¶](https://fastapi.tiangolo.com/tutorial/dependencies/classes-as-dependencies/#what-makes-a-dependency "Permanent link")
Up to now you have seen dependencies declared as functions.
But that's not the only way to declare dependencies (although it would probably be the more common).
The key factor is that a dependency should be a "callable".
A "**callable** " in Python is anything that Python can "call" like a function.
So, if you have an object `something` (that might _not_ be a function) and you can "call" it (execute it) like:
```
something()

```

or
```
something(some_argument, some_keyword_argument="foo")

```

then it is a "callable".
## Classes as dependencies[Â¶](https://fastapi.tiangolo.com/tutorial/dependencies/classes-as-dependencies/#classes-as-dependencies_1 "Permanent link")
You might notice that to create an instance of a Python class, you use that same syntax.
For example:
```
classCat:
  def__init__(self, name: str):
    self.name = name
fluffy = Cat(name="Mr Fluffy")

```

In this case, `fluffy` is an instance of the class `Cat`.
And to create `fluffy`, you are "calling" `Cat`.
So, a Python class is also a **callable**.
Then, in **FastAPI** , you could use a Python class as a dependency.
What FastAPI actually checks is that it is a "callable" (function, class or anything else) and the parameters defined.
If you pass a "callable" as a dependency in **FastAPI** , it will analyze the parameters for that "callable", and process them in the same way as the parameters for a _path operation function_. Including sub-dependencies.
That also applies to callables with no parameters at all. The same as it would be for _path operation functions_ with no parameters.
Then, we can change the dependency "dependable" `common_parameters` from above to the class `CommonQueryParams`:
[Python 3.10+](https://fastapi.tiangolo.com/tutorial/dependencies/classes-as-dependencies/#__tabbed_3_1)
```
fromtypingimport Annotated
fromfastapiimport Depends, FastAPI
app = FastAPI()
fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]
classCommonQueryParams:
  def__init__(self, q: str | None = None, skip: int = 0, limit: int = 100):
    self.q = q
    self.skip = skip
    self.limit = limit
@app.get("/items/")
async defread_items(commons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]):
  response = {}
  if commons.q:
    response.update({"q": commons.q})
  items = fake_items_db[commons.skip : commons.skip + commons.limit]
  response.update({"items": items})
  return response

```

ðŸ¤“ Other versions and variants
[Python 3.9+](https://fastapi.tiangolo.com/tutorial/dependencies/classes-as-dependencies/#__tabbed_4_1)[Python 3.8+](https://fastapi.tiangolo.com/tutorial/dependencies/classes-as-dependencies/#__tabbed_4_2)[Python 3.10+ - non-Annotated](https://fastapi.tiangolo.com/tutorial/dependencies/classes-as-dependencies/#__tabbed_4_3)[Python 3.8+ - non-Annotated](https://fastapi.tiangolo.com/tutorial/dependencies/classes-as-dependencies/#__tabbed_4_4)
```
fromtypingimport Annotated, Union
fromfastapiimport Depends, FastAPI
app = FastAPI()
fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]
classCommonQueryParams:
  def__init__(self, q: Union[str, None] = None, skip: int = 0, limit: int = 100):
    self.q = q
    self.skip = skip
    self.limit = limit
@app.get("/items/")
async defread_items(commons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]):
  response = {}
  if commons.q:
    response.update({"q": commons.q})
  items = fake_items_db[commons.skip : commons.skip + commons.limit]
  response.update({"items": items})
  return response

```

```
fromtypingimport Union
fromfastapiimport Depends, FastAPI
fromtyping_extensionsimport Annotated
app = FastAPI()
fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]
classCommonQueryParams:
  def__init__(self, q: Union[str, None] = None, skip: int = 0, limit: int = 100):
    self.q = q
    self.skip = skip
    self.limit = limit
@app.get("/items/")
async defread_items(commons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]):
  response = {}
  if commons.q:
    response.update({"q": commons.q})
  items = fake_items_db[commons.skip : commons.skip + commons.limit]
  response.update({"items": items})
  return response

```

Tip
Prefer to use the `Annotated` version if possible.