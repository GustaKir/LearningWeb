Title: Using Asynchronous Code in FastAPI
URL: https://fastapi.tiangolo.com/async/
Summary: This section discusses when to use `async def` versus `def` in FastAPI applications, emphasizing that if no external communication is necessary, `async def` should be preferred. It notes that both `def` and `async def` can be mixed in path operation functions for optimal performance, as FastAPI manages asynchronous processes efficiently. The section introduces the concept of asynchronous code and the use of coroutines with `async` and `await` syntax.
---

```

If your application (somehow) doesn't have to communicate with anything else and wait for it to respond, use `async def`.
If you just don't know, use normal `def`.
**Note** : You can mix `def` and `async def` in your _path operation functions_ as much as you need and define each one using the best option for you. FastAPI will do the right thing with them.
Anyway, in any of the cases above, FastAPI will still work asynchronously and be extremely fast.
But by following the steps above, it will be able to do some performance optimizations.
## Technical Details[¶](https://fastapi.tiangolo.com/async/#technical-details "Permanent link")
Modern versions of Python have support for **"asynchronous code"** using something called **"coroutines"** , with **`async`and`await`** syntax.
Let's see that phrase by parts in the sections below:
  * **Asynchronous Code**
  * **`async`and`await`**
  * **Coroutines**


## Asynchronous Code[¶](https://fastapi.tiangolo.com/async/#asynchronous-code "Permanent link")
Asynchronous code just means that the language 💬 has a way to tell the computer / program 🤖 that at some point in the code, it 🤖 will have to wait for _something else_ to finish somewhere else. Let's say that _something else_ is called "slow-file" 📝.
So, during that time, the computer can go and do some other work, while "slow-file" 📝 finishes.
Then the computer / program 🤖 will come back every time it has a chance because it's waiting again, or whenever it 🤖 finished all the work it had at that point. And it 🤖 will see if any of the tasks it was waiting for have already finished, doing whatever it had to do.
Next, it 🤖 takes the first task to finish (let's say, our "slow-file" 📝) and continues whatever it had to do with it.
That "wait for something else" normally refers to I/O operations that are relatively "slow" (compared to the speed of the processor and the RAM memory), like waiting for:
  * the data from the client to be sent through the network
  * the data sent by your program to be received by the client through the network
  * the contents of a file in the disk to be read by the system and given to your program
  * the contents your program gave to the system to be written to disk
  * a remote API operation
  * a database operation to finish
  * a database query to return the results
  * etc.