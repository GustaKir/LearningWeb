Title: Generic Types with Type Parameters in Python
URL: https://fastapi.tiangolo.com/python-types/
Summary: This section discusses generic types in Python, such as `dict`, `list`, `set`, and `tuple`, which can contain values of specific internal types. It explains how to declare these types using the `typing` module, which is compatible across Python 3.6 and later versions, enhancing support for type annotations.
---

```

### Generic types with type parameters[¶](https://fastapi.tiangolo.com/python-types/#generic-types-with-type-parameters "Permanent link")
There are some data structures that can contain other values, like `dict`, `list`, `set` and `tuple`. And the internal values can have their own type too.
These types that have internal types are called "**generic** " types. And it's possible to declare them, even with their internal types.
To declare those types and the internal types, you can use the standard Python module `typing`. It exists specifically to support these type hints.
#### Newer versions of Python[¶](https://fastapi.tiangolo.com/python-types/#newer-versions-of-python "Permanent link")
The syntax using `typing` is **compatible** with all versions, from Python 3.6 to the latest ones, including Python 3.9, Python 3.10, etc.
As Python advances, **newer versions** come with improved support for these type annotations and in many cases you won't even need to import and use the `typing` module to declare the type annotations.
If you can choose a more recent version of Python for your project, you will be able to take advantage of that extra simplicity.
In all the docs there are examples compatible with each version of Python (when there's a difference).
For example "**Python 3.6+** " means it's compatible with Python 3.6 or above (including 3.7, 3.8, 3.9, 3.10, etc). And "**Python 3.9+** " means it's compatible with Python 3.9 or above (including 3.10, etc).
If you can use the **latest versions of Python** , use the examples for the latest version, those will have the **best and simplest syntax** , for example, "**Python 3.10+** ".
#### List[¶](https://fastapi.tiangolo.com/python-types/#list "Permanent link")
For example, let's define a variable to be a `list` of `str`.
[Python 3.9+](https://fastapi.tiangolo.com/python-types/#__tabbed_7_1)[Python 3.8+](https://fastapi.tiangolo.com/python-types/#__tabbed_7_2)
Declare the variable, with the same colon (`:`) syntax.
As the type, put `list`.
As the list is a type that contains some internal types, you put them in square brackets:
```
defprocess_items(items: list[str]):
  for item in items:
    print(item)

```

From `typing`, import `List` (with a capital `L`):
```
fromtypingimport List
defprocess_items(items: List[str]):
  for item in items:
    print(item)

```

Declare the variable, with the same colon (`:`) syntax.
As the type, put the `List` that you imported from `typing`.
As the list is a type that contains some internal types, you put them in square brackets:
```
fromtypingimport List
defprocess_items(items: List[str]):
  for item in items:
    print(item)

```

Info
Those internal types in the square brackets are called "type parameters".
In this case, `str` is the type parameter passed to `List` (or `list` in Python 3.9 and above).
That means: "the variable `items` is a `list`, and each of the items in this list is a `str`".
Tip
If you use Python 3.9 or above, you don't have to import `List` from `typing`, you can use the same regular `list` type instead.
By doing that, your editor can provide support even while processing items from the list:
![](https://fastapi.tiangolo.com/img/python-types/image05.png)
Without types, that's almost impossible to achieve.
Notice that the variable `item` is one of the elements in the list `items`.
And still, the editor knows it is a `str`, and provides support for that.
#### Tuple and Set[¶](https://fastapi.tiangolo.com/python-types/#tuple-and-set "Permanent link")
You would do the same to declare `tuple`s and `set`s:
[Python 3.9+](https://fastapi.tiangolo.com/python-types/#__tabbed_8_1)[Python 3.8+](https://fastapi.tiangolo.com/python-types/#__tabbed_8_2)
```
defprocess_items(items_t: tuple[int, int, str], items_s: set[bytes]):
  return items_t, items_s

```

```
fromtypingimport Set, Tuple
defprocess_items(items_t: Tuple[int, int, str], items_s: Set[bytes]):
  return items_t, items_s

```

This means:
  * The variable `items_t` is a `tuple` with 3 items, an `int`, another `int`, and a `str`.
  * The variable `items_s` is a `set`, and each of its items is of type `bytes`.


#### Dict[¶](https://fastapi.tiangolo.com/python-types/#dict "Permanent link")
To define a `dict`, you pass 2 type parameters, separated by commas.
The first type parameter is for the keys of the `dict`.
The second type parameter is for the values of the `dict`:
[Python 3.9+](https://fastapi.tiangolo.com/python-types/#__tabbed_9_1)[Python 3.8+](https://fastapi.tiangolo.com/python-types/#__tabbed_9_2)
```
defprocess_items(prices: dict[str, float]):
  for item_name, item_price in prices.items():
    print(item_name)
    print(item_price)

```

```
fromtypingimport Dict
defprocess_items(prices: Dict[str, float]):
  for item_name, item_price in prices.items():
    print(item_name)
    print(item_price)