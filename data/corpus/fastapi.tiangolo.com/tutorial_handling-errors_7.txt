Title: Handling Errors in FastAPI
URL: https://fastapi.tiangolo.com/tutorial/handling-errors/
Summary: This section discusses error handling in FastAPI, including custom exception handlers for HTTP exceptions and validation errors. It provides examples of defining handlers that return plain text responses for different error situations, such as when an HTTPException is raised or a request validation fails.
---

```
fromfastapiimport FastAPI, HTTPException
fromfastapi.exceptionsimport RequestValidationError
fromfastapi.responsesimport PlainTextResponse
fromstarlette.exceptionsimport HTTPException as StarletteHTTPException
app = FastAPI()
@app.exception_handler(StarletteHTTPException)
async defhttp_exception_handler(request, exc):
  return PlainTextResponse(str(exc.detail), status_code=exc.status_code)
@app.exception_handler(RequestValidationError)
async defvalidation_exception_handler(request, exc):
  return PlainTextResponse(str(exc), status_code=400)
@app.get("/items/{item_id}")
async defread_item(item_id: int):
  if item_id == 3:
    raise HTTPException(status_code=418, detail="Nope! I don't like 3.")
  return {"item_id": item_id}

```

Technical Details
You could also use `from starlette.responses import PlainTextResponse`.
**FastAPI** provides the same `starlette.responses` as `fastapi.responses` just as a convenience for you, the developer. But most of the available responses come directly from Starlette.
### Use the `RequestValidationError` body[¶](https://fastapi.tiangolo.com/tutorial/handling-errors/#use-the-requestvalidationerror-body "Permanent link")
The `RequestValidationError` contains the `body` it received with invalid data.
You could use it while developing your app to log the body and debug it, return it to the user, etc.
[Python 3.8+](https://fastapi.tiangolo.com/tutorial/handling-errors/#__tabbed_7_1)
```
fromfastapiimport FastAPI, Request, status
fromfastapi.encodersimport jsonable_encoder
fromfastapi.exceptionsimport RequestValidationError
fromfastapi.responsesimport JSONResponse
frompydanticimport BaseModel
app = FastAPI()
@app.exception_handler(RequestValidationError)
async defvalidation_exception_handler(request: Request, exc: RequestValidationError):
  return JSONResponse(
    status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
    content=jsonable_encoder({"detail": exc.errors(), "body": exc.body}),
  )
classItem(BaseModel):
  title: str
  size: int
@app.post("/items/")
async defcreate_item(item: Item):
  return item

```

Now try sending an invalid item like:
```
{
"title":"towel",
"size":"XL"
}

```

You will receive a response telling you that the data is invalid containing the received body:
```
{
"detail":[
{
"loc":[
"body",
"size"
],
"msg":"value is not a valid integer",
"type":"type_error.integer"
}
],
"body":{
"title":"towel",
"size":"XL"
}
}

```

#### FastAPI's `HTTPException` vs Starlette's `HTTPException`[¶](https://fastapi.tiangolo.com/tutorial/handling-errors/#fastapis-httpexception-vs-starlettes-httpexception "Permanent link")
**FastAPI** has its own `HTTPException`.
And **FastAPI** 's `HTTPException` error class inherits from Starlette's `HTTPException` error class.
The only difference is that **FastAPI** 's `HTTPException` accepts any JSON-able data for the `detail` field, while Starlette's `HTTPException` only accepts strings for it.
So, you can keep raising **FastAPI** 's `HTTPException` as normally in your code.
But when you register an exception handler, you should register it for Starlette's `HTTPException`.
This way, if any part of Starlette's internal code, or a Starlette extension or plug-in, raises a Starlette `HTTPException`, your handler will be able to catch and handle it.
In this example, to be able to have both `HTTPException`s in the same code, Starlette's exceptions is renamed to `StarletteHTTPException`:
```
fromstarlette.exceptionsimport HTTPException as StarletteHTTPException

```

### Reuse **FastAPI** 's exception handlers[¶](https://fastapi.tiangolo.com/tutorial/handling-errors/#reuse-fastapis-exception-handlers "Permanent link")
If you want to use the exception along with the same default exception handlers from **FastAPI** , you can import and reuse the default exception handlers from `fastapi.exception_handlers`:
[Python 3.8+](https://fastapi.tiangolo.com/tutorial/handling-errors/#__tabbed_8_1)
```
fromfastapiimport FastAPI, HTTPException
fromfastapi.exception_handlersimport (
  http_exception_handler,
  request_validation_exception_handler,
)
fromfastapi.exceptionsimport RequestValidationError
fromstarlette.exceptionsimport HTTPException as StarletteHTTPException
app = FastAPI()
@app.exception_handler(StarletteHTTPException)
async defcustom_http_exception_handler(request, exc):
  print(f"OMG! An HTTP error!: {repr(exc)}")
  return await http_exception_handler(request, exc)
@app.exception_handler(RequestValidationError)
async defvalidation_exception_handler(request, exc):
  print(f"OMG! The client sent invalid data!: {exc}")
  return await request_validation_exception_handler(request, exc)
@app.get("/items/{item_id}")
async defread_item(item_id: int):
  if item_id == 3:
    raise HTTPException(status_code=418, detail="Nope! I don't like 3.")
  return {"item_id": item_id}