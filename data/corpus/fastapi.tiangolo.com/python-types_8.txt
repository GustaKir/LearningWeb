Title: Generic Types in Python
URL: https://fastapi.tiangolo.com/python-types/
Summary: This section explains Generic types in Python, which are types that take parameters in square brackets, such as `list`, `tuple`, `set`, and `dict`. It also discusses the use of `Union` and `Optional` from the `typing` module. For Python 3.10 and later, it introduces the simplified syntax using the vertical bar (`|`) to declare unions of types.
---

```

And then you won't have to worry about names like `Optional` and `Union`. ðŸ˜Ž
#### Generic types[Â¶](https://fastapi.tiangolo.com/python-types/#generic-types "Permanent link")
These types that take type parameters in square brackets are called **Generic types** or **Generics** , for example:
[Python 3.10+](https://fastapi.tiangolo.com/python-types/#__tabbed_16_1)[Python 3.9+](https://fastapi.tiangolo.com/python-types/#__tabbed_16_2)[Python 3.8+](https://fastapi.tiangolo.com/python-types/#__tabbed_16_3)
You can use the same builtin types as generics (with square brackets and types inside):
  * `list`
  * `tuple`
  * `set`
  * `dict`


And the same as with Python 3.8, from the `typing` module:
  * `Union`
  * `Optional` (the same as with Python 3.8)
  * ...and others.


In Python 3.10, as an alternative to using the generics `Union` and `Optional`, you can use the vertical bar (`|`) to declare unions of types, that's a lot better and simpler.
You can use the same builtin types as generics (with square brackets and types inside):
  * `list`
  * `tuple`
  * `set`
  * `dict`


And the same as with Python 3.8, from the `typing` module:
  * `Union`
  * `Optional`
  * ...and others.


  * `List`
  * `Tuple`
  * `Set`
  * `Dict`
  * `Union`
  * `Optional`
  * ...and others.


### Classes as types[Â¶](https://fastapi.tiangolo.com/python-types/#classes-as-types "Permanent link")
You can also declare a class as the type of a variable.
Let's say you have a class `Person`, with a name:
[Python 3.8+](https://fastapi.tiangolo.com/python-types/#__tabbed_17_1)
```
classPerson:
  def__init__(self, name: str):
    self.name = name
defget_person_name(one_person: Person):
  return one_person.name

```

Then you can declare a variable to be of type `Person`:
[Python 3.8+](https://fastapi.tiangolo.com/python-types/#__tabbed_18_1)
```
classPerson:
  def__init__(self, name: str):
    self.name = name
defget_person_name(one_person: Person):
  return one_person.name

```

And then, again, you get all the editor support:
![](https://fastapi.tiangolo.com/img/python-types/image06.png)
Notice that this means "`one_person` is an **instance** of the class `Person`".
It doesn't mean "`one_person` is the **class** called `Person`".
## Pydantic models[Â¶](https://fastapi.tiangolo.com/python-types/#pydantic-models "Permanent link")
[Pydantic](https://docs.pydantic.dev/) is a Python library to perform data validation.
You declare the "shape" of the data as classes with attributes.
And each attribute has a type.
Then you create an instance of that class with some values and it will validate the values, convert them to the appropriate type (if that's the case) and give you an object with all the data.
And you get all the editor support with that resulting object.
An example from the official Pydantic docs:
[Python 3.10+](https://fastapi.tiangolo.com/python-types/#__tabbed_19_1)[Python 3.9+](https://fastapi.tiangolo.com/python-types/#__tabbed_19_2)[Python 3.8+](https://fastapi.tiangolo.com/python-types/#__tabbed_19_3)
```
fromdatetimeimport datetime
frompydanticimport BaseModel
classUser(BaseModel):
  id: int
  name: str = "John Doe"
  signup_ts: datetime | None = None
  friends: list[int] = []
external_data = {
  "id": "123",
  "signup_ts": "2017-06-01 12:22",
  "friends": [1, "2", b"3"],
}
user = User(**external_data)
print(user)
# > User id=123 name='John Doe' signup_ts=datetime.datetime(2017, 6, 1, 12, 22) friends=[1, 2, 3]
print(user.id)
# > 123

```

```
fromdatetimeimport datetime
fromtypingimport Union
frompydanticimport BaseModel
classUser(BaseModel):
  id: int
  name: str = "John Doe"
  signup_ts: Union[datetime, None] = None
  friends: list[int] = []
external_data = {
  "id": "123",
  "signup_ts": "2017-06-01 12:22",
  "friends": [1, "2", b"3"],
}
user = User(**external_data)
print(user)
# > User id=123 name='John Doe' signup_ts=datetime.datetime(2017, 6, 1, 12, 22) friends=[1, 2, 3]
print(user.id)
# > 123

```

```
fromdatetimeimport datetime
fromtypingimport List, Union
frompydanticimport BaseModel
classUser(BaseModel):
  id: int
  name: str = "John Doe"
  signup_ts: Union[datetime, None] = None
  friends: List[int] = []
external_data = {
  "id": "123",
  "signup_ts": "2017-06-01 12:22",
  "friends": [1, "2", b"3"],
}
user = User(**external_data)
print(user)
# > User id=123 name='John Doe' signup_ts=datetime.datetime(2017, 6, 1, 12, 22) friends=[1, 2, 3]
print(user.id)
# > 123