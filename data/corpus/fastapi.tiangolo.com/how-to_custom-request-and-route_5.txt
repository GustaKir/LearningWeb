Title: Custom Request and Route in FastAPI
URL: https://fastapi.tiangolo.com/how-to/custom-request-and-route/
Summary: This document demonstrates how to create a custom request handler in FastAPI that supports GZIP-compressed request bodies. It defines a `GzipRequest` class to handle GZIP decompression and a `GzipRoute` to integrate this custom request handling into FastAPI's routing system. A sample endpoint is provided to calculate the sum of a list of integers.
---

```
importgzip
fromtypingimport Callable, List
fromfastapiimport Body, FastAPI, Request, Response
fromfastapi.routingimport APIRoute
classGzipRequest(Request):
  async defbody(self) -> bytes:
    if not hasattr(self, "_body"):
      body = await super().body()
      if "gzip" in self.headers.getlist("Content-Encoding"):
        body = gzip.decompress(body)
      self._body = body
    return self._body
classGzipRoute(APIRoute):
  defget_route_handler(self) -> Callable:
    original_route_handler = super().get_route_handler()
    async defcustom_route_handler(request: Request) -> Response:
      request = GzipRequest(request.scope, request.receive)
      return await original_route_handler(request)
    return custom_route_handler
app = FastAPI()
app.router.route_class = GzipRoute
@app.post("/sum")
async defsum_numbers(numbers: List[int] = Body()):
  return {"sum": sum(numbers)}

```

Technical Details
A `Request` has a `request.scope` attribute, that's just a Python `dict` containing the metadata related to the request.
A `Request` also has a `request.receive`, that's a function to "receive" the body of the request.
The `scope` `dict` and `receive` function are both part of the ASGI specification.
And those two things, `scope` and `receive`, are what is needed to create a new `Request` instance.
To learn more about the `Request` check [Starlette's docs about Requests](https://www.starlette.io/requests/).
The only thing the function returned by `GzipRequest.get_route_handler` does differently is convert the `Request` to a `GzipRequest`.
Doing this, our `GzipRequest` will take care of decompressing the data (if necessary) before passing it to our _path operations_.
After that, all of the processing logic is the same.
But because of our changes in `GzipRequest.body`, the request body will be automatically decompressed when it is loaded by **FastAPI** when needed.
## Accessing the request body in an exception handler[¶](https://fastapi.tiangolo.com/how-to/custom-request-and-route/#accessing-the-request-body-in-an-exception-handler "Permanent link")
Tip
To solve this same problem, it's probably a lot easier to use the `body` in a custom handler for `RequestValidationError` ([Handling Errors](https://fastapi.tiangolo.com/tutorial/handling-errors/#use-the-requestvalidationerror-body)).
But this example is still valid and it shows how to interact with the internal components.
We can also use this same approach to access the request body in an exception handler.
All we need to do is handle the request inside a `try`/`except` block:
[Python 3.8+](https://fastapi.tiangolo.com/how-to/custom-request-and-route/#__tabbed_3_1)
```
fromtypingimport Callable, List
fromfastapiimport Body, FastAPI, HTTPException, Request, Response
fromfastapi.exceptionsimport RequestValidationError
fromfastapi.routingimport APIRoute
classValidationErrorLoggingRoute(APIRoute):
  defget_route_handler(self) -> Callable:
    original_route_handler = super().get_route_handler()
    async defcustom_route_handler(request: Request) -> Response:
      try:
        return await original_route_handler(request)
      except RequestValidationError as exc:
        body = await request.body()
        detail = {"errors": exc.errors(), "body": body.decode()}
        raise HTTPException(status_code=422, detail=detail)
    return custom_route_handler
app = FastAPI()
app.router.route_class = ValidationErrorLoggingRoute
@app.post("/")
async defsum_numbers(numbers: List[int] = Body()):
  return sum(numbers)

```

If an exception occurs, the`Request` instance will still be in scope, so we can read and make use of the request body when handling the error:
[Python 3.8+](https://fastapi.tiangolo.com/how-to/custom-request-and-route/#__tabbed_4_1)
```
fromtypingimport Callable, List
fromfastapiimport Body, FastAPI, HTTPException, Request, Response
fromfastapi.exceptionsimport RequestValidationError
fromfastapi.routingimport APIRoute
classValidationErrorLoggingRoute(APIRoute):
  defget_route_handler(self) -> Callable:
    original_route_handler = super().get_route_handler()
    async defcustom_route_handler(request: Request) -> Response:
      try:
        return await original_route_handler(request)
      except RequestValidationError as exc:
        body = await request.body()
        detail = {"errors": exc.errors(), "body": body.decode()}
        raise HTTPException(status_code=422, detail=detail)
    return custom_route_handler
app = FastAPI()
app.router.route_class = ValidationErrorLoggingRoute
@app.post("/")
async defsum_numbers(numbers: List[int] = Body()):
  return sum(numbers)

```

## Custom `APIRoute` class in a router[¶](https://fastapi.tiangolo.com/how-to/custom-request-and-route/#custom-apiroute-class-in-a-router "Permanent link")
You can also set the `route_class` parameter of an `APIRouter`:
[Python 3.8+](https://fastapi.tiangolo.com/how-to/custom-request-and-route/#__tabbed_5_1)