Title: Using Common Parameters with FastAPI Dependencies
URL: https://fastapi.tiangolo.com/tutorial/dependencies/
Summary: This documentation chunk illustrates how to define and use common parameters in FastAPI routes using dependency injection. It shows a common_parameters function that returns query parameters and how to apply it in multiple route handlers for '/items/' and '/users/'.
---

```
fromtypingimport Annotated, Union
fromfastapiimport Depends, FastAPI
app = FastAPI()
async defcommon_parameters(
  q: Union[str, None] = None, skip: int = 0, limit: int = 100
):
  return {"q": q, "skip": skip, "limit": limit}
CommonsDep = Annotated[dict, Depends(common_parameters)]
@app.get("/items/")
async defread_items(commons: CommonsDep):
  return commons
@app.get("/users/")
async defread_users(commons: CommonsDep):
  return commons

```

```
fromtypingimport Union
fromfastapiimport Depends, FastAPI
fromtyping_extensionsimport Annotated
app = FastAPI()
async defcommon_parameters(
  q: Union[str, None] = None, skip: int = 0, limit: int = 100
):
  return {"q": q, "skip": skip, "limit": limit}
CommonsDep = Annotated[dict, Depends(common_parameters)]
@app.get("/items/")
async defread_items(commons: CommonsDep):
  return commons
@app.get("/users/")
async defread_users(commons: CommonsDep):
  return commons

```

Tip
This is just standard Python, it's called a "type alias", it's actually not specific to **FastAPI**.
But because **FastAPI** is based on the Python standards, including `Annotated`, you can use this trick in your code. ðŸ˜Ž
The dependencies will keep working as expected, and the **best part** is that the **type information will be preserved** , which means that your editor will be able to keep providing you with **autocompletion** , **inline errors** , etc. The same for other tools like `mypy`.
This will be especially useful when you use it in a **large code base** where you use **the same dependencies** over and over again in **many _path operations_**.
## To `async` or not to `async`[Â¶](https://fastapi.tiangolo.com/tutorial/dependencies/#to-async-or-not-to-async "Permanent link")
As dependencies will also be called by **FastAPI** (the same as your _path operation functions_), the same rules apply while defining your functions.
You can use `async def` or normal `def`.
And you can declare dependencies with `async def` inside of normal `def` _path operation functions_ , or `def` dependencies inside of `async def` _path operation functions_ , etc.
It doesn't matter. **FastAPI** will know what to do.
Note
If you don't know, check the [Async: _"In a hurry?"_](https://fastapi.tiangolo.com/async/#in-a-hurry) section about `async` and `await` in the docs.
## Integrated with OpenAPI[Â¶](https://fastapi.tiangolo.com/tutorial/dependencies/#integrated-with-openapi "Permanent link")
All the request declarations, validations and requirements of your dependencies (and sub-dependencies) will be integrated in the same OpenAPI schema.
So, the interactive docs will have all the information from these dependencies too:
![](https://fastapi.tiangolo.com/img/tutorial/dependencies/image01.png)
## Simple usage[Â¶](https://fastapi.tiangolo.com/tutorial/dependencies/#simple-usage "Permanent link")
If you look at it, _path operation functions_ are declared to be used whenever a _path_ and _operation_ matches, and then **FastAPI** takes care of calling the function with the correct parameters, extracting the data from the request.
Actually, all (or most) of the web frameworks work in this same way.
You never call those functions directly. They are called by your framework (in this case, **FastAPI**).
With the Dependency Injection system, you can also tell **FastAPI** that your _path operation function_ also "depends" on something else that should be executed before your _path operation function_ , and **FastAPI** will take care of executing it and "injecting" the results.
Other common terms for this same idea of "dependency injection" are:
  * resources
  * providers
  * services
  * injectables
  * components


## **FastAPI** plug-ins[Â¶](https://fastapi.tiangolo.com/tutorial/dependencies/#fastapi-plug-ins "Permanent link")
Integrations and "plug-ins" can be built using the **Dependency Injection** system. But in fact, there is actually **no need to create "plug-ins"** , as by using dependencies it's possible to declare an infinite number of integrations and interactions that become available to your _path operation functions_.
And dependencies can be created in a very simple and intuitive way that allows you to just import the Python packages you need, and integrate them with your API functions in a couple of lines of code, _literally_.
You will see examples of this in the next chapters, about relational and NoSQL databases, security, etc.
## **FastAPI** compatibility[Â¶](https://fastapi.tiangolo.com/tutorial/dependencies/#fastapi-compatibility "Permanent link")
The simplicity of the dependency injection system makes **FastAPI** compatible with:
  * all the relational databases
  * NoSQL databases
  * external packages
  * external APIs
  * authentication and authorization systems
  * API usage monitoring systems
  * response data injection systems
  * etc.