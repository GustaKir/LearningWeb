Title: Getting the Current User in FastAPI
URL: https://fastapi.tiangolo.com/tutorial/security/get-current-user/
Summary: This section demonstrates how to retrieve the current user in a FastAPI application using OAuth2 security. It defines a User model, a token decoding function, and a route (`/users/me`) to obtain the user details from the provided token, favoring the use of `Annotated` for dependency injection.
---

```
fromtypingimport Union
fromfastapiimport Depends, FastAPI
fromfastapi.securityimport OAuth2PasswordBearer
frompydanticimport BaseModel
fromtyping_extensionsimport Annotated
app = FastAPI()
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
classUser(BaseModel):
  username: str
  email: Union[str, None] = None
  full_name: Union[str, None] = None
  disabled: Union[bool, None] = None
deffake_decode_token(token):
  return User(
    username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
  )
async defget_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
  user = fake_decode_token(token)
  return user
@app.get("/users/me")
async defread_users_me(current_user: Annotated[User, Depends(get_current_user)]):
  return current_user

```

Tip
Prefer to use the `Annotated` version if possible.
```
fromfastapiimport Depends, FastAPI
fromfastapi.securityimport OAuth2PasswordBearer
frompydanticimport BaseModel
app = FastAPI()
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
classUser(BaseModel):
  username: str
  email: str | None = None
  full_name: str | None = None
  disabled: bool | None = None
deffake_decode_token(token):
  return User(
    username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
  )
async defget_current_user(token: str = Depends(oauth2_scheme)):
  user = fake_decode_token(token)
  return user
@app.get("/users/me")
async defread_users_me(current_user: User = Depends(get_current_user)):
  return current_user

```

Tip
Prefer to use the `Annotated` version if possible.
```
fromtypingimport Union
fromfastapiimport Depends, FastAPI
fromfastapi.securityimport OAuth2PasswordBearer
frompydanticimport BaseModel
app = FastAPI()
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
classUser(BaseModel):
  username: str
  email: Union[str, None] = None
  full_name: Union[str, None] = None
  disabled: Union[bool, None] = None
deffake_decode_token(token):
  return User(
    username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
  )
async defget_current_user(token: str = Depends(oauth2_scheme)):
  user = fake_decode_token(token)
  return user
@app.get("/users/me")
async defread_users_me(current_user: User = Depends(get_current_user)):
  return current_user

```

Notice that we declare the type of `current_user` as the Pydantic model `User`.
This will help us inside of the function with all the completion and type checks.
Tip
You might remember that request bodies are also declared with Pydantic models.
Here **FastAPI** won't get confused because you are using `Depends`.
Check
The way this dependency system is designed allows us to have different dependencies (different "dependables") that all return a `User` model.
We are not restricted to having only one dependency that can return that type of data.
## Other models[¶](https://fastapi.tiangolo.com/tutorial/security/get-current-user/#other-models "Permanent link")
You can now get the current user directly in the _path operation functions_ and deal with the security mechanisms at the **Dependency Injection** level, using `Depends`.
And you can use any model or data for the security requirements (in this case, a Pydantic model `User`).
But you are not restricted to using some specific data model, class or type.
Do you want to have an `id` and `email` and not have any `username` in your model? Sure. You can use these same tools.
Do you want to just have a `str`? Or just a `dict`? Or a database class model instance directly? It all works the same way.
You actually don't have users that log in to your application but robots, bots, or other systems, that have just an access token? Again, it all works the same.
Just use any kind of model, any kind of class, any kind of database that you need for your application. **FastAPI** has you covered with the dependency injection system.
## Code size[¶](https://fastapi.tiangolo.com/tutorial/security/get-current-user/#code-size "Permanent link")
This example might seem verbose. Keep in mind that we are mixing security, data models, utility functions and _path operations_ in the same file.
But here's the key point.
The security and dependency injection stuff is written once.
And you can make it as complex as you want. And still, have it written only once, in a single place. With all the flexibility.
But you can have thousands of endpoints (_path operations_) using the same security system.
And all of them (or any portion of them that you want) can take advantage of re-using these dependencies or any other dependencies you create.
And all these thousands of _path operations_ can be as small as 3 lines:
[Python 3.10+](https://fastapi.tiangolo.com/tutorial/security/get-current-user/#__tabbed_11_1)