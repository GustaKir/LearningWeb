Title: Using Multiple Models in FastAPI
URL: https://fastapi.tiangolo.com/tutorial/extra-models/
Summary: This section discusses how to effectively use multiple models in FastAPI, covering topics such as unpacking dictionaries, utilizing Pydantic's `.dict()` method, and reducing duplication in model definitions. Additionally, it addresses the use of `Union` or `anyOf` for type representation in models.
---

Table of contents 
  * [ Multiple models  ](https://fastapi.tiangolo.com/tutorial/extra-models/#multiple-models)
    * [ About `**user_in.dict()` ](https://fastapi.tiangolo.com/tutorial/extra-models/#about-user_indict)
      * [ Pydantic's `.dict()` ](https://fastapi.tiangolo.com/tutorial/extra-models/#pydantics-dict)
      * [ Unpacking a `dict` ](https://fastapi.tiangolo.com/tutorial/extra-models/#unpacking-a-dict)
      * [ A Pydantic model from the contents of another  ](https://fastapi.tiangolo.com/tutorial/extra-models/#a-pydantic-model-from-the-contents-of-another)
      * [ Unpacking a `dict` and extra keywords  ](https://fastapi.tiangolo.com/tutorial/extra-models/#unpacking-a-dict-and-extra-keywords)
  * [ Reduce duplication  ](https://fastapi.tiangolo.com/tutorial/extra-models/#reduce-duplication)
  * [ `Union` or `anyOf` ](https://fastapi.tiangolo.com/tutorial/extra-models/#union-or-anyof)
    * [ `Union` in Python 3.10  ](https://fastapi.tiangolo.com/tutorial/extra-models/#union-in-python-310)
  * [ List of models  ](https://fastapi.tiangolo.com/tutorial/extra-models/#list-of-models)
  * [ Response with arbitrary `dict` ](https://fastapi.tiangolo.com/tutorial/extra-models/#response-with-arbitrary-dict)
  * [ Recap  ](https://fastapi.tiangolo.com/tutorial/extra-models/#recap)


  1. [ FastAPI  ](https://fastapi.tiangolo.com/)
  2. [ Learn  ](https://fastapi.tiangolo.com/learn/)
  3. [ Tutorial - User Guide  ](https://fastapi.tiangolo.com/tutorial/)


# Extra Models[Â¶](https://fastapi.tiangolo.com/tutorial/extra-models/#extra-models "Permanent link")
Continuing with the previous example, it will be common to have more than one related model.
This is especially the case for user models, because:
  * The **input model** needs to be able to have a password.
  * The **output model** should not have a password.
  * The **database model** would probably need to have a hashed password.


Danger
Never store user's plaintext passwords. Always store a "secure hash" that you can then verify.
If you don't know, you will learn what a "password hash" is in the [security chapters](https://fastapi.tiangolo.com/tutorial/security/simple-oauth2/#password-hashing).
## Multiple models[Â¶](https://fastapi.tiangolo.com/tutorial/extra-models/#multiple-models "Permanent link")
Here's a general idea of how the models could look like with their password fields and the places where they are used:
[Python 3.10+](https://fastapi.tiangolo.com/tutorial/extra-models/#__tabbed_1_1)
```
fromfastapiimport FastAPI
frompydanticimport BaseModel, EmailStr
app = FastAPI()
classUserIn(BaseModel):
  username: str
  password: str
  email: EmailStr
  full_name: str | None = None
classUserOut(BaseModel):
  username: str
  email: EmailStr
  full_name: str | None = None
classUserInDB(BaseModel):
  username: str
  hashed_password: str
  email: EmailStr
  full_name: str | None = None
deffake_password_hasher(raw_password: str):
  return "supersecret" + raw_password
deffake_save_user(user_in: UserIn):
  hashed_password = fake_password_hasher(user_in.password)
  user_in_db = UserInDB(**user_in.dict(), hashed_password=hashed_password)
  print("User saved! ..not really")
  return user_in_db
@app.post("/user/", response_model=UserOut)
async defcreate_user(user_in: UserIn):
  user_saved = fake_save_user(user_in)
  return user_saved

```

ðŸ¤“ Other versions and variants
[Python 3.8+](https://fastapi.tiangolo.com/tutorial/extra-models/#__tabbed_2_1)
```
fromtypingimport Union
fromfastapiimport FastAPI
frompydanticimport BaseModel, EmailStr
app = FastAPI()
classUserIn(BaseModel):
  username: str
  password: str
  email: EmailStr
  full_name: Union[str, None] = None
classUserOut(BaseModel):
  username: str
  email: EmailStr
  full_name: Union[str, None] = None
classUserInDB(BaseModel):
  username: str
  hashed_password: str
  email: EmailStr
  full_name: Union[str, None] = None
deffake_password_hasher(raw_password: str):
  return "supersecret" + raw_password
deffake_save_user(user_in: UserIn):
  hashed_password = fake_password_hasher(user_in.password)
  user_in_db = UserInDB(**user_in.dict(), hashed_password=hashed_password)
  print("User saved! ..not really")
  return user_in_db
@app.post("/user/", response_model=UserOut)
async defcreate_user(user_in: UserIn):
  user_saved = fake_save_user(user_in)
  return user_saved