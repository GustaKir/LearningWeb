Title: Implementing OAuth2 Scopes in FastAPI
URL: https://fastapi.tiangolo.com/advanced/security/oauth2-scopes/
Summary: This document explains how to use OAuth2 scopes in FastAPI for secure API access. It includes code snippets for user authentication, token generation, and permission management using JSON Web Tokens (JWT), alongside setting up a fake user database.
---

n {"status": "ok"}

```

```
fromdatetimeimport datetime, timedelta, timezone
fromtypingimport List, Union
importjwt
fromfastapiimport Depends, FastAPI, HTTPException, Security, status
fromfastapi.securityimport (
  OAuth2PasswordBearer,
  OAuth2PasswordRequestForm,
  SecurityScopes,
)
fromjwt.exceptionsimport InvalidTokenError
frompasslib.contextimport CryptContext
frompydanticimport BaseModel, ValidationError
fromtyping_extensionsimport Annotated
# to get a string like this run:
# openssl rand -hex 32
SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30
fake_users_db = {
  "johndoe": {
    "username": "johndoe",
    "full_name": "John Doe",
    "email": "johndoe@example.com",
    "hashed_password": "$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW",
    "disabled": False,
  },
  "alice": {
    "username": "alice",
    "full_name": "Alice Chains",
    "email": "alicechains@example.com",
    "hashed_password": "$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm",
    "disabled": True,
  },
}
classToken(BaseModel):
  access_token: str
  token_type: str
classTokenData(BaseModel):
  username: Union[str, None] = None
  scopes: List[str] = []
classUser(BaseModel):
  username: str
  email: Union[str, None] = None
  full_name: Union[str, None] = None
  disabled: Union[bool, None] = None
classUserInDB(User):
  hashed_password: str
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(
  tokenUrl="token",
  scopes={"me": "Read information about the current user.", "items": "Read items."},
)
app = FastAPI()
defverify_password(plain_password, hashed_password):
  return pwd_context.verify(plain_password, hashed_password)
defget_password_hash(password):
  return pwd_context.hash(password)
defget_user(db, username: str):
  if username in db:
    user_dict = db[username]
    return UserInDB(**user_dict)
defauthenticate_user(fake_db, username: str, password: str):
  user = get_user(fake_db, username)
  if not user:
    return False
  if not verify_password(password, user.hashed_password):
    return False
  return user
defcreate_access_token(data: dict, expires_delta: Union[timedelta, None] = None):
  to_encode = data.copy()
  if expires_delta:
    expire = datetime.now(timezone.utc) + expires_delta
  else:
    expire = datetime.now(timezone.utc) + timedelta(minutes=15)
  to_encode.update({"exp": expire})
  encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
  return encoded_jwt
async defget_current_user(
  security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)]
):
  if security_scopes.scopes:
    authenticate_value = f'Bearer scope="{security_scopes.scope_str}"'
  else:
    authenticate_value = "Bearer"
  credentials_exception = HTTPException(
    status_code=status.HTTP_401_UNAUTHORIZED,
    detail="Could not validate credentials",
    headers={"WWW-Authenticate": authenticate_value},
  )
  try:
    payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
    username = payload.get("sub")
    if username is None:
      raise credentials_exception
    token_scopes = payload.get("scopes", [])
    token_data = TokenData(scopes=token_scopes, username=username)
  except (InvalidTokenError, ValidationError):
    raise credentials_exception
  user = get_user(fake_users_db, username=token_data.username)
  if user is None:
    raise credentials_exception
  for scope in security_scopes.scopes:
    if scope not in token_data.scopes:
      raise HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Not enough permissions",
        headers={"WWW-Authenticate": authenticate_value},
      )
  return user
async defget_current_active_user(
  current_user: Annotated[User, Security(get_current_user, scopes=["me"])],
):
  if current_user.disabled:
    raise HTTPException(status_code=400, detail="Inactive user")
  return current_user
@app.post("/token")
async deflogin_for_access_token(
  form_data: Annotated[OAuth2PasswordRequestForm, Depends()],
) -> Token:
  user = authenticate_user(fake_users_db, form_data.username, form_data.password)
  if not user:
    raise HTTPException(status_code=400, detail="Incorrect username or password")
  access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
  access_token = create_access_token(
    data={"sub": user.username, "scopes": form_data.scopes},
    expires_delta=access_token_expires,
  )
  return Token(access_token=access_token, token_type="bearer")
@app.get("/users/me/", response_model=User)
async defread_users_me(
  current_user: Annotated[User, Depends(get_current_active_user)],
):
  return current_user
@app.get("/users/me/items/")
async defread_own_items(
  current_user: Annotated[User, Security(get_current_active_user, scopes=["items"])],
):
  return [{"item_id": "Foo", "owner": current_user.username}]
@app.get("/status/")
async defread_system_status(current_