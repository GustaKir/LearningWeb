Title: Alternatives to FastAPI
URL: https://fastapi.tiangolo.com/alternatives/
Summary: This section discusses alternatives to FastAPI, highlighting the user's experience with Flask and related libraries. It mentions the combination of Flask with Flask-apispec, Marshmallow, and Webargs as a favored stack before transitioning to FastAPI. The author references various full-stack generators derived from Flask that informed the FastAPI project generators.
---

ght be due to its documentation being too concise and abstract.
This solved having to write YAML (another syntax) inside of Python docstrings.
This combination of Flask, Flask-apispec with Marshmallow and Webargs was my favorite backend stack until building **FastAPI**.
Using it led to the creation of several Flask full-stack generators. These are the main stacks I (and several external teams) have been using up to now:
  * <https://github.com/tiangolo/full-stack>
  * <https://github.com/tiangolo/full-stack-flask-couchbase>
  * <https://github.com/tiangolo/full-stack-flask-couchdb>


And these same full-stack generators were the base of the [**FastAPI** Project Generators](https://fastapi.tiangolo.com/project-generation/).
Info
Flask-apispec was created by the same Marshmallow developers.
Inspired **FastAPI** to
Generate the OpenAPI schema automatically, from the same code that defines serialization and validation.
### [NestJS](https://nestjs.com/) (and [Angular](https://angular.io/))[¶](https://fastapi.tiangolo.com/alternatives/#nestjs-and-angular "Permanent link")
This isn't even Python, NestJS is a JavaScript (TypeScript) NodeJS framework inspired by Angular.
It achieves something somewhat similar to what can be done with Flask-apispec.
It has an integrated dependency injection system, inspired by Angular 2. It requires pre-registering the "injectables" (like all the other dependency injection systems I know), so, it adds to the verbosity and code repetition.
As the parameters are described with TypeScript types (similar to Python type hints), editor support is quite good.
But as TypeScript data is not preserved after compilation to JavaScript, it cannot rely on the types to define validation, serialization and documentation at the same time. Due to this and some design decisions, to get validation, serialization and automatic schema generation, it's needed to add decorators in many places. So, it becomes quite verbose.
It can't handle nested models very well. So, if the JSON body in the request is a JSON object that has inner fields that in turn are nested JSON objects, it cannot be properly documented and validated.
Inspired **FastAPI** to
Use Python types to have great editor support.
Have a powerful dependency injection system. Find a way to minimize code repetition.
### [Sanic](https://sanic.readthedocs.io/en/latest/)[¶](https://fastapi.tiangolo.com/alternatives/#sanic "Permanent link")
It was one of the first extremely fast Python frameworks based on `asyncio`. It was made to be very similar to Flask.
Technical Details
It used [`uvloop`](https://github.com/MagicStack/uvloop) instead of the default Python `asyncio` loop. That's what made it so fast.
It clearly inspired Uvicorn and Starlette, that are currently faster than Sanic in open benchmarks.
Inspired **FastAPI** to
Find a way to have a crazy performance.
That's why **FastAPI** is based on Starlette, as it is the fastest framework available (tested by third-party benchmarks).
### [Falcon](https://falconframework.org/)[¶](https://fastapi.tiangolo.com/alternatives/#falcon "Permanent link")
Falcon is another high performance Python framework, it is designed to be minimal, and work as the foundation of other frameworks like Hug.
It is designed to have functions that receive two parameters, one "request" and one "response". Then you "read" parts from the request, and "write" parts to the response. Because of this design, it is not possible to declare request parameters and bodies with standard Python type hints as function parameters.
So, data validation, serialization, and documentation, have to be done in code, not automatically. Or they have to be implemented as a framework on top of Falcon, like Hug. This same distinction happens in other frameworks that are inspired by Falcon's design, of having one request object and one response object as parameters.
Inspired **FastAPI** to
Find ways to get great performance.
Along with Hug (as Hug is based on Falcon) inspired **FastAPI** to declare a `response` parameter in functions.
Although in FastAPI it's optional, and is used mainly to set headers, cookies, and alternative status codes.
### [Molten](https://moltenframework.com/)[¶](https://fastapi.tiangolo.com/alternatives/#molten "Permanent link")
I discovered Molten in the first stages of building **FastAPI**. And it has quite similar ideas:
  * Based on Python type hints.
  * Validation and documentation from these types.
  * Dependency Injection system.