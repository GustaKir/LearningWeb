Title: Using Pydantic's Model Method in FastAPI
URL: https://fastapi.tiangolo.com/tutorial/extra-models/
Summary: This section discusses the transition from Pydantic v1's `.dict()` method to v2's `.model_dump()`. It illustrates how to create a Pydantic model instance and extract its data as a dictionary using the deprecated `.dict()` method, while recommending the use of `.model_dump()` in new implementations.
---

```

Info
In Pydantic v1 the method was called `.dict()`, it was deprecated (but still supported) in Pydantic v2, and renamed to `.model_dump()`.
The examples here use `.dict()` for compatibility with Pydantic v1, but you should use `.model_dump()` instead if you can use Pydantic v2.
### About `**user_in.dict()`[¶](https://fastapi.tiangolo.com/tutorial/extra-models/#about-user_indict "Permanent link")
#### Pydantic's `.dict()`[¶](https://fastapi.tiangolo.com/tutorial/extra-models/#pydantics-dict "Permanent link")
`user_in` is a Pydantic model of class `UserIn`.
Pydantic models have a `.dict()` method that returns a `dict` with the model's data.
So, if we create a Pydantic object `user_in` like:
```
user_in = UserIn(username="john", password="secret", email="john.doe@example.com")

```

and then we call:
```
user_dict = user_in.dict()

```

we now have a `dict` with the data in the variable `user_dict` (it's a `dict` instead of a Pydantic model object).
And if we call:
```
print(user_dict)

```

we would get a Python `dict` with:
```
{
  'username': 'john',
  'password': 'secret',
  'email': 'john.doe@example.com',
  'full_name': None,
}

```

#### Unpacking a `dict`[¶](https://fastapi.tiangolo.com/tutorial/extra-models/#unpacking-a-dict "Permanent link")
If we take a `dict` like `user_dict` and pass it to a function (or class) with `**user_dict`, Python will "unpack" it. It will pass the keys and values of the `user_dict` directly as key-value arguments.
So, continuing with the `user_dict` from above, writing:
```
UserInDB(**user_dict)

```

would result in something equivalent to:
```
UserInDB(
  username="john",
  password="secret",
  email="john.doe@example.com",
  full_name=None,
)

```

Or more exactly, using `user_dict` directly, with whatever contents it might have in the future:
```
UserInDB(
  username = user_dict["username"],
  password = user_dict["password"],
  email = user_dict["email"],
  full_name = user_dict["full_name"],
)

```

#### A Pydantic model from the contents of another[¶](https://fastapi.tiangolo.com/tutorial/extra-models/#a-pydantic-model-from-the-contents-of-another "Permanent link")
As in the example above we got `user_dict` from `user_in.dict()`, this code:
```
user_dict = user_in.dict()
UserInDB(**user_dict)

```

would be equivalent to:
```
UserInDB(**user_in.dict())

```

...because `user_in.dict()` is a `dict`, and then we make Python "unpack" it by passing it to `UserInDB` prefixed with `**`.
So, we get a Pydantic model from the data in another Pydantic model.
#### Unpacking a `dict` and extra keywords[¶](https://fastapi.tiangolo.com/tutorial/extra-models/#unpacking-a-dict-and-extra-keywords "Permanent link")
And then adding the extra keyword argument `hashed_password=hashed_password`, like in:
```
UserInDB(**user_in.dict(), hashed_password=hashed_password)

```

...ends up being like:
```
UserInDB(
  username = user_dict["username"],
  password = user_dict["password"],
  email = user_dict["email"],
  full_name = user_dict["full_name"],
  hashed_password = hashed_password,
)

```

Warning
The supporting additional functions `fake_password_hasher` and `fake_save_user` are just to demo a possible flow of the data, but they of course are not providing any real security.
## Reduce duplication[¶](https://fastapi.tiangolo.com/tutorial/extra-models/#reduce-duplication "Permanent link")
Reducing code duplication is one of the core ideas in **FastAPI**.
As code duplication increments the chances of bugs, security issues, code desynchronization issues (when you update in one place but not in the others), etc.
And these models are all sharing a lot of the data and duplicating attribute names and types.
We could do better.
We can declare a `UserBase` model that serves as a base for our other models. And then we can make subclasses of that model that inherit its attributes (type declarations, validation, etc).
All the data conversion, validation, documentation, etc. will still work as normally.
That way, we can declare just the differences between the models (with plaintext `password`, with `hashed_password` and without password):
[Python 3.10+](https://fastapi.tiangolo.com/tutorial/extra-models/#__tabbed_3_1)
```
fromfastapiimport FastAPI
frompydanticimport BaseModel, EmailStr
app = FastAPI()
classUserBase(BaseModel):
  username: str
  email: EmailStr
  full_name: str | None = None
classUserIn(UserBase):
  password: str
classUserOut(UserBase):
  pass
classUserInDB(UserBase):
  hashed_password: str
deffake_password_hasher(raw_password: str):
  return "supersecret" + raw_password
deffake_save_user(user_in: UserIn):
  hashed_password = fake_password_hasher(user_in.password)
  user_in_db = UserInDB(**user_in.dict(), hashed_password=hashed_password)
  print("User saved! ..not really")
  return user_in_db
@app.post("/user/", response_model=UserOut)
async defcreate_user(user_in: UserIn):
  user_saved = fake_save_user(user_in)
  return user_saved