Title: Using Additional Responses in FastAPI
URL: https://fastapi.tiangolo.com/advanced/additional-responses/
Summary: This section demonstrates how to configure FastAPI to return multiple response types for a single endpoint. It illustrates the use of `FileResponse` to send an image file or a JSON item based on a query parameter. Explicit media types must be defined in the `responses` parameter to handle different response formats correctly.
---

```
fromtypingimport Union
fromfastapiimport FastAPI
fromfastapi.responsesimport FileResponse
frompydanticimport BaseModel
classItem(BaseModel):
  id: str
  value: str
app = FastAPI()
@app.get(
  "/items/{item_id}",
  response_model=Item,
  responses={
    200: {
      "content": {"image/png": {}},
      "description": "Return the JSON item or an image.",
    }
  },
)
async defread_item(item_id: str, img: Union[bool, None] = None):
  if img:
    return FileResponse("image.png", media_type="image/png")
  else:
    return {"id": "foo", "value": "there goes my hero"}

```

Note
Notice that you have to return the image using a `FileResponse` directly.
Info
Unless you specify a different media type explicitly in your `responses` parameter, FastAPI will assume the response has the same media type as the main response class (default `application/json`).
But if you have specified a custom response class with `None` as its media type, FastAPI will use `application/json` for any additional response that has an associated model.
## Combining information[¶](https://fastapi.tiangolo.com/advanced/additional-responses/#combining-information "Permanent link")
You can also combine response information from multiple places, including the `response_model`, `status_code`, and `responses` parameters.
You can declare a `response_model`, using the default status code `200` (or a custom one if you need), and then declare additional information for that same response in `responses`, directly in the OpenAPI schema.
**FastAPI** will keep the additional information from `responses`, and combine it with the JSON Schema from your model.
For example, you can declare a response with a status code `404` that uses a Pydantic model and has a custom `description`.
And a response with a status code `200` that uses your `response_model`, but includes a custom `example`:
[Python 3.8+](https://fastapi.tiangolo.com/advanced/additional-responses/#__tabbed_3_1)
```
fromfastapiimport FastAPI
fromfastapi.responsesimport JSONResponse
frompydanticimport BaseModel
classItem(BaseModel):
  id: str
  value: str
classMessage(BaseModel):
  message: str
app = FastAPI()
@app.get(
  "/items/{item_id}",
  response_model=Item,
  responses={
    404: {"model": Message, "description": "The item was not found"},
    200: {
      "description": "Item requested by ID",
      "content": {
        "application/json": {
          "example": {"id": "bar", "value": "The bar tenders"}
        }
      },
    },
  },
)
async defread_item(item_id: str):
  if item_id == "foo":
    return {"id": "foo", "value": "there goes my hero"}
  else:
    return JSONResponse(status_code=404, content={"message": "Item not found"})

```

It will all be combined and included in your OpenAPI, and shown in the API docs:
![](https://fastapi.tiangolo.com/img/tutorial/additional-responses/image01.png)
## Combine predefined responses and custom ones[¶](https://fastapi.tiangolo.com/advanced/additional-responses/#combine-predefined-responses-and-custom-ones "Permanent link")
You might want to have some predefined responses that apply to many _path operations_ , but you want to combine them with custom responses needed by each _path operation_.
For those cases, you can use the Python technique of "unpacking" a `dict` with `**dict_to_unpack`:
```
old_dict = {
  "old key": "old value",
  "second old key": "second old value",
}
new_dict = {**old_dict, "new key": "new value"}

```

Here, `new_dict` will contain all the key-value pairs from `old_dict` plus the new key-value pair:
```
{
  "old key": "old value",
  "second old key": "second old value",
  "new key": "new value",
}

```

You can use that technique to reuse some predefined responses in your _path operations_ and combine them with additional custom ones.
For example:
[Python 3.8+](https://fastapi.tiangolo.com/advanced/additional-responses/#__tabbed_4_1)
```
fromtypingimport Union
fromfastapiimport FastAPI
fromfastapi.responsesimport FileResponse
frompydanticimport BaseModel
classItem(BaseModel):
  id: str
  value: str
responses = {
  404: {"description": "Item not found"},
  302: {"description": "The item was moved"},
  403: {"description": "Not enough privileges"},
}
app = FastAPI()
@app.get(
  "/items/{item_id}",
  response_model=Item,
  responses={**responses, 200: {"content": {"image/png": {}}}},
)
async defread_item(item_id: str, img: Union[bool, None] = None):
  if img:
    return FileResponse("image.png", media_type="image/png")
  else:
    return {"id": "foo", "value": "there goes my hero"}